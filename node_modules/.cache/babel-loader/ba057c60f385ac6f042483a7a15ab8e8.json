{"ast":null,"code":"/*\n Highmaps JS v6.2.0 (2018-10-17)\n\n (c) 2011-2016 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (R, M) {\n  \"object\" === typeof module && module.exports ? module.exports = R.document ? M(R) : M : \"function\" === typeof define && define.amd ? define(function () {\n    return M(R);\n  }) : R.Highcharts = M(R);\n})(\"undefined\" !== typeof window ? window : this, function (R) {\n  var M = function () {\n    var a = \"undefined\" === typeof R ? window : R,\n        B = a.document,\n        C = a.navigator && a.navigator.userAgent || \"\",\n        D = B && B.createElementNS && !!B.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        n = /(edge|msie|trident)/i.test(C) && !a.opera,\n        d = -1 !== C.indexOf(\"Firefox\"),\n        k = -1 !== C.indexOf(\"Chrome\"),\n        u = d && 4 > parseInt(C.split(\"Firefox/\")[1], 10);\n    return a.Highcharts ? a.Highcharts.error(16, !0) : {\n      product: \"Highmaps\",\n      version: \"6.2.0\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: B,\n      hasBidiBug: u,\n      hasTouch: B && void 0 !== B.documentElement.ontouchstart,\n      isMS: n,\n      isWebKit: -1 !== C.indexOf(\"AppleWebKit\"),\n      isFirefox: d,\n      isChrome: k,\n      isSafari: !k && -1 !== C.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(C),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: D,\n      win: a,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function noop() {},\n      charts: []\n    };\n  }();\n\n  (function (a) {\n    a.timers = [];\n    var B = a.charts,\n        C = a.doc,\n        D = a.win;\n\n    a.error = function (n, d) {\n      n = a.isNumber(n) ? \"Highcharts error #\" + n + \": www.highcharts.com/errors/\" + n : n;\n      if (d) throw Error(n);\n      D.console && console.log(n);\n    };\n\n    a.Fx = function (a, d, k) {\n      this.options = d;\n      this.elem = a;\n      this.prop = k;\n    };\n\n    a.Fx.prototype = {\n      dSetter: function dSetter() {\n        var a = this.paths[0],\n            d = this.paths[1],\n            k = [],\n            u = this.now,\n            v = a.length,\n            q;\n        if (1 === u) k = this.toD;else if (v === d.length && 1 > u) for (; v--;) {\n          q = parseFloat(a[v]), k[v] = isNaN(q) ? d[v] : u * parseFloat(d[v] - q) + q;\n        } else k = d;\n        this.elem.attr(\"d\", k, null, !0);\n      },\n      update: function update() {\n        var a = this.elem,\n            d = this.prop,\n            k = this.now,\n            u = this.options.step;\n        if (this[d + \"Setter\"]) this[d + \"Setter\"]();else a.attr ? a.element && a.attr(d, k, null, !0) : a.style[d] = k + this.unit;\n        u && u.call(a, k, this);\n      },\n      run: function run(n, d, k) {\n        var u = this,\n            v = u.options,\n            q = function q(a) {\n          return q.stopped ? !1 : u.step(a);\n        },\n            p = D.requestAnimationFrame || function (a) {\n          setTimeout(a, 13);\n        },\n            y = function y() {\n          for (var g = 0; g < a.timers.length; g++) {\n            a.timers[g]() || a.timers.splice(g--, 1);\n          }\n\n          a.timers.length && p(y);\n        };\n\n        n !== d || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = n, this.end = d, this.unit = k, this.now = this.start, this.pos = 0, q.elem = this.elem, q.prop = this.prop, q() && 1 === a.timers.push(q) && p(y)) : (delete v.curAnim[this.prop], v.complete && 0 === a.keys(v.curAnim).length && v.complete.call(this.elem));\n      },\n      step: function step(n) {\n        var d = +new Date(),\n            k,\n            u = this.options,\n            v = this.elem,\n            q = u.complete,\n            p = u.duration,\n            y = u.curAnim;\n        v.attr && !v.element ? n = !1 : n || d >= p + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), k = y[this.prop] = !0, a.objectEach(y, function (a) {\n          !0 !== a && (k = !1);\n        }), k && q && q.call(v), n = !1) : (this.pos = u.easing((d - this.startTime) / p), this.now = this.start + (this.end - this.start) * this.pos, this.update(), n = !0);\n        return n;\n      },\n      initPath: function initPath(n, d, k) {\n        function u(a) {\n          var b, c;\n\n          for (f = a.length; f--;) {\n            b = \"M\" === a[f] || \"L\" === a[f], c = /[a-zA-Z]/.test(a[f + 3]), b && c && a.splice(f + 1, 0, a[f + 1], a[f + 2], a[f + 1], a[f + 2]);\n          }\n        }\n\n        function v(a, c) {\n          for (; a.length < b;) {\n            a[0] = c[b - a.length];\n            var h = a.slice(0, m);\n            [].splice.apply(a, [0, 0].concat(h));\n            e && (h = a.slice(a.length - m), [].splice.apply(a, [a.length, 0].concat(h)), f--);\n          }\n\n          a[0] = \"M\";\n        }\n\n        function q(a, f) {\n          for (var g = (b - a.length) / m; 0 < g && g--;) {\n            c = a.slice().splice(a.length / w - m, m * w), c[0] = f[b - m - g * m], h && (c[m - 6] = c[m - 2], c[m - 5] = c[m - 1]), [].splice.apply(a, [a.length / w, 0].concat(c)), e && g--;\n          }\n        }\n\n        d = d || \"\";\n        var p,\n            y = n.startX,\n            g = n.endX,\n            h = -1 < d.indexOf(\"C\"),\n            m = h ? 7 : 3,\n            b,\n            c,\n            f;\n        d = d.split(\" \");\n        k = k.slice();\n        var e = n.isArea,\n            w = e ? 2 : 1,\n            G;\n        h && (u(d), u(k));\n\n        if (y && g) {\n          for (f = 0; f < y.length; f++) {\n            if (y[f] === g[0]) {\n              p = f;\n              break;\n            } else if (y[0] === g[g.length - y.length + f]) {\n              p = f;\n              G = !0;\n              break;\n            }\n          }\n\n          void 0 === p && (d = []);\n        }\n\n        d.length && a.isNumber(p) && (b = k.length + p * w * m, G ? (v(d, k), q(k, d)) : (v(k, d), q(d, k)));\n        return [d, k];\n      },\n      fillSetter: function fillSetter() {\n        a.Fx.prototype.strokeSetter.apply(this, arguments);\n      },\n      strokeSetter: function strokeSetter() {\n        this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, !0);\n      }\n    };\n\n    a.merge = function () {\n      var n,\n          d = arguments,\n          k,\n          u = {},\n          v = function v(q, p) {\n        \"object\" !== typeof q && (q = {});\n        a.objectEach(p, function (n, g) {\n          !a.isObject(n, !0) || a.isClass(n) || a.isDOMElement(n) ? q[g] = p[g] : q[g] = v(q[g] || {}, n);\n        });\n        return q;\n      };\n\n      !0 === d[0] && (u = d[1], d = Array.prototype.slice.call(d, 2));\n      k = d.length;\n\n      for (n = 0; n < k; n++) {\n        u = v(u, d[n]);\n      }\n\n      return u;\n    };\n\n    a.pInt = function (a, d) {\n      return parseInt(a, d || 10);\n    };\n\n    a.isString = function (a) {\n      return \"string\" === typeof a;\n    };\n\n    a.isArray = function (a) {\n      a = Object.prototype.toString.call(a);\n      return \"[object Array]\" === a || \"[object Array Iterator]\" === a;\n    };\n\n    a.isObject = function (n, d) {\n      return !!n && \"object\" === typeof n && (!d || !a.isArray(n));\n    };\n\n    a.isDOMElement = function (n) {\n      return a.isObject(n) && \"number\" === typeof n.nodeType;\n    };\n\n    a.isClass = function (n) {\n      var d = n && n.constructor;\n      return !(!a.isObject(n, !0) || a.isDOMElement(n) || !d || !d.name || \"Object\" === d.name);\n    };\n\n    a.isNumber = function (a) {\n      return \"number\" === typeof a && !isNaN(a) && Infinity > a && -Infinity < a;\n    };\n\n    a.erase = function (a, d) {\n      for (var k = a.length; k--;) {\n        if (a[k] === d) {\n          a.splice(k, 1);\n          break;\n        }\n      }\n    };\n\n    a.defined = function (a) {\n      return void 0 !== a && null !== a;\n    };\n\n    a.attr = function (n, d, k) {\n      var u;\n      a.isString(d) ? a.defined(k) ? n.setAttribute(d, k) : n && n.getAttribute && ((u = n.getAttribute(d)) || \"class\" !== d || (u = n.getAttribute(d + \"Name\"))) : a.defined(d) && a.isObject(d) && a.objectEach(d, function (a, q) {\n        n.setAttribute(q, a);\n      });\n      return u;\n    };\n\n    a.splat = function (n) {\n      return a.isArray(n) ? n : [n];\n    };\n\n    a.syncTimeout = function (a, d, k) {\n      if (d) return setTimeout(a, d, k);\n      a.call(0, k);\n    };\n\n    a.clearTimeout = function (n) {\n      a.defined(n) && clearTimeout(n);\n    };\n\n    a.extend = function (a, d) {\n      var k;\n      a || (a = {});\n\n      for (k in d) {\n        a[k] = d[k];\n      }\n\n      return a;\n    };\n\n    a.pick = function () {\n      var a = arguments,\n          d,\n          k,\n          u = a.length;\n\n      for (d = 0; d < u; d++) {\n        if (k = a[d], void 0 !== k && null !== k) return k;\n      }\n    };\n\n    a.css = function (n, d) {\n      a.isMS && !a.svg && d && void 0 !== d.opacity && (d.filter = \"alpha(opacity\\x3d\" + 100 * d.opacity + \")\");\n      a.extend(n.style, d);\n    };\n\n    a.createElement = function (n, d, k, u, v) {\n      n = C.createElement(n);\n      var q = a.css;\n      d && a.extend(n, d);\n      v && q(n, {\n        padding: 0,\n        border: \"none\",\n        margin: 0\n      });\n      k && q(n, k);\n      u && u.appendChild(n);\n      return n;\n    };\n\n    a.extendClass = function (n, d) {\n      var k = function k() {};\n\n      k.prototype = new n();\n      a.extend(k.prototype, d);\n      return k;\n    };\n\n    a.pad = function (a, d, k) {\n      return Array((d || 2) + 1 - String(a).replace(\"-\", \"\").length).join(k || 0) + a;\n    };\n\n    a.relativeLength = function (a, d, k) {\n      return /%$/.test(a) ? d * parseFloat(a) / 100 + (k || 0) : parseFloat(a);\n    };\n\n    a.wrap = function (a, d, k) {\n      var n = a[d];\n\n      a[d] = function () {\n        var a = Array.prototype.slice.call(arguments),\n            q = arguments,\n            p = this;\n\n        p.proceed = function () {\n          n.apply(p, arguments.length ? arguments : q);\n        };\n\n        a.unshift(n);\n        a = k.apply(this, a);\n        p.proceed = null;\n        return a;\n      };\n    };\n\n    a.datePropsToTimestamps = function (n) {\n      a.objectEach(n, function (d, k) {\n        a.isObject(d) && \"function\" === typeof d.getTime ? n[k] = d.getTime() : (a.isObject(d) || a.isArray(d)) && a.datePropsToTimestamps(d);\n      });\n    };\n\n    a.formatSingle = function (n, d, k) {\n      var u = /\\.([0-9])/,\n          v = a.defaultOptions.lang;\n      /f$/.test(n) ? (k = (k = n.match(u)) ? k[1] : -1, null !== d && (d = a.numberFormat(d, k, v.decimalPoint, -1 < n.indexOf(\",\") ? v.thousandsSep : \"\"))) : d = (k || a.time).dateFormat(n, d);\n      return d;\n    };\n\n    a.format = function (n, d, k) {\n      for (var u = \"{\", v = !1, q, p, y, g, h = [], m; n;) {\n        u = n.indexOf(u);\n        if (-1 === u) break;\n        q = n.slice(0, u);\n\n        if (v) {\n          q = q.split(\":\");\n          p = q.shift().split(\".\");\n          g = p.length;\n          m = d;\n\n          for (y = 0; y < g; y++) {\n            m && (m = m[p[y]]);\n          }\n\n          q.length && (m = a.formatSingle(q.join(\":\"), m, k));\n          h.push(m);\n        } else h.push(q);\n\n        n = n.slice(u + 1);\n        u = (v = !v) ? \"}\" : \"{\";\n      }\n\n      h.push(n);\n      return h.join(\"\");\n    };\n\n    a.getMagnitude = function (a) {\n      return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));\n    };\n\n    a.normalizeTickInterval = function (n, d, k, u, v) {\n      var q,\n          p = n;\n      k = a.pick(k, 1);\n      q = n / k;\n      d || (d = v ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === u && (1 === k ? d = a.grep(d, function (a) {\n        return 0 === a % 1;\n      }) : .1 >= k && (d = [1 / k])));\n\n      for (u = 0; u < d.length && !(p = d[u], v && p * k >= n || !v && q <= (d[u] + (d[u + 1] || d[u])) / 2); u++) {\n        ;\n      }\n\n      return p = a.correctFloat(p * k, -Math.round(Math.log(.001) / Math.LN10));\n    };\n\n    a.stableSort = function (a, d) {\n      var k = a.length,\n          n,\n          v;\n\n      for (v = 0; v < k; v++) {\n        a[v].safeI = v;\n      }\n\n      a.sort(function (a, p) {\n        n = d(a, p);\n        return 0 === n ? a.safeI - p.safeI : n;\n      });\n\n      for (v = 0; v < k; v++) {\n        delete a[v].safeI;\n      }\n    };\n\n    a.arrayMin = function (a) {\n      for (var d = a.length, k = a[0]; d--;) {\n        a[d] < k && (k = a[d]);\n      }\n\n      return k;\n    };\n\n    a.arrayMax = function (a) {\n      for (var d = a.length, k = a[0]; d--;) {\n        a[d] > k && (k = a[d]);\n      }\n\n      return k;\n    };\n\n    a.destroyObjectProperties = function (n, d) {\n      a.objectEach(n, function (a, u) {\n        a && a !== d && a.destroy && a.destroy();\n        delete n[u];\n      });\n    };\n\n    a.discardElement = function (n) {\n      var d = a.garbageBin;\n      d || (d = a.createElement(\"div\"));\n      n && d.appendChild(n);\n      d.innerHTML = \"\";\n    };\n\n    a.correctFloat = function (a, d) {\n      return parseFloat(a.toPrecision(d || 14));\n    };\n\n    a.setAnimation = function (n, d) {\n      d.renderer.globalAnimation = a.pick(n, d.options.chart.animation, !0);\n    };\n\n    a.animObject = function (n) {\n      return a.isObject(n) ? a.merge(n) : {\n        duration: n ? 500 : 0\n      };\n    };\n\n    a.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    };\n\n    a.numberFormat = function (n, d, k, u) {\n      n = +n || 0;\n      d = +d;\n      var v = a.defaultOptions.lang,\n          q = (n.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          p,\n          y,\n          g = n.toString().split(\"e\");\n      -1 === d ? d = Math.min(q, 20) : a.isNumber(d) ? d && g[1] && 0 > g[1] && (p = d + +g[1], 0 <= p ? (g[0] = (+g[0]).toExponential(p).split(\"e\")[0], d = p) : (g[0] = g[0].split(\".\")[0] || 0, n = 20 > d ? (g[0] * Math.pow(10, g[1])).toFixed(d) : 0, g[1] = 0)) : d = 2;\n      y = (Math.abs(g[1] ? g[0] : n) + Math.pow(10, -Math.max(d, q) - 1)).toFixed(d);\n      q = String(a.pInt(y));\n      p = 3 < q.length ? q.length % 3 : 0;\n      k = a.pick(k, v.decimalPoint);\n      u = a.pick(u, v.thousandsSep);\n      n = (0 > n ? \"-\" : \"\") + (p ? q.substr(0, p) + u : \"\");\n      n += q.substr(p).replace(/(\\d{3})(?=\\d)/g, \"$1\" + u);\n      d && (n += k + y.slice(-d));\n      g[1] && 0 !== +n && (n += \"e\" + g[1]);\n      return n;\n    };\n\n    Math.easeInOutSine = function (a) {\n      return -.5 * (Math.cos(Math.PI * a) - 1);\n    };\n\n    a.getStyle = function (n, d, k) {\n      if (\"width\" === d) return Math.max(0, Math.min(n.offsetWidth, n.scrollWidth) - a.getStyle(n, \"padding-left\") - a.getStyle(n, \"padding-right\"));\n      if (\"height\" === d) return Math.max(0, Math.min(n.offsetHeight, n.scrollHeight) - a.getStyle(n, \"padding-top\") - a.getStyle(n, \"padding-bottom\"));\n      D.getComputedStyle || a.error(27, !0);\n      if (n = D.getComputedStyle(n, void 0)) n = n.getPropertyValue(d), a.pick(k, \"opacity\" !== d) && (n = a.pInt(n));\n      return n;\n    };\n\n    a.inArray = function (n, d, k) {\n      return (a.indexOfPolyfill || Array.prototype.indexOf).call(d, n, k);\n    };\n\n    a.grep = function (n, d) {\n      return (a.filterPolyfill || Array.prototype.filter).call(n, d);\n    };\n\n    a.find = Array.prototype.find ? function (a, d) {\n      return a.find(d);\n    } : function (a, d) {\n      var k,\n          n = a.length;\n\n      for (k = 0; k < n; k++) {\n        if (d(a[k], k)) return a[k];\n      }\n    };\n\n    a.some = function (n, d, k) {\n      return (a.somePolyfill || Array.prototype.some).call(n, d, k);\n    };\n\n    a.map = function (a, d) {\n      for (var k = [], n = 0, v = a.length; n < v; n++) {\n        k[n] = d.call(a[n], a[n], n, a);\n      }\n\n      return k;\n    };\n\n    a.keys = function (n) {\n      return (a.keysPolyfill || Object.keys).call(void 0, n);\n    };\n\n    a.reduce = function (n, d, k) {\n      return (a.reducePolyfill || Array.prototype.reduce).apply(n, 2 < arguments.length ? [d, k] : [d]);\n    };\n\n    a.offset = function (a) {\n      var d = C.documentElement;\n      a = a.parentElement || a.parentNode ? a.getBoundingClientRect() : {\n        top: 0,\n        left: 0\n      };\n      return {\n        top: a.top + (D.pageYOffset || d.scrollTop) - (d.clientTop || 0),\n        left: a.left + (D.pageXOffset || d.scrollLeft) - (d.clientLeft || 0)\n      };\n    };\n\n    a.stop = function (n, d) {\n      for (var k = a.timers.length; k--;) {\n        a.timers[k].elem !== n || d && d !== a.timers[k].prop || (a.timers[k].stopped = !0);\n      }\n    };\n\n    a.each = function (n, d, k) {\n      return (a.forEachPolyfill || Array.prototype.forEach).call(n, d, k);\n    };\n\n    a.objectEach = function (a, d, k) {\n      for (var n in a) {\n        a.hasOwnProperty(n) && d.call(k || a[n], a[n], n, a);\n      }\n    };\n\n    a.addEvent = function (n, d, k, u) {\n      var v,\n          q = n.addEventListener || a.addEventListenerPolyfill;\n      v = \"function\" === typeof n && n.prototype ? n.prototype.protoEvents = n.prototype.protoEvents || {} : n.hcEvents = n.hcEvents || {};\n      a.Point && n instanceof a.Point && n.series && n.series.chart && (n.series.chart.runTrackerClick = !0);\n      q && q.call(n, d, k, !1);\n      v[d] || (v[d] = []);\n      v[d].push(k);\n      u && a.isNumber(u.order) && (k.order = u.order, v[d].sort(function (a, q) {\n        return a.order - q.order;\n      }));\n      return function () {\n        a.removeEvent(n, d, k);\n      };\n    };\n\n    a.removeEvent = function (n, d, k) {\n      function u(p, g) {\n        var h = n.removeEventListener || a.removeEventListenerPolyfill;\n        h && h.call(n, p, g, !1);\n      }\n\n      function v(p) {\n        var g, h;\n        n.nodeName && (d ? (g = {}, g[d] = !0) : g = p, a.objectEach(g, function (a, b) {\n          if (p[b]) for (h = p[b].length; h--;) {\n            u(b, p[b][h]);\n          }\n        }));\n      }\n\n      var q, p;\n      a.each([\"protoEvents\", \"hcEvents\"], function (y) {\n        var g = n[y];\n        g && (d ? (q = g[d] || [], k ? (p = a.inArray(k, q), -1 < p && (q.splice(p, 1), g[d] = q), u(d, k)) : (v(g), g[d] = [])) : (v(g), n[y] = {}));\n      });\n    };\n\n    a.fireEvent = function (n, d, k, u) {\n      var v, q, p, y, g;\n      k = k || {};\n      C.createEvent && (n.dispatchEvent || n.fireEvent) ? (v = C.createEvent(\"Events\"), v.initEvent(d, !0, !0), a.extend(v, k), n.dispatchEvent ? n.dispatchEvent(v) : n.fireEvent(d, v)) : a.each([\"protoEvents\", \"hcEvents\"], function (h) {\n        if (n[h]) for (q = n[h][d] || [], p = q.length, k.target || a.extend(k, {\n          preventDefault: function preventDefault() {\n            k.defaultPrevented = !0;\n          },\n          target: n,\n          type: d\n        }), y = 0; y < p; y++) {\n          (g = q[y]) && !1 === g.call(n, k) && k.preventDefault();\n        }\n      });\n      u && !k.defaultPrevented && u.call(n, k);\n    };\n\n    a.animate = function (n, d, k) {\n      var u,\n          v = \"\",\n          q,\n          p,\n          y;\n      a.isObject(k) || (y = arguments, k = {\n        duration: y[2],\n        easing: y[3],\n        complete: y[4]\n      });\n      a.isNumber(k.duration) || (k.duration = 400);\n      k.easing = \"function\" === typeof k.easing ? k.easing : Math[k.easing] || Math.easeInOutSine;\n      k.curAnim = a.merge(d);\n      a.objectEach(d, function (g, h) {\n        a.stop(n, h);\n        p = new a.Fx(n, k, h);\n        q = null;\n        \"d\" === h ? (p.paths = p.initPath(n, n.d, d.d), p.toD = d.d, u = 0, q = 1) : n.attr ? u = n.attr(h) : (u = parseFloat(a.getStyle(n, h)) || 0, \"opacity\" !== h && (v = \"px\"));\n        q || (q = g);\n        q && q.match && q.match(\"px\") && (q = q.replace(/px/g, \"\"));\n        p.run(u, q, v);\n      });\n    };\n\n    a.seriesType = function (n, d, k, u, v) {\n      var q = a.getOptions(),\n          p = a.seriesTypes;\n      q.plotOptions[n] = a.merge(q.plotOptions[d], k);\n      p[n] = a.extendClass(p[d] || function () {}, u);\n      p[n].prototype.type = n;\n      v && (p[n].prototype.pointClass = a.extendClass(a.Point, v));\n      return p[n];\n    };\n\n    a.uniqueKey = function () {\n      var a = Math.random().toString(36).substring(2, 9),\n          d = 0;\n      return function () {\n        return \"highcharts-\" + a + \"-\" + d++;\n      };\n    }();\n\n    D.jQuery && (D.jQuery.fn.highcharts = function () {\n      var n = [].slice.call(arguments);\n      if (this[0]) return n[0] ? (new a[a.isString(n[0]) ? n.shift() : \"Chart\"](this[0], n[0], n[1]), this) : B[a.attr(this[0], \"data-highcharts-chart\")];\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.each,\n        C = a.isNumber,\n        D = a.map,\n        n = a.merge,\n        d = a.pInt;\n\n    a.Color = function (d) {\n      if (!(this instanceof a.Color)) return new a.Color(d);\n      this.init(d);\n    };\n\n    a.Color.prototype = {\n      parsers: [{\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function parse(a) {\n          return [d(a[1]), d(a[2]), d(a[3]), parseFloat(a[4], 10)];\n        }\n      }, {\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function parse(a) {\n          return [d(a[1]), d(a[2]), d(a[3]), 1];\n        }\n      }],\n      names: {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      },\n      init: function init(d) {\n        var k, n, q, p;\n        if ((this.input = d = this.names[d && d.toLowerCase ? d.toLowerCase() : \"\"] || d) && d.stops) this.stops = D(d.stops, function (p) {\n          return new a.Color(p[1]);\n        });else if (d && d.charAt && \"#\" === d.charAt() && (k = d.length, d = parseInt(d.substr(1), 16), 7 === k ? n = [(d & 16711680) >> 16, (d & 65280) >> 8, d & 255, 1] : 4 === k && (n = [(d & 3840) >> 4 | (d & 3840) >> 8, (d & 240) >> 4 | d & 240, (d & 15) << 4 | d & 15, 1])), !n) for (q = this.parsers.length; q-- && !n;) {\n          p = this.parsers[q], (k = p.regex.exec(d)) && (n = p.parse(k));\n        }\n        this.rgba = n || [];\n      },\n      get: function get(a) {\n        var d = this.input,\n            k = this.rgba,\n            q;\n        this.stops ? (q = n(d), q.stops = [].concat(q.stops), B(this.stops, function (p, d) {\n          q.stops[d] = [q.stops[d][0], p.get(a)];\n        })) : q = k && C(k[0]) ? \"rgb\" === a || !a && 1 === k[3] ? \"rgb(\" + k[0] + \",\" + k[1] + \",\" + k[2] + \")\" : \"a\" === a ? k[3] : \"rgba(\" + k.join(\",\") + \")\" : d;\n        return q;\n      },\n      brighten: function brighten(a) {\n        var k,\n            n = this.rgba;\n        if (this.stops) B(this.stops, function (d) {\n          d.brighten(a);\n        });else if (C(a) && 0 !== a) for (k = 0; 3 > k; k++) {\n          n[k] += d(255 * a), 0 > n[k] && (n[k] = 0), 255 < n[k] && (n[k] = 255);\n        }\n        return this;\n      },\n      setOpacity: function setOpacity(a) {\n        this.rgba[3] = a;\n        return this;\n      },\n      tweenTo: function tweenTo(a, d) {\n        var k = this.rgba,\n            q = a.rgba;\n        q.length && k && k.length ? (a = 1 !== q[3] || 1 !== k[3], d = (a ? \"rgba(\" : \"rgb(\") + Math.round(q[0] + (k[0] - q[0]) * (1 - d)) + \",\" + Math.round(q[1] + (k[1] - q[1]) * (1 - d)) + \",\" + Math.round(q[2] + (k[2] - q[2]) * (1 - d)) + (a ? \",\" + (q[3] + (k[3] - q[3]) * (1 - d)) : \"\") + \")\") : d = a.input || \"none\";\n        return d;\n      }\n    };\n\n    a.color = function (d) {\n      return new a.Color(d);\n    };\n  })(M);\n\n  (function (a) {\n    var B = a.defined,\n        C = a.each,\n        D = a.extend,\n        n = a.merge,\n        d = a.pick,\n        k = a.timeUnits,\n        u = a.win;\n\n    a.Time = function (a) {\n      this.update(a, !1);\n    };\n\n    a.Time.prototype = {\n      defaultOptions: {},\n      update: function update(a) {\n        var q = d(a && a.useUTC, !0),\n            p = this;\n        this.options = a = n(!0, this.options || {}, a);\n        this.Date = a.Date || u.Date;\n        this.timezoneOffset = (this.useUTC = q) && a.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        (this.variableTimezone = !(q && !a.getTimezoneOffset && !a.timezone)) || this.timezoneOffset ? (this.get = function (a, g) {\n          var h = g.getTime(),\n              m = h - p.getTimezoneOffset(g);\n          g.setTime(m);\n          a = g[\"getUTC\" + a]();\n          g.setTime(h);\n          return a;\n        }, this.set = function (a, g, h) {\n          var m;\n          if (\"Milliseconds\" === a || \"Seconds\" === a || \"Minutes\" === a && 0 === g.getTimezoneOffset() % 60) g[\"set\" + a](h);else m = p.getTimezoneOffset(g), m = g.getTime() - m, g.setTime(m), g[\"setUTC\" + a](h), a = p.getTimezoneOffset(g), m = g.getTime() + a, g.setTime(m);\n        }) : q ? (this.get = function (a, g) {\n          return g[\"getUTC\" + a]();\n        }, this.set = function (a, g, h) {\n          return g[\"setUTC\" + a](h);\n        }) : (this.get = function (a, g) {\n          return g[\"get\" + a]();\n        }, this.set = function (a, g, h) {\n          return g[\"set\" + a](h);\n        });\n      },\n      makeTime: function makeTime(k, q, p, y, g, h) {\n        var m, b, c;\n        this.useUTC ? (m = this.Date.UTC.apply(0, arguments), b = this.getTimezoneOffset(m), m += b, c = this.getTimezoneOffset(m), b !== c ? m += c - b : b - 36E5 !== this.getTimezoneOffset(m - 36E5) || a.isSafari || (m -= 36E5)) : m = new this.Date(k, q, d(p, 1), d(y, 0), d(g, 0), d(h, 0)).getTime();\n        return m;\n      },\n      timezoneOffsetFunction: function timezoneOffsetFunction() {\n        var d = this,\n            q = this.options,\n            p = u.moment;\n        if (!this.useUTC) return function (a) {\n          return 6E4 * new Date(a).getTimezoneOffset();\n        };\n\n        if (q.timezone) {\n          if (p) return function (a) {\n            return 6E4 * -p.tz(a, q.timezone).utcOffset();\n          };\n          a.error(25);\n        }\n\n        return this.useUTC && q.getTimezoneOffset ? function (a) {\n          return 6E4 * q.getTimezoneOffset(a);\n        } : function () {\n          return 6E4 * (d.timezoneOffset || 0);\n        };\n      },\n      dateFormat: function dateFormat(d, q, p) {\n        if (!a.defined(q) || isNaN(q)) return a.defaultOptions.lang.invalidDate || \"\";\n        d = a.pick(d, \"%Y-%m-%d %H:%M:%S\");\n        var k = this,\n            g = new this.Date(q),\n            h = this.get(\"Hours\", g),\n            m = this.get(\"Day\", g),\n            b = this.get(\"Date\", g),\n            c = this.get(\"Month\", g),\n            f = this.get(\"FullYear\", g),\n            e = a.defaultOptions.lang,\n            w = e.weekdays,\n            G = e.shortWeekdays,\n            t = a.pad,\n            g = a.extend({\n          a: G ? G[m] : w[m].substr(0, 3),\n          A: w[m],\n          d: t(b),\n          e: t(b, 2, \" \"),\n          w: m,\n          b: e.shortMonths[c],\n          B: e.months[c],\n          m: t(c + 1),\n          o: c + 1,\n          y: f.toString().substr(2, 2),\n          Y: f,\n          H: t(h),\n          k: h,\n          I: t(h % 12 || 12),\n          l: h % 12 || 12,\n          M: t(k.get(\"Minutes\", g)),\n          p: 12 > h ? \"AM\" : \"PM\",\n          P: 12 > h ? \"am\" : \"pm\",\n          S: t(g.getSeconds()),\n          L: t(Math.floor(q % 1E3), 3)\n        }, a.dateFormats);\n        a.objectEach(g, function (a, b) {\n          for (; -1 !== d.indexOf(\"%\" + b);) {\n            d = d.replace(\"%\" + b, \"function\" === typeof a ? a.call(k, q) : a);\n          }\n        });\n        return p ? d.substr(0, 1).toUpperCase() + d.substr(1) : d;\n      },\n      resolveDTLFormat: function resolveDTLFormat(d) {\n        return a.isObject(d, !0) ? d : (d = a.splat(d), {\n          main: d[0],\n          from: d[1],\n          to: d[2]\n        });\n      },\n      getTimeTicks: function getTimeTicks(a, q, p, n) {\n        var g = this,\n            h = [],\n            m,\n            b = {},\n            c;\n        m = new g.Date(q);\n        var f = a.unitRange,\n            e = a.count || 1,\n            w;\n        n = d(n, 1);\n\n        if (B(q)) {\n          g.set(\"Milliseconds\", m, f >= k.second ? 0 : e * Math.floor(g.get(\"Milliseconds\", m) / e));\n          f >= k.second && g.set(\"Seconds\", m, f >= k.minute ? 0 : e * Math.floor(g.get(\"Seconds\", m) / e));\n          f >= k.minute && g.set(\"Minutes\", m, f >= k.hour ? 0 : e * Math.floor(g.get(\"Minutes\", m) / e));\n          f >= k.hour && g.set(\"Hours\", m, f >= k.day ? 0 : e * Math.floor(g.get(\"Hours\", m) / e));\n          f >= k.day && g.set(\"Date\", m, f >= k.month ? 1 : e * Math.floor(g.get(\"Date\", m) / e));\n          f >= k.month && (g.set(\"Month\", m, f >= k.year ? 0 : e * Math.floor(g.get(\"Month\", m) / e)), c = g.get(\"FullYear\", m));\n          f >= k.year && g.set(\"FullYear\", m, c - c % e);\n          f === k.week && (c = g.get(\"Day\", m), g.set(\"Date\", m, g.get(\"Date\", m) - c + n + (c < n ? -7 : 0)));\n          c = g.get(\"FullYear\", m);\n          n = g.get(\"Month\", m);\n          var G = g.get(\"Date\", m),\n              t = g.get(\"Hours\", m);\n          q = m.getTime();\n          g.variableTimezone && (w = p - q > 4 * k.month || g.getTimezoneOffset(q) !== g.getTimezoneOffset(p));\n          q = m.getTime();\n\n          for (m = 1; q < p;) {\n            h.push(q), q = f === k.year ? g.makeTime(c + m * e, 0) : f === k.month ? g.makeTime(c, n + m * e) : !w || f !== k.day && f !== k.week ? w && f === k.hour && 1 < e ? g.makeTime(c, n, G, t + m * e) : q + f * e : g.makeTime(c, n, G + m * e * (f === k.day ? 1 : 7)), m++;\n          }\n\n          h.push(q);\n          f <= k.hour && 1E4 > h.length && C(h, function (a) {\n            0 === a % 18E5 && \"000000000\" === g.dateFormat(\"%H%M%S%L\", a) && (b[a] = \"day\");\n          });\n        }\n\n        h.info = D(a, {\n          higherRanks: b,\n          totalRange: f * e\n        });\n        return h;\n      }\n    };\n  })(M);\n\n  (function (a) {\n    var B = a.color,\n        C = a.merge;\n    a.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: a.Time.prototype.defaultOptions,\n      chart: {\n        borderRadius: 0,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function labelFormatter() {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: a.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: a.isTouchDevice ? 25 : 10,\n        backgroundColor: B(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        headerFormat: '\\x3cspan style\\x3d\"font-size: 10px\"\\x3e{point.key}\\x3c/span\\x3e\\x3cbr/\\x3e',\n        pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>\",\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          pointerEvents: \"none\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n\n    a.setOptions = function (D) {\n      a.defaultOptions = C(!0, a.defaultOptions, D);\n      a.time.update(C(a.defaultOptions.global, a.defaultOptions.time), !1);\n      return a.defaultOptions;\n    };\n\n    a.getOptions = function () {\n      return a.defaultOptions;\n    };\n\n    a.defaultPlotOptions = a.defaultOptions.plotOptions;\n    a.time = new a.Time(C(a.defaultOptions.global, a.defaultOptions.time));\n\n    a.dateFormat = function (C, n, d) {\n      return a.time.dateFormat(C, n, d);\n    };\n  })(M);\n\n  (function (a) {\n    var B,\n        C,\n        D = a.addEvent,\n        n = a.animate,\n        d = a.attr,\n        k = a.charts,\n        u = a.color,\n        v = a.css,\n        q = a.createElement,\n        p = a.defined,\n        y = a.deg2rad,\n        g = a.destroyObjectProperties,\n        h = a.doc,\n        m = a.each,\n        b = a.extend,\n        c = a.erase,\n        f = a.grep,\n        e = a.hasTouch,\n        w = a.inArray,\n        G = a.isArray,\n        t = a.isFirefox,\n        K = a.isMS,\n        A = a.isObject,\n        F = a.isString,\n        r = a.isWebKit,\n        I = a.merge,\n        E = a.noop,\n        L = a.objectEach,\n        J = a.pick,\n        l = a.pInt,\n        x = a.removeEvent,\n        N = a.stop,\n        T = a.svg,\n        H = a.SVG_NS,\n        P = a.symbolSizes,\n        Q = a.win;\n\n    B = a.SVGElement = function () {\n      return this;\n    };\n\n    b(B.prototype, {\n      opacity: 1,\n      SVG_NS: H,\n      textProps: \"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor\".split(\" \"),\n      init: function init(a, b) {\n        this.element = \"span\" === b ? q(b) : h.createElementNS(this.SVG_NS, b);\n        this.renderer = a;\n      },\n      animate: function animate(z, b, l) {\n        b = a.animObject(J(b, this.renderer.globalAnimation, !0));\n        0 !== b.duration ? (l && (b.complete = l), n(this, z, b)) : (this.attr(z, null, l), b.step && b.step.call(this));\n        return this;\n      },\n      complexColor: function complexColor(z, b, l) {\n        var c = this.renderer,\n            x,\n            f,\n            e,\n            r,\n            H,\n            h,\n            w,\n            g,\n            O,\n            E,\n            d,\n            t = [],\n            N;\n        a.fireEvent(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          z.radialGradient ? f = \"radialGradient\" : z.linearGradient && (f = \"linearGradient\");\n          f && (e = z[f], H = c.gradients, w = z.stops, E = l.radialReference, G(e) && (z[f] = e = {\n            x1: e[0],\n            y1: e[1],\n            x2: e[2],\n            y2: e[3],\n            gradientUnits: \"userSpaceOnUse\"\n          }), \"radialGradient\" === f && E && !p(e.gradientUnits) && (r = e, e = I(e, c.getRadialAttr(E, r), {\n            gradientUnits: \"userSpaceOnUse\"\n          })), L(e, function (a, z) {\n            \"id\" !== z && t.push(z, a);\n          }), L(w, function (a) {\n            t.push(a);\n          }), t = t.join(\",\"), H[t] ? d = H[t].attr(\"id\") : (e.id = d = a.uniqueKey(), H[t] = h = c.createElement(f).attr(e).add(c.defs), h.radAttr = r, h.stops = [], m(w, function (z) {\n            0 === z[1].indexOf(\"rgba\") ? (x = a.color(z[1]), g = x.get(\"rgb\"), O = x.get(\"a\")) : (g = z[1], O = 1);\n            z = c.createElement(\"stop\").attr({\n              offset: z[0],\n              \"stop-color\": g,\n              \"stop-opacity\": O\n            }).add(h);\n            h.stops.push(z);\n          })), N = \"url(\" + c.url + \"#\" + d + \")\", l.setAttribute(b, N), l.gradient = t, z.toString = function () {\n            return N;\n          });\n        });\n      },\n      applyTextOutline: function applyTextOutline(z) {\n        var b = this.element,\n            l,\n            x,\n            f,\n            e,\n            r;\n        -1 !== z.indexOf(\"contrast\") && (z = z.replace(/contrast/g, this.renderer.getContrast(b.style.fill)));\n        z = z.split(\" \");\n        x = z[z.length - 1];\n\n        if ((f = z[0]) && \"none\" !== f && a.svg) {\n          this.fakeTS = !0;\n          z = [].slice.call(b.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;\n          f = f.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, z, b) {\n            return 2 * z + b;\n          });\n\n          for (r = z.length; r--;) {\n            l = z[r], \"highcharts-text-outline\" === l.getAttribute(\"class\") && c(z, b.removeChild(l));\n          }\n\n          e = b.firstChild;\n          m(z, function (a, z) {\n            0 === z && (a.setAttribute(\"x\", b.getAttribute(\"x\")), z = b.getAttribute(\"y\"), a.setAttribute(\"y\", z || 0), null === z && b.setAttribute(\"y\", 0));\n            a = a.cloneNode(1);\n            d(a, {\n              \"class\": \"highcharts-text-outline\",\n              fill: x,\n              stroke: x,\n              \"stroke-width\": f,\n              \"stroke-linejoin\": \"round\"\n            });\n            b.insertBefore(a, e);\n          });\n        }\n      },\n      attr: function attr(a, b, l, c) {\n        var z,\n            x = this.element,\n            f,\n            e = this,\n            r,\n            H;\n        \"string\" === typeof a && void 0 !== b && (z = a, a = {}, a[z] = b);\n        \"string\" === typeof a ? e = (this[a + \"Getter\"] || this._defaultGetter).call(this, a, x) : (L(a, function (z, b) {\n          r = !1;\n          c || N(this, b);\n          this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(b) && (f || (this.symbolAttr(a), f = !0), r = !0);\n          !this.rotation || \"x\" !== b && \"y\" !== b || (this.doTransform = !0);\n          r || (H = this[b + \"Setter\"] || this._defaultSetter, H.call(this, z, b, x), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(b) && this.updateShadows(b, z, H));\n        }, this), this.afterSetters());\n        l && l.call(this);\n        return e;\n      },\n      afterSetters: function afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      },\n      updateShadows: function updateShadows(a, b, l) {\n        for (var z = this.shadows, c = z.length; c--;) {\n          l.call(z[c], \"height\" === a ? Math.max(b - (z[c].cutHeight || 0), 0) : \"d\" === a ? this.d : b, a, z[c]);\n        }\n      },\n      addClass: function addClass(a, b) {\n        var z = this.attr(\"class\") || \"\";\n        -1 === z.indexOf(a) && (b || (a = (z + (z ? \" \" : \"\") + a).replace(\"  \", \" \")), this.attr(\"class\", a));\n        return this;\n      },\n      hasClass: function hasClass(a) {\n        return -1 !== w(a, (this.attr(\"class\") || \"\").split(\" \"));\n      },\n      removeClass: function removeClass(a) {\n        return this.attr(\"class\", (this.attr(\"class\") || \"\").replace(a, \"\"));\n      },\n      symbolAttr: function symbolAttr(a) {\n        var b = this;\n        m(\"x y r start end width height innerR anchorX anchorY\".split(\" \"), function (z) {\n          b[z] = J(a[z], b[z]);\n        });\n        b.attr({\n          d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)\n        });\n      },\n      clip: function clip(a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      },\n      crisp: function crisp(a, b) {\n        var z;\n        b = b || a.strokeWidth || 0;\n        z = Math.round(b) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + z;\n        a.y = Math.floor(a.y || this.y || 0) + z;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * z);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * z);\n        p(a.strokeWidth) && (a.strokeWidth = b);\n        return a;\n      },\n      css: function css(a) {\n        var z = this.styles,\n            c = {},\n            x = this.element,\n            f,\n            e = \"\",\n            r,\n            H = !z,\n            h = [\"textOutline\", \"textOverflow\", \"width\"];\n        a && a.color && (a.fill = a.color);\n        z && L(a, function (a, b) {\n          a !== z[b] && (c[b] = a, H = !0);\n        });\n        H && (z && (a = b(z, c)), a && (null === a.width || \"auto\" === a.width ? delete this.textWidth : \"text\" === x.nodeName.toLowerCase() && a.width && (f = this.textWidth = l(a.width))), this.styles = a, f && !T && this.renderer.forExport && delete a.width, x.namespaceURI === this.SVG_NS ? (r = function r(a, b) {\n          return \"-\" + b.toLowerCase();\n        }, L(a, function (a, b) {\n          -1 === w(b, h) && (e += b.replace(/([A-Z])/g, r) + \":\" + a + \";\");\n        }), e && d(x, \"style\", e)) : v(x, a), this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline)));\n        return this;\n      },\n      strokeWidth: function strokeWidth() {\n        return this[\"stroke-width\"] || 0;\n      },\n      on: function on(a, b) {\n        var z = this,\n            l = z.element;\n        e && \"click\" === a ? (l.ontouchstart = function (a) {\n          z.touchEventFired = Date.now();\n          a.preventDefault();\n          b.call(l, a);\n        }, l.onclick = function (a) {\n          (-1 === Q.navigator.userAgent.indexOf(\"Android\") || 1100 < Date.now() - (z.touchEventFired || 0)) && b.call(l, a);\n        }) : l[\"on\" + a] = b;\n        return this;\n      },\n      setRadialReference: function setRadialReference(a) {\n        var b = this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        b && b.radAttr && b.animate(this.renderer.getRadialAttr(a, b.radAttr));\n        return this;\n      },\n      translate: function translate(a, b) {\n        return this.attr({\n          translateX: a,\n          translateY: b\n        });\n      },\n      invert: function invert(a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      },\n      updateTransform: function updateTransform() {\n        var a = this.translateX || 0,\n            b = this.translateY || 0,\n            l = this.scaleX,\n            c = this.scaleY,\n            x = this.inverted,\n            f = this.rotation,\n            e = this.matrix,\n            r = this.element;\n        x && (a += this.width, b += this.height);\n        a = [\"translate(\" + a + \",\" + b + \")\"];\n        p(e) && a.push(\"matrix(\" + e.join(\",\") + \")\");\n        x ? a.push(\"rotate(90) scale(-1,1)\") : f && a.push(\"rotate(\" + f + \" \" + J(this.rotationOriginX, r.getAttribute(\"x\"), 0) + \" \" + J(this.rotationOriginY, r.getAttribute(\"y\") || 0) + \")\");\n        (p(l) || p(c)) && a.push(\"scale(\" + J(l, 1) + \" \" + J(c, 1) + \")\");\n        a.length && r.setAttribute(\"transform\", a.join(\" \"));\n      },\n      toFront: function toFront() {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      },\n      align: function align(a, b, l) {\n        var z,\n            x,\n            f,\n            e,\n            r = {};\n        x = this.renderer;\n        f = x.alignedObjects;\n        var H, h;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = b, !l || F(l)) this.alignTo = z = l || \"renderer\", c(f, this), f.push(this), l = null;\n        } else a = this.alignOptions, b = this.alignByTranslate, z = this.alignTo;\n\n        l = J(l, x[z], x);\n        z = a.align;\n        x = a.verticalAlign;\n        f = (l.x || 0) + (a.x || 0);\n        e = (l.y || 0) + (a.y || 0);\n        \"right\" === z ? H = 1 : \"center\" === z && (H = 2);\n        H && (f += (l.width - (a.width || 0)) / H);\n        r[b ? \"translateX\" : \"x\"] = Math.round(f);\n        \"bottom\" === x ? h = 1 : \"middle\" === x && (h = 2);\n        h && (e += (l.height - (a.height || 0)) / h);\n        r[b ? \"translateY\" : \"y\"] = Math.round(e);\n        this[this.placed ? \"animate\" : \"attr\"](r);\n        this.placed = !0;\n        this.alignAttr = r;\n        return this;\n      },\n      getBBox: function getBBox(a, l) {\n        var z,\n            c = this.renderer,\n            x,\n            f = this.element,\n            e = this.styles,\n            r,\n            H = this.textStr,\n            h,\n            w = c.cache,\n            g = c.cacheKeys,\n            E = f.namespaceURI === this.SVG_NS,\n            t;\n        l = J(l, this.rotation);\n        x = l * y;\n        r = e && e.fontSize;\n        p(H) && (t = H.toString(), -1 === t.indexOf(\"\\x3c\") && (t = t.replace(/[0-9]/g, \"0\")), t += [\"\", l || 0, r, this.textWidth, e && e.textOverflow].join());\n        t && !a && (z = w[t]);\n\n        if (!z) {\n          if (E || c.forExport) {\n            try {\n              (h = this.fakeTS && function (a) {\n                m(f.querySelectorAll(\".highcharts-text-outline\"), function (b) {\n                  b.style.display = a;\n                });\n              }) && h(\"none\"), z = f.getBBox ? b({}, f.getBBox()) : {\n                width: f.offsetWidth,\n                height: f.offsetHeight\n              }, h && h(\"\");\n            } catch (X) {}\n\n            if (!z || 0 > z.width) z = {\n              width: 0,\n              height: 0\n            };\n          } else z = this.htmlGetBBox();\n\n          c.isSVG && (a = z.width, c = z.height, E && (z.height = c = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[e && e.fontSize + \",\" + Math.round(c)] || c), l && (z.width = Math.abs(c * Math.sin(x)) + Math.abs(a * Math.cos(x)), z.height = Math.abs(c * Math.cos(x)) + Math.abs(a * Math.sin(x))));\n\n          if (t && 0 < z.height) {\n            for (; 250 < g.length;) {\n              delete w[g.shift()];\n            }\n\n            w[t] || g.push(t);\n            w[t] = z;\n          }\n        }\n\n        return z;\n      },\n      show: function show(a) {\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      },\n      hide: function hide() {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      },\n      fadeOut: function fadeOut(a) {\n        var b = this;\n        b.animate({\n          opacity: 0\n        }, {\n          duration: a || 150,\n          complete: function complete() {\n            b.attr({\n              y: -9999\n            });\n          }\n        });\n      },\n      add: function add(a) {\n        var b = this.renderer,\n            l = this.element,\n            z;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        void 0 !== this.textStr && b.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) z = this.zIndexSetter();\n        z || (a ? a.element : b.box).appendChild(l);\n        if (this.onAdd) this.onAdd();\n        return this;\n      },\n      safeRemoveChild: function safeRemoveChild(a) {\n        var b = a.parentNode;\n        b && b.removeChild(a);\n      },\n      destroy: function destroy() {\n        var a = this,\n            b = a.element || {},\n            l = a.renderer.isSVG && \"SPAN\" === b.nodeName && a.parentGroup,\n            x = b.ownerSVGElement,\n            f = a.clipPath;\n        b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null;\n        N(a);\n        f && x && (m(x.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (a) {\n          var b = a.getAttribute(\"clip-path\"),\n              l = f.element.id;\n          (-1 < b.indexOf(\"(#\" + l + \")\") || -1 < b.indexOf('(\"#' + l + '\")')) && a.removeAttribute(\"clip-path\");\n        }), a.clipPath = f.destroy());\n\n        if (a.stops) {\n          for (x = 0; x < a.stops.length; x++) {\n            a.stops[x] = a.stops[x].destroy();\n          }\n\n          a.stops = null;\n        }\n\n        a.safeRemoveChild(b);\n\n        for (a.destroyShadows(); l && l.div && 0 === l.div.childNodes.length;) {\n          b = l.parentGroup, a.safeRemoveChild(l.div), delete l.div, l = b;\n        }\n\n        a.alignTo && c(a.renderer.alignedObjects, a);\n        L(a, function (b, l) {\n          delete a[l];\n        });\n        return null;\n      },\n      shadow: function shadow(a, b, l) {\n        var c = [],\n            x,\n            f,\n            z = this.element,\n            e,\n            r,\n            H,\n            h;\n        if (!a) this.destroyShadows();else if (!this.shadows) {\n          r = J(a.width, 3);\n          H = (a.opacity || .15) / r;\n          h = this.parentInverted ? \"(-1,-1)\" : \"(\" + J(a.offsetX, 1) + \", \" + J(a.offsetY, 1) + \")\";\n\n          for (x = 1; x <= r; x++) {\n            f = z.cloneNode(0), e = 2 * r + 1 - 2 * x, d(f, {\n              stroke: a.color || \"#000000\",\n              \"stroke-opacity\": H * x,\n              \"stroke-width\": e,\n              transform: \"translate\" + h,\n              fill: \"none\"\n            }), f.setAttribute(\"class\", (f.getAttribute(\"class\") || \"\") + \" highcharts-shadow\"), l && (d(f, \"height\", Math.max(d(f, \"height\") - e, 0)), f.cutHeight = e), b ? b.element.appendChild(f) : z.parentNode && z.parentNode.insertBefore(f, z), c.push(f);\n          }\n\n          this.shadows = c;\n        }\n        return this;\n      },\n      destroyShadows: function destroyShadows() {\n        m(this.shadows || [], function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      },\n      xGetter: function xGetter(a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      },\n      _defaultGetter: function _defaultGetter(a) {\n        a = J(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      },\n      dSetter: function dSetter(a, b, l) {\n        a && a.join && (a = a.join(\" \"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[b] !== a && (l.setAttribute(b, a), this[b] = a);\n      },\n      dashstyleSetter: function dashstyleSetter(a) {\n        var b,\n            c = this[\"stroke-width\"];\n        \"inherit\" === c && (c = 1);\n\n        if (a = a && a.toLowerCase()) {\n          a = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (b = a.length; b--;) {\n            a[b] = l(a[b]) * c;\n          }\n\n          a = a.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      },\n      alignSetter: function alignSetter(a) {\n        this.alignValue = a;\n        this.element.setAttribute(\"text-anchor\", {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        }[a]);\n      },\n      opacitySetter: function opacitySetter(a, b, l) {\n        this[b] = a;\n        l.setAttribute(b, a);\n      },\n      titleSetter: function titleSetter(a) {\n        var b = this.element.getElementsByTagName(\"title\")[0];\n        b || (b = h.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(b));\n        b.firstChild && b.removeChild(b.firstChild);\n        b.appendChild(h.createTextNode(String(J(a), \"\").replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"\\x3c\").replace(/&gt;/g, \"\\x3e\")));\n      },\n      textSetter: function textSetter(a) {\n        a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this));\n      },\n      fillSetter: function fillSetter(a, b, l) {\n        \"string\" === typeof a ? l.setAttribute(b, a) : a && this.complexColor(a, b, l);\n      },\n      visibilitySetter: function visibilitySetter(a, b, l) {\n        \"inherit\" === a ? l.removeAttribute(b) : this[b] !== a && l.setAttribute(b, a);\n        this[b] = a;\n      },\n      zIndexSetter: function zIndexSetter(a, b) {\n        var c = this.renderer,\n            x = this.parentGroup,\n            f = (x || c).element || c.box,\n            e,\n            r = this.element,\n            z,\n            H,\n            c = f === c.box;\n        e = this.added;\n        var h;\n        p(a) ? (r.setAttribute(\"data-z-index\", a), a = +a, this[b] === a && (e = !1)) : p(this[b]) && r.removeAttribute(\"data-z-index\");\n        this[b] = a;\n\n        if (e) {\n          (a = this.zIndex) && x && (x.handleZ = !0);\n          b = f.childNodes;\n\n          for (h = b.length - 1; 0 <= h && !z; h--) {\n            if (x = b[h], e = x.getAttribute(\"data-z-index\"), H = !p(e), x !== r) if (0 > a && H && !c && !h) f.insertBefore(r, b[h]), z = !0;else if (l(e) <= a || H && (!p(a) || 0 <= a)) f.insertBefore(r, b[h + 1] || null), z = !0;\n          }\n\n          z || (f.insertBefore(r, b[c ? 3 : 0] || null), z = !0);\n        }\n\n        return z;\n      },\n      _defaultSetter: function _defaultSetter(a, b, l) {\n        l.setAttribute(b, a);\n      }\n    });\n    B.prototype.yGetter = B.prototype.xGetter;\n\n    B.prototype.translateXSetter = B.prototype.translateYSetter = B.prototype.rotationSetter = B.prototype.verticalAlignSetter = B.prototype.rotationOriginXSetter = B.prototype.rotationOriginYSetter = B.prototype.scaleXSetter = B.prototype.scaleYSetter = B.prototype.matrixSetter = function (a, b) {\n      this[b] = a;\n      this.doTransform = !0;\n    };\n\n    B.prototype[\"stroke-widthSetter\"] = B.prototype.strokeSetter = function (a, b, l) {\n      this[b] = a;\n      this.stroke && this[\"stroke-width\"] ? (B.prototype.fillSetter.call(this, this.stroke, \"stroke\", l), l.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === b && 0 === a && this.hasStroke && (l.removeAttribute(\"stroke\"), this.hasStroke = !1);\n    };\n\n    C = a.SVGRenderer = function () {\n      this.init.apply(this, arguments);\n    };\n\n    b(C.prototype, {\n      Element: B,\n      SVG_NS: H,\n      init: function init(a, b, l, c, x, f) {\n        var e;\n        c = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        }).css(this.getStyle(c));\n        e = c.element;\n        a.appendChild(e);\n        d(a, \"dir\", \"ltr\");\n        -1 === a.innerHTML.indexOf(\"xmlns\") && d(e, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = e;\n        this.boxWrapper = c;\n        this.alignedObjects = [];\n        this.url = (t || r) && h.getElementsByTagName(\"base\").length ? Q.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(h.createTextNode(\"Created with Highmaps 6.2.0\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = f;\n        this.forExport = x;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(b, l, !1);\n        var z;\n        t && a.getBoundingClientRect && (b = function b() {\n          v(a, {\n            left: 0,\n            top: 0\n          });\n          z = a.getBoundingClientRect();\n          v(a, {\n            left: Math.ceil(z.left) - z.left + \"px\",\n            top: Math.ceil(z.top) - z.top + \"px\"\n          });\n        }, b(), this.unSubPixelFix = D(Q, \"resize\", b));\n      },\n      getStyle: function getStyle(a) {\n        return this.style = b({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, a);\n      },\n      setStyle: function setStyle(a) {\n        this.boxWrapper.css(this.getStyle(a));\n      },\n      isHidden: function isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      },\n      destroy: function destroy() {\n        var a = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        g(this.gradients || {});\n        this.gradients = null;\n        a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      },\n      createElement: function createElement(a) {\n        var b = new this.Element();\n        b.init(this, a);\n        return b;\n      },\n      draw: E,\n      getRadialAttr: function getRadialAttr(a, b) {\n        return {\n          cx: a[0] - a[2] / 2 + b.cx * a[2],\n          cy: a[1] - a[2] / 2 + b.cy * a[2],\n          r: b.r * a[2]\n        };\n      },\n      truncate: function truncate(a, b, l, c, x, f, e) {\n        var r = this,\n            z = a.rotation,\n            H,\n            w = c ? 1 : 0,\n            g = (l || c).length,\n            m = g,\n            p = [],\n            E = function E(a) {\n          b.firstChild && b.removeChild(b.firstChild);\n          a && b.appendChild(h.createTextNode(a));\n        },\n            t = function t(f, z) {\n          z = z || f;\n          if (void 0 === p[z]) if (b.getSubStringLength) try {\n            p[z] = x + b.getSubStringLength(0, c ? z + 1 : z);\n          } catch (Y) {} else r.getSpanWidth && (E(e(l || c, f)), p[z] = x + r.getSpanWidth(a, b));\n          return p[z];\n        },\n            d,\n            N;\n\n        a.rotation = 0;\n        d = t(b.textContent.length);\n\n        if (N = x + d > f) {\n          for (; w <= g;) {\n            m = Math.ceil((w + g) / 2), c && (H = e(c, m)), d = t(m, H && H.length - 1), w === g ? w = g + 1 : d > f ? g = m - 1 : w = m;\n          }\n\n          0 === g ? E(\"\") : l && g === l.length - 1 || E(H || e(l || c, m));\n        }\n\n        c && c.splice(0, m);\n        a.actualWidth = d;\n        a.rotation = z;\n        return N;\n      },\n      escapes: {\n        \"\\x26\": \"\\x26amp;\",\n        \"\\x3c\": \"\\x26lt;\",\n        \"\\x3e\": \"\\x26gt;\",\n        \"'\": \"\\x26#39;\",\n        '\"': \"\\x26quot;\"\n      },\n      buildText: function buildText(a) {\n        var b = a.element,\n            c = this,\n            x = c.forExport,\n            e = J(a.textStr, \"\").toString(),\n            r = -1 !== e.indexOf(\"\\x3c\"),\n            z = b.childNodes,\n            g,\n            p = d(b, \"x\"),\n            E = a.styles,\n            t = a.textWidth,\n            N = E && E.lineHeight,\n            I = E && E.textOutline,\n            A = E && \"ellipsis\" === E.textOverflow,\n            q = E && \"nowrap\" === E.whiteSpace,\n            G = E && E.fontSize,\n            F,\n            k,\n            P = z.length,\n            E = t && !a.added && this.box,\n            n = function n(a) {\n          var x;\n          x = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : G || c.style.fontSize || 12;\n          return N ? l(N) : c.fontMetrics(x, a.getAttribute(\"style\") ? a : b).h;\n        },\n            y = function y(a, b) {\n          L(c.escapes, function (l, c) {\n            b && -1 !== w(l, b) || (a = a.toString().replace(new RegExp(l, \"g\"), c));\n          });\n          return a;\n        },\n            Q = function Q(a, b) {\n          var l;\n          l = a.indexOf(\"\\x3c\");\n          a = a.substring(l, a.indexOf(\"\\x3e\") - l);\n          l = a.indexOf(b + \"\\x3d\");\n          if (-1 !== l && (l = l + b.length + 1, b = a.charAt(l), '\"' === b || \"'\" === b)) return a = a.substring(l + 1), a.substring(0, a.indexOf(b));\n        };\n\n        F = [e, A, q, N, I, G, t].join();\n\n        if (F !== a.textCache) {\n          for (a.textCache = F; P--;) {\n            b.removeChild(z[P]);\n          }\n\n          r || I || A || t || -1 !== e.indexOf(\" \") ? (E && E.appendChild(b), e = r ? e.replace(/<(b|strong)>/g, '\\x3cspan style\\x3d\"font-weight:bold\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan style\\x3d\"font-style:italic\"\\x3e').replace(/<a/g, \"\\x3cspan\").replace(/<\\/(b|strong|i|em|a)>/g, \"\\x3c/span\\x3e\").split(/<br.*?>/g) : [e], e = f(e, function (a) {\n            return \"\" !== a;\n          }), m(e, function (l, f) {\n            var e,\n                r = 0,\n                z = 0;\n            l = l.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||\\x3cspan\").replace(/<\\/span>/g, \"\\x3c/span\\x3e|||\");\n            e = l.split(\"|||\");\n            m(e, function (l) {\n              if (\"\" !== l || 1 === e.length) {\n                var w = {},\n                    m = h.createElementNS(c.SVG_NS, \"tspan\"),\n                    E,\n                    N;\n                (E = Q(l, \"class\")) && d(m, \"class\", E);\n                if (E = Q(l, \"style\")) E = E.replace(/(;| |^)color([ :])/, \"$1fill$2\"), d(m, \"style\", E);\n                (N = Q(l, \"href\")) && !x && (d(m, \"onclick\", 'location.href\\x3d\"' + N + '\"'), d(m, \"class\", \"highcharts-anchor\"), v(m, {\n                  cursor: \"pointer\"\n                }));\n                l = y(l.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");\n\n                if (\" \" !== l) {\n                  m.appendChild(h.createTextNode(l));\n                  r ? w.dx = 0 : f && null !== p && (w.x = p);\n                  d(m, w);\n                  b.appendChild(m);\n                  !r && k && (!T && x && v(m, {\n                    display: \"block\"\n                  }), d(m, \"dy\", n(m)));\n\n                  if (t) {\n                    var I = l.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n                        w = !q && (1 < e.length || f || 1 < I.length);\n                    N = 0;\n                    var F = n(m);\n                    if (A) g = c.truncate(a, m, l, void 0, 0, Math.max(0, t - parseInt(G || 12, 10)), function (a, b) {\n                      return a.substring(0, b) + \"\\u2026\";\n                    });else if (w) for (; I.length;) {\n                      I.length && !q && 0 < N && (m = h.createElementNS(H, \"tspan\"), d(m, {\n                        dy: F,\n                        x: p\n                      }), E && d(m, \"style\", E), m.appendChild(h.createTextNode(I.join(\" \").replace(/- /g, \"-\"))), b.appendChild(m)), c.truncate(a, m, null, I, 0 === N ? z : 0, t, function (a, b) {\n                        return I.slice(0, b).join(\" \").replace(/- /g, \"-\");\n                      }), z = a.actualWidth, N++;\n                    }\n                  }\n\n                  r++;\n                }\n              }\n            });\n            k = k || b.childNodes.length;\n          }), A && g && a.attr(\"title\", y(a.textStr, [\"\\x26lt;\", \"\\x26gt;\"])), E && E.removeChild(b), I && a.applyTextOutline && a.applyTextOutline(I)) : b.appendChild(h.createTextNode(y(e)));\n        }\n      },\n      getContrast: function getContrast(a) {\n        a = u(a).rgba;\n        a[0] *= 1;\n        a[1] *= 1.2;\n        a[2] *= .5;\n        return 459 < a[0] + a[1] + a[2] ? \"#000000\" : \"#FFFFFF\";\n      },\n      button: function button(a, l, c, x, f, e, r, H, h) {\n        var z = this.label(a, l, c, h, null, null, null, null, \"button\"),\n            m = 0;\n        z.attr(I({\n          padding: 8,\n          r: 2\n        }, f));\n        var w, g, E, p;\n        f = I({\n          fill: \"#f7f7f7\",\n          stroke: \"#cccccc\",\n          \"stroke-width\": 1,\n          style: {\n            color: \"#333333\",\n            cursor: \"pointer\",\n            fontWeight: \"normal\"\n          }\n        }, f);\n        w = f.style;\n        delete f.style;\n        e = I(f, {\n          fill: \"#e6e6e6\"\n        }, e);\n        g = e.style;\n        delete e.style;\n        r = I(f, {\n          fill: \"#e6ebf5\",\n          style: {\n            color: \"#000000\",\n            fontWeight: \"bold\"\n          }\n        }, r);\n        E = r.style;\n        delete r.style;\n        H = I(f, {\n          style: {\n            color: \"#cccccc\"\n          }\n        }, H);\n        p = H.style;\n        delete H.style;\n        D(z.element, K ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== m && z.setState(1);\n        });\n        D(z.element, K ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== m && z.setState(m);\n        });\n\n        z.setState = function (a) {\n          1 !== a && (z.state = m = a);\n          z.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n          z.attr([f, e, r, H][a || 0]).css([w, g, E, p][a || 0]);\n        };\n\n        z.attr(f).css(b({\n          cursor: \"default\"\n        }, w));\n        return z.on(\"click\", function (a) {\n          3 !== m && x.call(z, a);\n        });\n      },\n      crispLine: function crispLine(a, b) {\n        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - b % 2 / 2);\n        a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + b % 2 / 2);\n        return a;\n      },\n      path: function path(a) {\n        var l = {\n          fill: \"none\"\n        };\n        G(a) ? l.d = a : A(a) && b(l, a);\n        return this.createElement(\"path\").attr(l);\n      },\n      circle: function circle(a, b, l) {\n        a = A(a) ? a : {\n          x: a,\n          y: b,\n          r: l\n        };\n        b = this.createElement(\"circle\");\n\n        b.xSetter = b.ySetter = function (a, b, l) {\n          l.setAttribute(\"c\" + b, a);\n        };\n\n        return b.attr(a);\n      },\n      arc: function arc(a, b, l, c, x, f) {\n        A(a) ? (c = a, b = c.y, l = c.r, a = c.x) : c = {\n          innerR: c,\n          start: x,\n          end: f\n        };\n        a = this.symbol(\"arc\", a, b, l, l, c);\n        a.r = l;\n        return a;\n      },\n      rect: function rect(a, b, l, c, x, f) {\n        x = A(a) ? a.r : x;\n        var e = this.createElement(\"rect\");\n        a = A(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: b,\n          width: Math.max(l, 0),\n          height: Math.max(c, 0)\n        };\n        void 0 !== f && (a.strokeWidth = f, a = e.crisp(a));\n        a.fill = \"none\";\n        x && (a.r = x);\n\n        e.rSetter = function (a, b, l) {\n          d(l, {\n            rx: a,\n            ry: a\n          });\n        };\n\n        return e.attr(a);\n      },\n      setSize: function setSize(a, b, l) {\n        var c = this.alignedObjects,\n            x = c.length;\n        this.width = a;\n        this.height = b;\n\n        for (this.boxWrapper.animate({\n          width: a,\n          height: b\n        }, {\n          step: function step() {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: J(l, !0) ? void 0 : 0\n        }); x--;) {\n          c[x].align();\n        }\n      },\n      g: function g(a) {\n        var b = this.createElement(\"g\");\n        return a ? b.attr({\n          \"class\": \"highcharts-\" + a\n        }) : b;\n      },\n      image: function image(a, l, c, x, f, e) {\n        var r = {\n          preserveAspectRatio: \"none\"\n        },\n            H,\n            h = function h(a, b) {\n          a.setAttributeNS ? a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", b) : a.setAttribute(\"hc-svg-href\", b);\n        },\n            m = function m(b) {\n          h(H.element, a);\n          e.call(H, b);\n        };\n\n        1 < arguments.length && b(r, {\n          x: l,\n          y: c,\n          width: x,\n          height: f\n        });\n        H = this.createElement(\"image\").attr(r);\n        e ? (h(H.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw\\x3d\\x3d\"), r = new Q.Image(), D(r, \"load\", m), r.src = a, r.complete && m({})) : h(H.element, a);\n        return H;\n      },\n      symbol: function symbol(a, l, c, x, f, e) {\n        var r = this,\n            H,\n            w = /^url\\((.*?)\\)$/,\n            g = w.test(a),\n            E = !g && (this.symbols[a] ? a : \"circle\"),\n            z = E && this.symbols[E],\n            t = p(l) && z && z.call(this.symbols, Math.round(l), Math.round(c), x, f, e),\n            d,\n            N;\n        z ? (H = this.path(t), H.attr(\"fill\", \"none\"), b(H, {\n          symbolName: E,\n          x: l,\n          y: c,\n          width: x,\n          height: f\n        }), e && b(H, e)) : g && (d = a.match(w)[1], H = this.image(d), H.imgwidth = J(P[d] && P[d].width, e && e.width), H.imgheight = J(P[d] && P[d].height, e && e.height), N = function N() {\n          H.attr({\n            width: H.width,\n            height: H.height\n          });\n        }, m([\"width\", \"height\"], function (a) {\n          H[a + \"Setter\"] = function (a, b) {\n            var l = {},\n                c = this[\"img\" + b],\n                x = \"width\" === b ? \"translateX\" : \"translateY\";\n            this[b] = a;\n            p(c) && (this.element && this.element.setAttribute(b, c), this.alignByTranslate || (l[x] = ((this[b] || 0) - c) / 2, this.attr(l)));\n          };\n        }), p(l) && H.attr({\n          x: l,\n          y: c\n        }), H.isImg = !0, p(H.imgwidth) && p(H.imgheight) ? N() : (H.attr({\n          width: 0,\n          height: 0\n        }), q(\"img\", {\n          onload: function onload() {\n            var a = k[r.chartIndex];\n            0 === this.width && (v(this, {\n              position: \"absolute\",\n              top: \"-999em\"\n            }), h.body.appendChild(this));\n            P[d] = {\n              width: this.width,\n              height: this.height\n            };\n            H.imgwidth = this.width;\n            H.imgheight = this.height;\n            H.element && N();\n            this.parentNode && this.parentNode.removeChild(this);\n            r.imgCount--;\n            if (!r.imgCount && a && a.onload) a.onload();\n          },\n          src: d\n        }), this.imgCount++));\n        return H;\n      },\n      symbols: {\n        circle: function circle(a, b, l, c) {\n          return this.arc(a + l / 2, b + c / 2, l / 2, c / 2, {\n            start: 0,\n            end: 2 * Math.PI,\n            open: !1\n          });\n        },\n        square: function square(a, b, l, c) {\n          return [\"M\", a, b, \"L\", a + l, b, a + l, b + c, a, b + c, \"Z\"];\n        },\n        triangle: function triangle(a, b, l, c) {\n          return [\"M\", a + l / 2, b, \"L\", a + l, b + c, a, b + c, \"Z\"];\n        },\n        \"triangle-down\": function triangleDown(a, b, l, c) {\n          return [\"M\", a, b, \"L\", a + l, b, a + l / 2, b + c, \"Z\"];\n        },\n        diamond: function diamond(a, b, l, c) {\n          return [\"M\", a + l / 2, b, \"L\", a + l, b + c / 2, a + l / 2, b + c, a, b + c / 2, \"Z\"];\n        },\n        arc: function arc(a, b, l, c, x) {\n          var f = x.start,\n              e = x.r || l,\n              r = x.r || c || l,\n              H = x.end - .001;\n          l = x.innerR;\n          c = J(x.open, .001 > Math.abs(x.end - x.start - 2 * Math.PI));\n          var h = Math.cos(f),\n              m = Math.sin(f),\n              w = Math.cos(H),\n              H = Math.sin(H);\n          x = .001 > x.end - f - Math.PI ? 0 : 1;\n          e = [\"M\", a + e * h, b + r * m, \"A\", e, r, 0, x, 1, a + e * w, b + r * H];\n          p(l) && e.push(c ? \"M\" : \"L\", a + l * w, b + l * H, \"A\", l, l, 0, x, 0, a + l * h, b + l * m);\n          e.push(c ? \"\" : \"Z\");\n          return e;\n        },\n        callout: function callout(a, b, l, c, x) {\n          var e = Math.min(x && x.r || 0, l, c),\n              f = e + 6,\n              r = x && x.anchorX;\n          x = x && x.anchorY;\n          var H;\n          H = [\"M\", a + e, b, \"L\", a + l - e, b, \"C\", a + l, b, a + l, b, a + l, b + e, \"L\", a + l, b + c - e, \"C\", a + l, b + c, a + l, b + c, a + l - e, b + c, \"L\", a + e, b + c, \"C\", a, b + c, a, b + c, a, b + c - e, \"L\", a, b + e, \"C\", a, b, a, b, a + e, b];\n          r && r > l ? x > b + f && x < b + c - f ? H.splice(13, 3, \"L\", a + l, x - 6, a + l + 6, x, a + l, x + 6, a + l, b + c - e) : H.splice(13, 3, \"L\", a + l, c / 2, r, x, a + l, c / 2, a + l, b + c - e) : r && 0 > r ? x > b + f && x < b + c - f ? H.splice(33, 3, \"L\", a, x + 6, a - 6, x, a, x - 6, a, b + e) : H.splice(33, 3, \"L\", a, c / 2, r, x, a, c / 2, a, b + e) : x && x > c && r > a + f && r < a + l - f ? H.splice(23, 3, \"L\", r + 6, b + c, r, b + c + 6, r - 6, b + c, a + e, b + c) : x && 0 > x && r > a + f && r < a + l - f && H.splice(3, 3, \"L\", r - 6, b, r, b - 6, r + 6, b, l - e, b);\n          return H;\n        }\n      },\n      clipRect: function clipRect(b, l, c, x) {\n        var e = a.uniqueKey(),\n            f = this.createElement(\"clipPath\").attr({\n          id: e\n        }).add(this.defs);\n        b = this.rect(b, l, c, x, 0).add(f);\n        b.id = e;\n        b.clipPath = f;\n        b.count = 0;\n        return b;\n      },\n      text: function text(a, b, l, c) {\n        var x = {};\n        if (c && (this.allowHTML || !this.forExport)) return this.html(a, b, l);\n        x.x = Math.round(b || 0);\n        l && (x.y = Math.round(l));\n        p(a) && (x.text = a);\n        a = this.createElement(\"text\").attr(x);\n        c || (a.xSetter = function (a, b, l) {\n          var c = l.getElementsByTagName(\"tspan\"),\n              x,\n              e = l.getAttribute(b),\n              f;\n\n          for (f = 0; f < c.length; f++) {\n            x = c[f], x.getAttribute(b) === e && x.setAttribute(b, a);\n          }\n\n          l.setAttribute(b, a);\n        });\n        return a;\n      },\n      fontMetrics: function fontMetrics(a, b) {\n        a = a || b && b.style && b.style.fontSize || this.style && this.style.fontSize;\n        a = /px/.test(a) ? l(a) : /em/.test(a) ? parseFloat(a) * (b ? this.fontMetrics(null, b.parentNode).f : 16) : 12;\n        b = 24 > a ? a + 3 : Math.round(1.2 * a);\n        return {\n          h: b,\n          b: Math.round(.8 * b),\n          f: a\n        };\n      },\n      rotCorr: function rotCorr(a, b, l) {\n        var c = a;\n        b && l && (c = Math.max(c * Math.cos(b * y), 4));\n        return {\n          x: -a / 3 * Math.sin(b * y),\n          y: c\n        };\n      },\n      label: function label(l, c, e, f, r, H, h, w, g) {\n        var E = this,\n            t = E.g(\"button\" !== g && \"label\"),\n            d = t.text = E.text(\"\", 0, 0, h).attr({\n          zIndex: 1\n        }),\n            N,\n            A,\n            T = 0,\n            q = 3,\n            z = 0,\n            G,\n            F,\n            k,\n            P,\n            J,\n            n = {},\n            L,\n            y,\n            Q = /^url\\((.*?)\\)$/.test(f),\n            K = Q,\n            v,\n            u,\n            O,\n            S;\n        g && t.addClass(\"highcharts-\" + g);\n        K = Q;\n\n        v = function v() {\n          return (L || 0) % 2 / 2;\n        };\n\n        u = function u() {\n          var a = d.element.style,\n              l = {};\n          A = (void 0 === G || void 0 === F || J) && p(d.textStr) && d.getBBox();\n          t.width = (G || A.width || 0) + 2 * q + z;\n          t.height = (F || A.height || 0) + 2 * q;\n          y = q + E.fontMetrics(a && a.fontSize, d).b;\n          K && (N || (t.box = N = E.symbols[f] || Q ? E.symbol(f) : E.rect(), N.addClass((\"button\" === g ? \"\" : \"highcharts-label-box\") + (g ? \" highcharts-\" + g + \"-box\" : \"\")), N.add(t), a = v(), l.x = a, l.y = (w ? -y : 0) + a), l.width = Math.round(t.width), l.height = Math.round(t.height), N.attr(b(l, n)), n = {});\n        };\n\n        O = function O() {\n          var a = z + q,\n              b;\n          b = w ? 0 : y;\n          p(G) && A && (\"center\" === J || \"right\" === J) && (a += {\n            center: .5,\n            right: 1\n          }[J] * (G - A.width));\n          if (a !== d.x || b !== d.y) d.attr(\"x\", a), d.hasBoxWidthChanged && (A = d.getBBox(!0), u()), void 0 !== b && d.attr(\"y\", b);\n          d.x = a;\n          d.y = b;\n        };\n\n        S = function S(a, b) {\n          N ? N.attr(a, b) : n[a] = b;\n        };\n\n        t.onAdd = function () {\n          d.add(t);\n          t.attr({\n            text: l || 0 === l ? l : \"\",\n            x: c,\n            y: e\n          });\n          N && p(r) && t.attr({\n            anchorX: r,\n            anchorY: H\n          });\n        };\n\n        t.widthSetter = function (b) {\n          G = a.isNumber(b) ? b : null;\n        };\n\n        t.heightSetter = function (a) {\n          F = a;\n        };\n\n        t[\"text-alignSetter\"] = function (a) {\n          J = a;\n        };\n\n        t.paddingSetter = function (a) {\n          p(a) && a !== q && (q = t.padding = a, O());\n        };\n\n        t.paddingLeftSetter = function (a) {\n          p(a) && a !== z && (z = a, O());\n        };\n\n        t.alignSetter = function (a) {\n          a = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[a];\n          a !== T && (T = a, A && t.attr({\n            x: k\n          }));\n        };\n\n        t.textSetter = function (a) {\n          void 0 !== a && d.textSetter(a);\n          u();\n          O();\n        };\n\n        t[\"stroke-widthSetter\"] = function (a, b) {\n          a && (K = !0);\n          L = this[\"stroke-width\"] = a;\n          S(b, a);\n        };\n\n        t.strokeSetter = t.fillSetter = t.rSetter = function (a, b) {\n          \"r\" !== b && (\"fill\" === b && a && (K = !0), t[b] = a);\n          S(b, a);\n        };\n\n        t.anchorXSetter = function (a, b) {\n          r = t.anchorX = a;\n          S(b, Math.round(a) - v() - k);\n        };\n\n        t.anchorYSetter = function (a, b) {\n          H = t.anchorY = a;\n          S(b, a - P);\n        };\n\n        t.xSetter = function (a) {\n          t.x = a;\n          T && (a -= T * ((G || A.width) + 2 * q), t[\"forceAnimate:x\"] = !0);\n          k = Math.round(a);\n          t.attr(\"translateX\", k);\n        };\n\n        t.ySetter = function (a) {\n          P = t.y = Math.round(a);\n          t.attr(\"translateY\", P);\n        };\n\n        var V = t.css;\n        return b(t, {\n          css: function css(a) {\n            if (a) {\n              var b = {};\n              a = I(a);\n              m(t.textProps, function (l) {\n                void 0 !== a[l] && (b[l] = a[l], delete a[l]);\n              });\n              d.css(b);\n              \"width\" in b && u();\n            }\n\n            return V.call(t, a);\n          },\n          getBBox: function getBBox() {\n            return {\n              width: A.width + 2 * q,\n              height: A.height + 2 * q,\n              x: A.x - q,\n              y: A.y - q\n            };\n          },\n          shadow: function shadow(a) {\n            a && (u(), N && N.shadow(a));\n            return t;\n          },\n          destroy: function destroy() {\n            x(t.element, \"mouseenter\");\n            x(t.element, \"mouseleave\");\n            d && (d = d.destroy());\n            N && (N = N.destroy());\n            B.prototype.destroy.call(t);\n            t = E = u = O = S = null;\n          }\n        });\n      }\n    });\n    a.Renderer = C;\n  })(M);\n\n  (function (a) {\n    var B = a.attr,\n        C = a.createElement,\n        D = a.css,\n        n = a.defined,\n        d = a.each,\n        k = a.extend,\n        u = a.isFirefox,\n        v = a.isMS,\n        q = a.isWebKit,\n        p = a.pick,\n        y = a.pInt,\n        g = a.SVGRenderer,\n        h = a.win,\n        m = a.wrap;\n    k(a.SVGElement.prototype, {\n      htmlCss: function htmlCss(a) {\n        var b = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n            f = p(b && a.width, void 0);\n        b && (delete a.width, this.textWidth = f, this.htmlUpdateTransform());\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = k(this.styles, a);\n        D(this.element, a);\n        return this;\n      },\n      htmlGetBBox: function htmlGetBBox() {\n        var a = this.element;\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function htmlUpdateTransform() {\n        if (this.added) {\n          var a = this.renderer,\n              c = this.element,\n              f = this.translateX || 0,\n              e = this.translateY || 0,\n              h = this.x || 0,\n              m = this.y || 0,\n              g = this.textAlign || \"left\",\n              p = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[g],\n              A = this.styles,\n              q = A && A.whiteSpace;\n          D(c, {\n            marginLeft: f,\n            marginTop: e\n          });\n          this.shadows && d(this.shadows, function (a) {\n            D(a, {\n              marginLeft: f + 1,\n              marginTop: e + 1\n            });\n          });\n          this.inverted && d(c.childNodes, function (b) {\n            a.invertChild(b, c);\n          });\n\n          if (\"SPAN\" === c.tagName) {\n            var A = this.rotation,\n                r = this.textWidth && y(this.textWidth),\n                I = [A, g, c.innerHTML, this.textWidth, this.textAlign].join(),\n                E;\n            (E = r !== this.oldTextWidth) && !(E = r > this.oldTextWidth) && ((E = this.textPxLength) || (D(c, {\n              width: \"\",\n              whiteSpace: q || \"nowrap\"\n            }), E = c.offsetWidth), E = E > r);\n            E && /[ \\-]/.test(c.textContent || c.innerText) ? (D(c, {\n              width: r + \"px\",\n              display: \"block\",\n              whiteSpace: q || \"normal\"\n            }), this.oldTextWidth = r, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            I !== this.cTT && (q = a.fontMetrics(c.style.fontSize).b, !n(A) || A === (this.oldRotation || 0) && g === this.oldAlign || this.setSpanRotation(A, p, q), this.getSpanCorrection(!n(A) && this.textPxLength || c.offsetWidth, q, p, A, g));\n            D(c, {\n              left: h + (this.xCorr || 0) + \"px\",\n              top: m + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = I;\n            this.oldRotation = A;\n            this.oldAlign = g;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function setSpanRotation(a, c, f) {\n        var b = {},\n            h = this.renderer.getTransformKey();\n        b[h] = b.transform = \"rotate(\" + a + \"deg)\";\n        b[h + (u ? \"Origin\" : \"-origin\")] = b.transformOrigin = 100 * c + \"% \" + f + \"px\";\n        D(this.element, b);\n      },\n      getSpanCorrection: function getSpanCorrection(a, c, f) {\n        this.xCorr = -a * f;\n        this.yCorr = -c;\n      }\n    });\n    k(g.prototype, {\n      getTransformKey: function getTransformKey() {\n        return v && !/Edge/.test(h.navigator.userAgent) ? \"-ms-transform\" : q ? \"-webkit-transform\" : u ? \"MozTransform\" : h.opera ? \"-o-transform\" : \"\";\n      },\n      html: function html(a, c, f) {\n        var b = this.createElement(\"span\"),\n            h = b.element,\n            g = b.renderer,\n            t = g.isSVG,\n            q = function q(a, b) {\n          d([\"opacity\", \"visibility\"], function (c) {\n            m(a, c + \"Setter\", function (a, c, f, e) {\n              a.call(this, c, f, e);\n              b[f] = c;\n            });\n          });\n          a.addedSetters = !0;\n        };\n\n        b.textSetter = function (a) {\n          a !== h.innerHTML && delete this.bBox;\n          this.textStr = a;\n          h.innerHTML = p(a, \"\");\n          b.doTransform = !0;\n        };\n\n        t && q(b, b.element.style);\n\n        b.xSetter = b.ySetter = b.alignSetter = b.rotationSetter = function (a, c) {\n          \"align\" === c && (c = \"textAlign\");\n          b[c] = a;\n          b.doTransform = !0;\n        };\n\n        b.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        b.attr({\n          text: a,\n          x: Math.round(c),\n          y: Math.round(f)\n        }).css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize,\n          position: \"absolute\"\n        });\n        h.style.whiteSpace = \"nowrap\";\n        b.css = b.htmlCss;\n        t && (b.add = function (a) {\n          var c,\n              f = g.box.parentNode,\n              e = [];\n\n          if (this.parentGroup = a) {\n            if (c = a.div, !c) {\n              for (; a;) {\n                e.push(a), a = a.parentGroup;\n              }\n\n              d(e.reverse(), function (a) {\n                function r(b, l) {\n                  a[l] = b;\n                  \"translateX\" === l ? h.left = b + \"px\" : h.top = b + \"px\";\n                  a.doTransform = !0;\n                }\n\n                var h,\n                    l = B(a.element, \"class\");\n                l && (l = {\n                  className: l\n                });\n                c = a.div = a.div || C(\"div\", l, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  pointerEvents: a.styles && a.styles.pointerEvents\n                }, c || f);\n                h = c.style;\n                k(a, {\n                  classSetter: function (a) {\n                    return function (b) {\n                      this.element.setAttribute(\"class\", b);\n                      a.className = b;\n                    };\n                  }(c),\n                  on: function on() {\n                    e[0].div && b.on.apply({\n                      element: e[0].div\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: r,\n                  translateYSetter: r\n                });\n                a.addedSetters || q(a, h);\n              });\n            }\n          } else c = f;\n\n          c.appendChild(h);\n          b.added = !0;\n          b.alignOnAdd && b.htmlUpdateTransform();\n          return b;\n        });\n        return b;\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.correctFloat,\n        C = a.defined,\n        D = a.destroyObjectProperties,\n        n = a.fireEvent,\n        d = a.isNumber,\n        k = a.merge,\n        u = a.pick,\n        v = a.deg2rad;\n\n    a.Tick = function (a, p, d, g, h) {\n      this.axis = a;\n      this.pos = p;\n      this.type = d || \"\";\n      this.isNewLabel = this.isNew = !0;\n      this.parameters = h || {};\n      this.tickmarkOffset = this.parameters.tickmarkOffset;\n      this.options = this.parameters.options;\n      d || g || this.addLabel();\n    };\n\n    a.Tick.prototype = {\n      addLabel: function addLabel() {\n        var d = this,\n            p = d.axis,\n            n = p.options,\n            g = p.chart,\n            h = p.categories,\n            m = p.names,\n            b = d.pos,\n            c = u(d.options && d.options.labels, n.labels),\n            f = p.tickPositions,\n            e = b === f[0],\n            w = b === f[f.length - 1],\n            h = this.parameters.category || (h ? u(h[b], m[b], b) : b),\n            G = d.label,\n            f = f.info,\n            t,\n            K,\n            A,\n            F;\n        p.isDatetimeAxis && f && (K = g.time.resolveDTLFormat(n.dateTimeLabelFormats[!n.grid && f.higherRanks[b] || f.unitName]), t = K.main);\n        d.isFirst = e;\n        d.isLast = w;\n        d.formatCtx = {\n          axis: p,\n          chart: g,\n          isFirst: e,\n          isLast: w,\n          dateTimeLabelFormat: t,\n          tickPositionInfo: f,\n          value: p.isLog ? B(p.lin2log(h)) : h,\n          pos: b\n        };\n        n = p.labelFormatter.call(d.formatCtx, this.formatCtx);\n        if (F = K && K.list) d.shortenLabel = function () {\n          for (A = 0; A < F.length; A++) {\n            if (G.attr({\n              text: p.labelFormatter.call(a.extend(d.formatCtx, {\n                dateTimeLabelFormat: F[A]\n              }))\n            }), G.getBBox().width < p.getSlotWidth(d) - 2 * u(c.padding, 5)) return;\n          }\n\n          G.attr({\n            text: \"\"\n          });\n        };\n        if (C(G)) G && G.textStr !== n && (!G.textWidth || c.style && c.style.width || G.styles.width || G.css({\n          width: null\n        }), G.attr({\n          text: n\n        }));else {\n          if (d.label = G = C(n) && c.enabled ? g.renderer.text(n, 0, 0, c.useHTML).css(k(c.style)).add(p.labelGroup) : null) G.textPxLength = G.getBBox().width;\n          d.rotation = 0;\n        }\n      },\n      getLabelSize: function getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      },\n      handleOverflow: function handleOverflow(a) {\n        var d = this.axis,\n            q = d.options.labels,\n            g = a.x,\n            h = d.chart.chartWidth,\n            m = d.chart.spacing,\n            b = u(d.labelLeft, Math.min(d.pos, m[3])),\n            m = u(d.labelRight, Math.max(d.isRadial ? 0 : d.pos + d.len, h - m[1])),\n            c = this.label,\n            f = this.rotation,\n            e = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[d.labelAlign || c.attr(\"align\")],\n            w = c.getBBox().width,\n            G = d.getSlotWidth(this),\n            t = G,\n            k = 1,\n            A,\n            n = {};\n        if (f || \"justify\" !== u(q.overflow, \"justify\")) 0 > f && g - e * w < b ? A = Math.round(g / Math.cos(f * v) - b) : 0 < f && g + e * w > m && (A = Math.round((h - g) / Math.cos(f * v)));else if (h = g + (1 - e) * w, g - e * w < b ? t = a.x + t * (1 - e) - b : h > m && (t = m - a.x + t * e, k = -1), t = Math.min(G, t), t < G && \"center\" === d.labelAlign && (a.x += k * (G - t - e * (G - Math.min(w, t)))), w > t || d.autoRotation && (c.styles || {}).width) A = t;\n        A && (this.shortenLabel ? this.shortenLabel() : (n.width = A, (q.style || {}).textOverflow || (n.textOverflow = \"ellipsis\"), c.css(n)));\n      },\n      getPosition: function getPosition(d, p, k, g) {\n        var h = this.axis,\n            m = h.chart,\n            b = g && m.oldChartHeight || m.chartHeight;\n        d = {\n          x: d ? a.correctFloat(h.translate(p + k, null, null, g) + h.transB) : h.left + h.offset + (h.opposite ? (g && m.oldChartWidth || m.chartWidth) - h.right - h.left : 0),\n          y: d ? b - h.bottom + h.offset - (h.opposite ? h.height : 0) : a.correctFloat(b - h.translate(p + k, null, null, g) - h.transB)\n        };\n        n(this, \"afterGetPosition\", {\n          pos: d\n        });\n        return d;\n      },\n      getLabelPosition: function getLabelPosition(a, d, k, g, h, m, b, c) {\n        var f = this.axis,\n            e = f.transA,\n            w = f.reversed,\n            p = f.staggerLines,\n            t = f.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            q = h.y,\n            A = g || f.reserveSpaceDefault ? 0 : -f.labelOffset * (\"center\" === f.labelAlign ? .5 : 1),\n            F = {};\n        C(q) || (q = 0 === f.side ? k.rotation ? -8 : -k.getBBox().height : 2 === f.side ? t.y + 8 : Math.cos(k.rotation * v) * (t.y - k.getBBox(!1, 0).height / 2));\n        a = a + h.x + A + t.x - (m && g ? m * e * (w ? -1 : 1) : 0);\n        d = d + q - (m && !g ? m * e * (w ? 1 : -1) : 0);\n        p && (k = b / (c || 1) % p, f.opposite && (k = p - k - 1), d += f.labelOffset / p * k);\n        F.x = a;\n        F.y = Math.round(d);\n        n(this, \"afterGetLabelPosition\", {\n          pos: F\n        });\n        return F;\n      },\n      getMarkPath: function getMarkPath(a, d, k, g, h, m) {\n        return m.crispLine([\"M\", a, d, \"L\", a + (h ? 0 : -k), d + (h ? k : 0)], g);\n      },\n      renderGridLine: function renderGridLine(a, d, k) {\n        var g = this.axis,\n            h = g.options,\n            m = this.gridLine,\n            b = {},\n            c = this.pos,\n            f = this.type,\n            e = u(this.tickmarkOffset, g.tickmarkOffset),\n            w = g.chart.renderer,\n            p = f ? f + \"Grid\" : \"grid\",\n            t = h[p + \"LineWidth\"],\n            q = h[p + \"LineColor\"],\n            h = h[p + \"LineDashStyle\"];\n        m || (b.stroke = q, b[\"stroke-width\"] = t, h && (b.dashstyle = h), f || (b.zIndex = 1), a && (d = 0), this.gridLine = m = w.path().attr(b).addClass(\"highcharts-\" + (f ? f + \"-\" : \"\") + \"grid-line\").add(g.gridGroup));\n        if (m && (k = g.getPlotLinePath(c + e, m.strokeWidth() * k, a, \"pass\"))) m[a || this.isNew ? \"attr\" : \"animate\"]({\n          d: k,\n          opacity: d\n        });\n      },\n      renderMark: function renderMark(a, d, k) {\n        var g = this.axis,\n            h = g.options,\n            m = g.chart.renderer,\n            b = this.type,\n            c = b ? b + \"Tick\" : \"tick\",\n            f = g.tickSize(c),\n            e = this.mark,\n            w = !e,\n            p = a.x;\n        a = a.y;\n        var t = u(h[c + \"Width\"], !b && g.isXAxis ? 1 : 0),\n            h = h[c + \"Color\"];\n        f && (g.opposite && (f[0] = -f[0]), w && (this.mark = e = m.path().addClass(\"highcharts-\" + (b ? b + \"-\" : \"\") + \"tick\").add(g.axisGroup), e.attr({\n          stroke: h,\n          \"stroke-width\": t\n        })), e[w ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(p, a, f[0], e.strokeWidth() * k, g.horiz, m),\n          opacity: d\n        }));\n      },\n      renderLabel: function renderLabel(a, p, k, g) {\n        var h = this.axis,\n            m = h.horiz,\n            b = h.options,\n            c = this.label,\n            f = b.labels,\n            e = f.step,\n            h = u(this.tickmarkOffset, h.tickmarkOffset),\n            w = !0,\n            G = a.x;\n        a = a.y;\n        c && d(G) && (c.xy = a = this.getLabelPosition(G, a, c, m, f, h, g, e), this.isFirst && !this.isLast && !u(b.showFirstLabel, 1) || this.isLast && !this.isFirst && !u(b.showLastLabel, 1) ? w = !1 : !m || f.step || f.rotation || p || 0 === k || this.handleOverflow(a), e && g % e && (w = !1), w && d(a.y) ? (a.opacity = k, c[this.isNewLabel ? \"attr\" : \"animate\"](a), this.isNewLabel = !1) : (c.attr(\"y\", -9999), this.isNewLabel = !0));\n      },\n      render: function render(d, p, k) {\n        var g = this.axis,\n            h = g.horiz,\n            m = this.pos,\n            b = u(this.tickmarkOffset, g.tickmarkOffset),\n            m = this.getPosition(h, m, b, p),\n            b = m.x,\n            c = m.y,\n            g = h && b === g.pos + g.len || !h && c === g.pos ? -1 : 1;\n        k = u(k, 1);\n        this.isActive = !0;\n        this.renderGridLine(p, k, g);\n        this.renderMark(m, k, g);\n        this.renderLabel(m, p, k, d);\n        this.isNew = !1;\n        a.fireEvent(this, \"afterRender\");\n      },\n      destroy: function destroy() {\n        D(this, this.axis);\n      }\n    };\n  })(M);\n\n  var W = function (a) {\n    var B = a.addEvent,\n        C = a.animObject,\n        D = a.arrayMax,\n        n = a.arrayMin,\n        d = a.color,\n        k = a.correctFloat,\n        u = a.defaultOptions,\n        v = a.defined,\n        q = a.deg2rad,\n        p = a.destroyObjectProperties,\n        y = a.each,\n        g = a.extend,\n        h = a.fireEvent,\n        m = a.format,\n        b = a.getMagnitude,\n        c = a.grep,\n        f = a.inArray,\n        e = a.isArray,\n        w = a.isNumber,\n        G = a.isString,\n        t = a.merge,\n        K = a.normalizeTickInterval,\n        A = a.objectEach,\n        F = a.pick,\n        r = a.removeEvent,\n        I = a.splat,\n        E = a.syncTimeout,\n        L = a.Tick,\n        J = function J() {\n      this.init.apply(this, arguments);\n    };\n\n    a.extend(J.prototype, {\n      defaultOptions: {\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e. %b\"\n          },\n          week: {\n            main: \"%e. %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          indentation: 10,\n          x: 0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      },\n      defaultYAxisOptions: {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          allowOverlap: !1,\n          enabled: !1,\n          formatter: function formatter() {\n            return a.numberFormat(this.total, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      },\n      defaultLeftAxisOptions: {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      },\n      defaultRightAxisOptions: {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      },\n      defaultBottomAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        title: {\n          rotation: 0\n        }\n      },\n      defaultTopAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        title: {\n          rotation: 0\n        }\n      },\n      init: function init(a, b) {\n        var l = b.isX,\n            c = this;\n        c.chart = a;\n        c.horiz = a.inverted && !c.isZAxis ? !l : l;\n        c.isXAxis = l;\n        c.coll = c.coll || (l ? \"xAxis\" : \"yAxis\");\n        h(this, \"init\", {\n          userOptions: b\n        });\n        c.opposite = b.opposite;\n        c.side = b.side || (c.horiz ? c.opposite ? 0 : 2 : c.opposite ? 1 : 3);\n        c.setOptions(b);\n        var x = this.options,\n            e = x.type;\n        c.labelFormatter = x.labels.formatter || c.defaultLabelFormatter;\n        c.userOptions = b;\n        c.minPixelPadding = 0;\n        c.reversed = x.reversed;\n        c.visible = !1 !== x.visible;\n        c.zoomEnabled = !1 !== x.zoomEnabled;\n        c.hasNames = \"category\" === e || !0 === x.categories;\n        c.categories = x.categories || c.hasNames;\n        c.names || (c.names = [], c.names.keys = {});\n        c.plotLinesAndBandsGroups = {};\n        c.isLog = \"logarithmic\" === e;\n        c.isDatetimeAxis = \"datetime\" === e;\n        c.positiveValuesOnly = c.isLog && !c.allowNegativeLog;\n        c.isLinked = v(x.linkedTo);\n        c.ticks = {};\n        c.labelEdge = [];\n        c.minorTicks = {};\n        c.plotLinesAndBands = [];\n        c.alternateBands = {};\n        c.len = 0;\n        c.minRange = c.userMinRange = x.minRange || x.maxZoom;\n        c.range = x.range;\n        c.offset = x.offset || 0;\n        c.stacks = {};\n        c.oldStacks = {};\n        c.stacksTouched = 0;\n        c.max = null;\n        c.min = null;\n        c.crosshair = F(x.crosshair, I(a.options.tooltip.crosshairs)[l ? 0 : 1], !1);\n        b = c.options.events;\n        -1 === f(c, a.axes) && (l ? a.axes.splice(a.xAxis.length, 0, c) : a.axes.push(c), a[c.coll].push(c));\n        c.series = c.series || [];\n        a.inverted && !c.isZAxis && l && void 0 === c.reversed && (c.reversed = !0);\n        A(b, function (a, b) {\n          B(c, b, a);\n        });\n        c.lin2log = x.linearToLogConverter || c.lin2log;\n        c.isLog && (c.val2lin = c.log2lin, c.lin2val = c.lin2log);\n        h(this, \"afterInit\");\n      },\n      setOptions: function setOptions(a) {\n        this.options = t(this.defaultOptions, \"yAxis\" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], t(u[this.coll], a));\n        h(this, \"afterSetOptions\", {\n          userOptions: a\n        });\n      },\n      defaultLabelFormatter: function defaultLabelFormatter() {\n        var b = this.axis,\n            c = this.value,\n            f = b.chart.time,\n            e = b.categories,\n            r = this.dateTimeLabelFormat,\n            h = u.lang,\n            d = h.numericSymbols,\n            h = h.numericSymbolMagnitude || 1E3,\n            g = d && d.length,\n            t,\n            w = b.options.labels.format,\n            b = b.isLog ? Math.abs(c) : b.tickInterval;\n        if (w) t = m(w, this, f);else if (e) t = c;else if (r) t = f.dateFormat(r, c);else if (g && 1E3 <= b) for (; g-- && void 0 === t;) {\n          f = Math.pow(h, g + 1), b >= f && 0 === 10 * c % f && null !== d[g] && 0 !== c && (t = a.numberFormat(c / f, -1) + d[g]);\n        }\n        void 0 === t && (t = 1E4 <= Math.abs(c) ? a.numberFormat(c, -1) : a.numberFormat(c, -1, void 0, \"\"));\n        return t;\n      },\n      getSeriesExtremes: function getSeriesExtremes() {\n        var a = this,\n            b = a.chart;\n        h(this, \"getSeriesExtremes\", null, function () {\n          a.hasVisibleSeries = !1;\n          a.dataMin = a.dataMax = a.threshold = null;\n          a.softThreshold = !a.isXAxis;\n          a.buildStacks && a.buildStacks();\n          y(a.series, function (l) {\n            if (l.visible || !b.options.chart.ignoreHiddenSeries) {\n              var x = l.options,\n                  f = x.threshold,\n                  e;\n              a.hasVisibleSeries = !0;\n              a.positiveValuesOnly && 0 >= f && (f = null);\n              if (a.isXAxis) x = l.xData, x.length && (l = n(x), e = D(x), w(l) || l instanceof Date || (x = c(x, w), l = n(x), e = D(x)), x.length && (a.dataMin = Math.min(F(a.dataMin, x[0], l), l), a.dataMax = Math.max(F(a.dataMax, x[0], e), e)));else if (l.getExtremes(), e = l.dataMax, l = l.dataMin, v(l) && v(e) && (a.dataMin = Math.min(F(a.dataMin, l), l), a.dataMax = Math.max(F(a.dataMax, e), e)), v(f) && (a.threshold = f), !x.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;\n            }\n          });\n        });\n        h(this, \"afterGetSeriesExtremes\");\n      },\n      translate: function translate(a, b, c, f, e, r) {\n        var l = this.linkedParent || this,\n            x = 1,\n            h = 0,\n            H = f ? l.oldTransA : l.transA;\n        f = f ? l.oldMin : l.min;\n        var d = l.minPixelPadding;\n        e = (l.isOrdinal || l.isBroken || l.isLog && e) && l.lin2val;\n        H || (H = l.transA);\n        c && (x *= -1, h = l.len);\n        l.reversed && (x *= -1, h -= x * (l.sector || l.len));\n        b ? (a = (a * x + h - d) / H + f, e && (a = l.lin2val(a))) : (e && (a = l.val2lin(a)), a = w(f) ? x * (a - f) * H + h + x * d + (w(r) ? H * r : 0) : void 0);\n        return a;\n      },\n      toPixels: function toPixels(a, b) {\n        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);\n      },\n      toValue: function toValue(a, b) {\n        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);\n      },\n      getPlotLinePath: function getPlotLinePath(a, b, c, f, e) {\n        var l = this.chart,\n            x = this.left,\n            r = this.top,\n            h,\n            H,\n            d = c && l.oldChartHeight || l.chartHeight,\n            g = c && l.oldChartWidth || l.chartWidth,\n            m;\n        h = this.transB;\n\n        var t = function t(a, b, c) {\n          if (\"pass\" !== f && a < b || a > c) f ? a = Math.min(Math.max(b, a), c) : m = !0;\n          return a;\n        };\n\n        e = F(e, this.translate(a, null, null, c));\n        e = Math.min(Math.max(-1E5, e), 1E5);\n        a = c = Math.round(e + h);\n        h = H = Math.round(d - e - h);\n        w(e) ? this.horiz ? (h = r, H = d - this.bottom, a = c = t(a, x, x + this.width)) : (a = x, c = g - this.right, h = H = t(h, r, r + this.height)) : (m = !0, f = !1);\n        return m && !f ? null : l.renderer.crispLine([\"M\", a, h, \"L\", c, H], b || 1);\n      },\n      getLinearTickPositions: function getLinearTickPositions(a, b, c) {\n        var l,\n            f = k(Math.floor(b / a) * a);\n        c = k(Math.ceil(c / a) * a);\n        var x = [],\n            e;\n        k(f + a) === f && (e = 20);\n        if (this.single) return [b];\n\n        for (b = f; b <= c;) {\n          x.push(b);\n          b = k(b + a, e);\n          if (b === l) break;\n          l = b;\n        }\n\n        return x;\n      },\n      getMinorTickInterval: function getMinorTickInterval() {\n        var a = this.options;\n        return !0 === a.minorTicks ? F(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      },\n      getMinorTickPositions: function getMinorTickPositions() {\n        var a = this,\n            b = a.options,\n            c = a.tickPositions,\n            f = a.minorTickInterval,\n            e = [],\n            r = a.pointRangePadding || 0,\n            h = a.min - r,\n            r = a.max + r,\n            d = r - h;\n        if (d && d / f < a.len / 3) if (a.isLog) y(this.paddedTicks, function (b, c, l) {\n          c && e.push.apply(e, a.getLogTickPositions(f, l[c - 1], l[c], !0));\n        });else if (a.isDatetimeAxis && \"auto\" === this.getMinorTickInterval()) e = e.concat(a.getTimeTicks(a.normalizeTimeTickInterval(f), h, r, b.startOfWeek));else for (b = h + (c[0] - h) % f; b <= r && b !== e[0]; b += f) {\n          e.push(b);\n        }\n        0 !== e.length && a.trimTicks(e);\n        return e;\n      },\n      adjustForMinRange: function adjustForMinRange() {\n        var a = this.options,\n            b = this.min,\n            c = this.max,\n            f,\n            e,\n            r,\n            h,\n            d,\n            g,\n            m,\n            t;\n        this.isXAxis && void 0 === this.minRange && !this.isLog && (v(a.min) || v(a.max) ? this.minRange = null : (y(this.series, function (a) {\n          g = a.xData;\n\n          for (h = m = a.xIncrement ? 1 : g.length - 1; 0 < h; h--) {\n            if (d = g[h] - g[h - 1], void 0 === r || d < r) r = d;\n          }\n        }), this.minRange = Math.min(5 * r, this.dataMax - this.dataMin)));\n        c - b < this.minRange && (e = this.dataMax - this.dataMin >= this.minRange, t = this.minRange, f = (t - c + b) / 2, f = [b - f, F(a.min, b - f)], e && (f[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), b = D(f), c = [b + t, F(a.max, b + t)], e && (c[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), c = n(c), c - b < t && (f[0] = c - t, f[1] = F(a.min, c - t), b = D(f)));\n        this.min = b;\n        this.max = c;\n      },\n      getClosest: function getClosest() {\n        var a;\n        this.categories ? a = 1 : y(this.series, function (b) {\n          var c = b.closestPointRange,\n              l = b.visible || !b.chart.options.chart.ignoreHiddenSeries;\n          !b.noSharedTooltip && v(c) && l && (a = v(a) ? Math.min(a, c) : c);\n        });\n        return a;\n      },\n      nameToX: function nameToX(a) {\n        var b = e(this.categories),\n            c = b ? this.categories : this.names,\n            l = a.options.x,\n            r;\n        a.series.requireSorting = !1;\n        v(l) || (l = !1 === this.options.uniqueNames ? a.series.autoIncrement() : b ? f(a.name, c) : F(c.keys[a.name], -1));\n        -1 === l ? b || (r = c.length) : r = l;\n        void 0 !== r && (this.names[r] = a.name, this.names.keys[a.name] = r);\n        return r;\n      },\n      updateNames: function updateNames() {\n        var b = this,\n            c = this.names;\n        0 < c.length && (y(a.keys(c.keys), function (a) {\n          delete c.keys[a];\n        }), c.length = 0, this.minRange = this.userMinRange, y(this.series || [], function (a) {\n          a.xIncrement = null;\n          if (!a.points || a.isDirtyData) a.processData(), a.generatePoints();\n          y(a.points, function (c, l) {\n            var f;\n            c.options && (f = b.nameToX(c), void 0 !== f && f !== c.x && (c.x = f, a.xData[l] = f));\n          });\n        }));\n      },\n      setAxisTranslation: function setAxisTranslation(a) {\n        var b = this,\n            c = b.max - b.min,\n            l = b.axisPointRange || 0,\n            f,\n            e = 0,\n            r = 0,\n            d = b.linkedParent,\n            g = !!b.categories,\n            m = b.transA,\n            t = b.isXAxis;\n        if (t || g || l) f = b.getClosest(), d ? (e = d.minPointOffset, r = d.pointRangePadding) : y(b.series, function (a) {\n          var c = g ? 1 : t ? F(a.options.pointRange, f, 0) : b.axisPointRange || 0;\n          a = a.options.pointPlacement;\n          l = Math.max(l, c);\n          b.single || (e = Math.max(e, G(a) ? 0 : c / 2), r = Math.max(r, \"on\" === a ? 0 : c));\n        }), d = b.ordinalSlope && f ? b.ordinalSlope / f : 1, b.minPointOffset = e *= d, b.pointRangePadding = r *= d, b.pointRange = Math.min(l, c), t && (b.closestPointRange = f);\n        a && (b.oldTransA = m);\n        b.translationSlope = b.transA = m = b.staticScale || b.len / (c + r || 1);\n        b.transB = b.horiz ? b.left : b.bottom;\n        b.minPixelPadding = m * e;\n        h(this, \"afterSetAxisTranslation\");\n      },\n      minFromRange: function minFromRange() {\n        return this.max - this.range;\n      },\n      setTickInterval: function setTickInterval(c) {\n        var l = this,\n            f = l.chart,\n            e = l.options,\n            r = l.isLog,\n            d = l.isDatetimeAxis,\n            g = l.isXAxis,\n            m = l.isLinked,\n            t = e.maxPadding,\n            E = e.minPadding,\n            p = e.tickInterval,\n            I = e.tickPixelInterval,\n            A = l.categories,\n            G = w(l.threshold) ? l.threshold : null,\n            q = l.softThreshold,\n            n,\n            J,\n            L,\n            u;\n        d || A || m || this.getTickAmount();\n        L = F(l.userMin, e.min);\n        u = F(l.userMax, e.max);\n        m ? (l.linkedParent = f[l.coll][e.linkedTo], f = l.linkedParent.getExtremes(), l.min = F(f.min, f.dataMin), l.max = F(f.max, f.dataMax), e.type !== l.linkedParent.options.type && a.error(11, 1)) : (!q && v(G) && (l.dataMin >= G ? (n = G, E = 0) : l.dataMax <= G && (J = G, t = 0)), l.min = F(L, n, l.dataMin), l.max = F(u, J, l.dataMax));\n        r && (l.positiveValuesOnly && !c && 0 >= Math.min(l.min, F(l.dataMin, l.min)) && a.error(10, 1), l.min = k(l.log2lin(l.min), 15), l.max = k(l.log2lin(l.max), 15));\n        l.range && v(l.max) && (l.userMin = l.min = L = Math.max(l.dataMin, l.minFromRange()), l.userMax = u = l.max, l.range = null);\n        h(l, \"foundExtremes\");\n        l.beforePadding && l.beforePadding();\n        l.adjustForMinRange();\n        !(A || l.axisPointRange || l.usePercentage || m) && v(l.min) && v(l.max) && (f = l.max - l.min) && (!v(L) && E && (l.min -= f * E), !v(u) && t && (l.max += f * t));\n        w(e.softMin) && !w(l.userMin) && (l.min = Math.min(l.min, e.softMin));\n        w(e.softMax) && !w(l.userMax) && (l.max = Math.max(l.max, e.softMax));\n        w(e.floor) && (l.min = Math.max(l.min, e.floor));\n        w(e.ceiling) && (l.max = Math.min(l.max, e.ceiling));\n        q && v(l.dataMin) && (G = G || 0, !v(L) && l.min < G && l.dataMin >= G ? l.min = G : !v(u) && l.max > G && l.dataMax <= G && (l.max = G));\n        l.tickInterval = l.min === l.max || void 0 === l.min || void 0 === l.max ? 1 : m && !p && I === l.linkedParent.options.tickPixelInterval ? p = l.linkedParent.tickInterval : F(p, this.tickAmount ? (l.max - l.min) / Math.max(this.tickAmount - 1, 1) : void 0, A ? 1 : (l.max - l.min) * I / Math.max(l.len, I));\n        g && !c && y(l.series, function (a) {\n          a.processData(l.min !== l.oldMin || l.max !== l.oldMax);\n        });\n        l.setAxisTranslation(!0);\n        l.beforeSetTickPositions && l.beforeSetTickPositions();\n        l.postProcessTickInterval && (l.tickInterval = l.postProcessTickInterval(l.tickInterval));\n        l.pointRange && !p && (l.tickInterval = Math.max(l.pointRange, l.tickInterval));\n        c = F(e.minTickInterval, l.isDatetimeAxis && l.closestPointRange);\n        !p && l.tickInterval < c && (l.tickInterval = c);\n        d || r || p || (l.tickInterval = K(l.tickInterval, null, b(l.tickInterval), F(e.allowDecimals, !(.5 < l.tickInterval && 5 > l.tickInterval && 1E3 < l.max && 9999 > l.max)), !!this.tickAmount));\n        this.tickAmount || (l.tickInterval = l.unsquish());\n        this.setTickPositions();\n      },\n      setTickPositions: function setTickPositions() {\n        var b = this.options,\n            c,\n            f = b.tickPositions;\n        c = this.getMinorTickInterval();\n        var e = b.tickPositioner,\n            r = b.startOnTick,\n            d = b.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === c && this.tickInterval ? this.tickInterval / 5 : c;\n        this.single = this.min === this.max && v(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);\n        this.tickPositions = c = f && f.slice();\n        !c && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (c = [this.min, this.max], a.error(19)) : c = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), c.length > this.len && (c = [c[0], c.pop()], c[0] === c[1] && (c.length = 1)), this.tickPositions = c, e && (e = e.apply(this, [this.min, this.max]))) && (this.tickPositions = c = e);\n        this.paddedTicks = c.slice(0);\n        this.trimTicks(c, r, d);\n        this.isLinked || (this.single && 2 > c.length && (this.min -= .5, this.max += .5), f || e || this.adjustTickAmount());\n        h(this, \"afterSetTickPositions\");\n      },\n      trimTicks: function trimTicks(a, b, c) {\n        var l = a[0],\n            f = a[a.length - 1],\n            e = this.minPointOffset || 0;\n\n        if (!this.isLinked) {\n          if (b && -Infinity !== l) this.min = l;else for (; this.min - e > a[0];) {\n            a.shift();\n          }\n          if (c) this.max = f;else for (; this.max + e < a[a.length - 1];) {\n            a.pop();\n          }\n          0 === a.length && v(l) && !this.options.tickPositions && a.push((f + l) / 2);\n        }\n      },\n      alignToOthers: function alignToOthers() {\n        var a = {},\n            b,\n            c = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === c.alignTicks || !1 === c.startOnTick || !1 === c.endOnTick || this.isLog || y(this.chart[this.coll], function (c) {\n          var l = c.options,\n              l = [c.horiz ? l.left : l.top, l.width, l.height, l.pane].join();\n          c.series.length && (a[l] ? b = !0 : a[l] = 1);\n        });\n        return b;\n      },\n      getTickAmount: function getTickAmount() {\n        var a = this.options,\n            b = a.tickAmount,\n            c = a.tickPixelInterval;\n        !v(a.tickInterval) && this.len < c && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);\n        !b && this.alignToOthers() && (b = Math.ceil(this.len / c) + 1);\n        4 > b && (this.finalTickAmt = b, b = 5);\n        this.tickAmount = b;\n      },\n      adjustTickAmount: function adjustTickAmount() {\n        var a = this.tickInterval,\n            b = this.tickPositions,\n            c = this.tickAmount,\n            f = this.finalTickAmt,\n            e = b && b.length,\n            r = F(this.threshold, this.softThreshold ? 0 : null);\n\n        if (this.hasData()) {\n          if (e < c) {\n            for (; b.length < c;) {\n              b.length % 2 || this.min === r ? b.push(k(b[b.length - 1] + a)) : b.unshift(k(b[0] - a));\n            }\n\n            this.transA *= (e - 1) / (c - 1);\n            this.min = b[0];\n            this.max = b[b.length - 1];\n          } else e > c && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (v(f)) {\n            for (a = c = b.length; a--;) {\n              (3 === f && 1 === a % 2 || 2 >= f && 0 < a && a < c - 1) && b.splice(a, 1);\n            }\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      },\n      setScale: function setScale() {\n        var a, b;\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        b = this.len !== this.oldAxisLength;\n        y(this.series, function (b) {\n          if (b.isDirtyData || b.isDirty || b.xAxis.isDirty) a = !0;\n        });\n        b || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();\n        h(this, \"afterSetScale\");\n      },\n      setExtremes: function setExtremes(a, b, c, f, e) {\n        var l = this,\n            r = l.chart;\n        c = F(c, !0);\n        y(l.series, function (a) {\n          delete a.kdTree;\n        });\n        e = g(e, {\n          min: a,\n          max: b\n        });\n        h(l, \"setExtremes\", e, function () {\n          l.userMin = a;\n          l.userMax = b;\n          l.eventArgs = e;\n          c && r.redraw(f);\n        });\n      },\n      zoom: function zoom(a, b) {\n        var c = this.dataMin,\n            l = this.dataMax,\n            f = this.options,\n            e = Math.min(c, F(f.min, c)),\n            f = Math.max(l, F(f.max, l));\n        if (a !== this.min || b !== this.max) this.allowZoomOutside || (v(c) && (a < e && (a = e), a > f && (a = f)), v(l) && (b < e && (b = e), b > f && (b = f))), this.displayBtn = void 0 !== a || void 0 !== b, this.setExtremes(a, b, !1, void 0, {\n          trigger: \"zoom\"\n        });\n        return !0;\n      },\n      setAxisSize: function setAxisSize() {\n        var b = this.chart,\n            c = this.options,\n            f = c.offsets || [0, 0, 0, 0],\n            e = this.horiz,\n            r = this.width = Math.round(a.relativeLength(F(c.width, b.plotWidth - f[3] + f[1]), b.plotWidth)),\n            h = this.height = Math.round(a.relativeLength(F(c.height, b.plotHeight - f[0] + f[2]), b.plotHeight)),\n            d = this.top = Math.round(a.relativeLength(F(c.top, b.plotTop + f[0]), b.plotHeight, b.plotTop)),\n            c = this.left = Math.round(a.relativeLength(F(c.left, b.plotLeft + f[3]), b.plotWidth, b.plotLeft));\n        this.bottom = b.chartHeight - h - d;\n        this.right = b.chartWidth - r - c;\n        this.len = Math.max(e ? r : h, 0);\n        this.pos = e ? c : d;\n      },\n      getExtremes: function getExtremes() {\n        var a = this.isLog;\n        return {\n          min: a ? k(this.lin2log(this.min)) : this.min,\n          max: a ? k(this.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      },\n      getThreshold: function getThreshold(a) {\n        var b = this.isLog,\n            c = b ? this.lin2log(this.min) : this.min,\n            b = b ? this.lin2log(this.max) : this.max;\n        null === a || -Infinity === a ? a = c : Infinity === a ? a = b : c > a ? a = c : b < a && (a = b);\n        return this.translate(a, 0, 1, 0, 1);\n      },\n      autoLabelAlign: function autoLabelAlign(a) {\n        a = (F(a, 0) - 90 * this.side + 720) % 360;\n        return 15 < a && 165 > a ? \"right\" : 195 < a && 345 > a ? \"left\" : \"center\";\n      },\n      tickSize: function tickSize(a) {\n        var b = this.options,\n            c = b[a + \"Length\"],\n            l = F(b[a + \"Width\"], \"tick\" === a && this.isXAxis ? 1 : 0);\n        if (l && c) return \"inside\" === b[a + \"Position\"] && (c = -c), [c, l];\n      },\n      labelMetrics: function labelMetrics() {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      },\n      unsquish: function unsquish() {\n        var a = this.options.labels,\n            b = this.horiz,\n            c = this.tickInterval,\n            f = c,\n            e = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / c),\n            r,\n            h = a.rotation,\n            d = this.labelMetrics(),\n            g,\n            m = Number.MAX_VALUE,\n            t,\n            w = function w(a) {\n          a /= e || 1;\n          a = 1 < a ? Math.ceil(a) : 1;\n          return k(a * c);\n        };\n\n        b ? (t = !a.staggerLines && !a.step && (v(h) ? [h] : e < F(a.autoRotationLimit, 80) && a.autoRotation)) && y(t, function (a) {\n          var b;\n          if (a === h || a && -90 <= a && 90 >= a) g = w(Math.abs(d.h / Math.sin(q * a))), b = g + Math.abs(a / 360), b < m && (m = b, r = a, f = g);\n        }) : a.step || (f = w(d.h));\n        this.autoRotation = t;\n        this.labelRotation = F(r, h);\n        return f;\n      },\n      getSlotWidth: function getSlotWidth(a) {\n        var b = this.chart,\n            c = this.horiz,\n            l = this.options.labels,\n            f = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            e = b.margin[3];\n        return a && a.slotWidth || c && 2 > (l.step || 0) && !l.rotation && (this.staggerLines || 1) * this.len / f || !c && (l.style && parseInt(l.style.width, 10) || e && e - b.spacing[3] || .33 * b.chartWidth);\n      },\n      renderUnsquish: function renderUnsquish() {\n        var a = this.chart,\n            b = a.renderer,\n            c = this.tickPositions,\n            f = this.ticks,\n            e = this.options.labels,\n            r = e && e.style || {},\n            h = this.horiz,\n            d = this.getSlotWidth(),\n            g = Math.max(1, Math.round(d - 2 * (e.padding || 5))),\n            m = {},\n            t = this.labelMetrics(),\n            w = e.style && e.style.textOverflow,\n            E,\n            p,\n            I = 0,\n            A;\n        G(e.rotation) || (m.rotation = e.rotation || 0);\n        y(c, function (a) {\n          (a = f[a]) && a.label && a.label.textPxLength > I && (I = a.label.textPxLength);\n        });\n        this.maxLabelLength = I;\n        if (this.autoRotation) I > g && I > t.h ? m.rotation = this.labelRotation : this.labelRotation = 0;else if (d && (E = g, !w)) for (p = \"clip\", g = c.length; !h && g--;) {\n          if (A = c[g], A = f[A].label) A.styles && \"ellipsis\" === A.styles.textOverflow ? A.css({\n            textOverflow: \"clip\"\n          }) : A.textPxLength > d && A.css({\n            width: d + \"px\"\n          }), A.getBBox().height > this.len / c.length - (t.h - t.f) && (A.specificTextOverflow = \"ellipsis\");\n        }\n        m.rotation && (E = I > .5 * a.chartHeight ? .33 * a.chartHeight : I, w || (p = \"ellipsis\"));\n        if (this.labelAlign = e.align || this.autoLabelAlign(this.labelRotation)) m.align = this.labelAlign;\n        y(c, function (a) {\n          var b = (a = f[a]) && a.label,\n              c = r.width,\n              l = {};\n          b && (b.attr(m), a.shortenLabel ? a.shortenLabel() : E && !c && \"nowrap\" !== r.whiteSpace && (E < b.textPxLength || \"SPAN\" === b.element.tagName) ? (l.width = E, w || (l.textOverflow = b.specificTextOverflow || p), b.css(l)) : b.styles && b.styles.width && !l.width && !c && b.css({\n            width: null\n          }), delete b.specificTextOverflow, a.rotation = m.rotation);\n        }, this);\n        this.tickRotCorr = b.rotCorr(t.b, this.labelRotation || 0, 0 !== this.side);\n      },\n      hasData: function hasData() {\n        return this.hasVisibleSeries || v(this.min) && v(this.max) && this.tickPositions && 0 < this.tickPositions.length;\n      },\n      addTitle: function addTitle(a) {\n        var b = this.chart.renderer,\n            c = this.horiz,\n            l = this.opposite,\n            f = this.options.title,\n            e;\n        this.axisTitle || ((e = f.textAlign) || (e = (c ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: l ? \"right\" : \"left\",\n          middle: \"center\",\n          high: l ? \"left\" : \"right\"\n        })[f.align]), this.axisTitle = b.text(f.text, 0, 0, f.useHTML).attr({\n          zIndex: 7,\n          rotation: f.rotation || 0,\n          align: e\n        }).addClass(\"highcharts-axis-title\").css(t(f.style)).add(this.axisGroup), this.axisTitle.isNew = !0);\n        f.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len\n        });\n        this.axisTitle[a ? \"show\" : \"hide\"](!0);\n      },\n      generateTick: function generateTick(a) {\n        var b = this.ticks;\n        b[a] ? b[a].addLabel() : b[a] = new L(this, a);\n      },\n      getOffset: function getOffset() {\n        var a = this,\n            b = a.chart,\n            c = b.renderer,\n            f = a.options,\n            e = a.tickPositions,\n            r = a.ticks,\n            d = a.horiz,\n            g = a.side,\n            m = b.inverted && !a.isZAxis ? [1, 0, 3, 2][g] : g,\n            t,\n            w,\n            E = 0,\n            p,\n            I = 0,\n            k = f.title,\n            G = f.labels,\n            q = 0,\n            n = b.axisOffset,\n            b = b.clipOffset,\n            J = [-1, 1, 1, -1][g],\n            L = f.className,\n            K = a.axisParent;\n        t = a.hasData();\n        a.showAxis = w = t || F(f.showEmpty, !0);\n        a.staggerLines = a.horiz && G.staggerLines;\n        a.axisGroup || (a.gridGroup = c.g(\"grid\").attr({\n          zIndex: f.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (L || \"\")).add(K), a.axisGroup = c.g(\"axis\").attr({\n          zIndex: f.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (L || \"\")).add(K), a.labelGroup = c.g(\"axis-labels\").attr({\n          zIndex: G.zIndex || 7\n        }).addClass(\"highcharts-\" + a.coll.toLowerCase() + \"-labels \" + (L || \"\")).add(K));\n        t || a.isLinked ? (y(e, function (b, c) {\n          a.generateTick(b, c);\n        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === g || 2 === g || {\n          1: \"left\",\n          3: \"right\"\n        }[g] === a.labelAlign, F(G.reserveSpace, \"center\" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && y(e, function (a) {\n          q = Math.max(r[a].getLabelSize(), q);\n        }), a.staggerLines && (q *= a.staggerLines), a.labelOffset = q * (a.opposite ? -1 : 1)) : A(r, function (a, b) {\n          a.destroy();\n          delete r[b];\n        });\n        k && k.text && !1 !== k.enabled && (a.addTitle(w), w && !1 !== k.reserveSpace && (a.titleOffset = E = a.axisTitle.getBBox()[d ? \"height\" : \"width\"], p = k.offset, I = v(p) ? 0 : F(k.margin, d ? 5 : 10)));\n        a.renderLine();\n        a.offset = J * F(f.offset, n[g]);\n        a.tickRotCorr = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        c = 0 === g ? -a.labelMetrics().h : 2 === g ? a.tickRotCorr.y : 0;\n        I = Math.abs(q) + I;\n        q && (I = I - c + J * (d ? F(G.y, a.tickRotCorr.y + 8 * J) : G.x));\n        a.axisTitleMargin = F(p, I);\n        a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(r, e));\n        d = this.tickSize(\"tick\");\n        n[g] = Math.max(n[g], a.axisTitleMargin + E + J * a.offset, I, t && e.length && d ? d[0] + J * a.offset : 0);\n        f = f.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);\n        b[m] = Math.max(b[m], f);\n        h(this, \"afterGetOffset\");\n      },\n      getLinePath: function getLinePath(a) {\n        var b = this.chart,\n            c = this.opposite,\n            f = this.offset,\n            e = this.horiz,\n            l = this.left + (c ? this.width : 0) + f,\n            f = b.chartHeight - this.bottom - (c ? this.height : 0) + f;\n        c && (a *= -1);\n        return b.renderer.crispLine([\"M\", e ? this.left : l, e ? f : this.top, \"L\", e ? b.chartWidth - this.right : l, e ? f : b.chartHeight - this.bottom], a);\n      },\n      renderLine: function renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      },\n      getTitlePosition: function getTitlePosition() {\n        var a = this.horiz,\n            b = this.left,\n            c = this.top,\n            f = this.len,\n            e = this.options.title,\n            r = a ? b : c,\n            h = this.opposite,\n            d = this.offset,\n            g = e.x || 0,\n            m = e.y || 0,\n            t = this.axisTitle,\n            w = this.chart.renderer.fontMetrics(e.style && e.style.fontSize, t),\n            t = Math.max(t.getBBox(null, 0).height - w.h - 1, 0),\n            f = {\n          low: r + (a ? 0 : f),\n          middle: r + f / 2,\n          high: r + (a ? f : 0)\n        }[e.align],\n            b = (a ? c + this.height : b) + (a ? 1 : -1) * (h ? -1 : 1) * this.axisTitleMargin + [-t, t, w.f, -t][this.side];\n        return {\n          x: a ? f + g : b + (h ? this.width : 0) + d + g,\n          y: a ? b + m - (h ? this.height : 0) + d : f + m\n        };\n      },\n      renderMinorTick: function renderMinorTick(a) {\n        var b = this.chart.hasRendered && w(this.oldMin),\n            c = this.minorTicks;\n        c[a] || (c[a] = new L(this, a, \"minor\"));\n        b && c[a].isNew && c[a].render(null, !0);\n        c[a].render(null, !1, 1);\n      },\n      renderTick: function renderTick(a, b) {\n        var c = this.isLinked,\n            f = this.ticks,\n            e = this.chart.hasRendered && w(this.oldMin);\n        if (!c || a >= this.min && a <= this.max) f[a] || (f[a] = new L(this, a)), e && f[a].isNew && f[a].render(b, !0, -1), f[a].render(b);\n      },\n      render: function render() {\n        var b = this,\n            c = b.chart,\n            f = b.options,\n            e = b.isLog,\n            r = b.isLinked,\n            d = b.tickPositions,\n            g = b.axisTitle,\n            t = b.ticks,\n            m = b.minorTicks,\n            p = b.alternateBands,\n            I = f.stackLabels,\n            k = f.alternateGridColor,\n            G = b.tickmarkOffset,\n            q = b.axisLine,\n            n = b.showAxis,\n            J = C(c.renderer.globalAnimation),\n            F,\n            K;\n        b.labelEdge.length = 0;\n        b.overlap = !1;\n        y([t, m, p], function (a) {\n          A(a, function (a) {\n            a.isActive = !1;\n          });\n        });\n        if (b.hasData() || r) b.minorTickInterval && !b.categories && y(b.getMinorTickPositions(), function (a) {\n          b.renderMinorTick(a);\n        }), d.length && (y(d, function (a, c) {\n          b.renderTick(a, c);\n        }), G && (0 === b.min || b.single) && (t[-1] || (t[-1] = new L(b, -1, null, !0)), t[-1].render(-1))), k && y(d, function (f, l) {\n          K = void 0 !== d[l + 1] ? d[l + 1] + G : b.max - G;\n          0 === l % 2 && f < b.max && K <= b.max + (c.polar ? -G : G) && (p[f] || (p[f] = new a.PlotLineOrBand(b)), F = f + G, p[f].options = {\n            from: e ? b.lin2log(F) : F,\n            to: e ? b.lin2log(K) : K,\n            color: k\n          }, p[f].render(), p[f].isActive = !0);\n        }), b._addedPlotLB || (y((f.plotLines || []).concat(f.plotBands || []), function (a) {\n          b.addPlotBandOrLine(a);\n        }), b._addedPlotLB = !0);\n        y([t, m, p], function (a) {\n          var b,\n              f = [],\n              e = J.duration;\n          A(a, function (a, b) {\n            a.isActive || (a.render(b, !1, 0), a.isActive = !1, f.push(b));\n          });\n          E(function () {\n            for (b = f.length; b--;) {\n              a[f[b]] && !a[f[b]].isActive && (a[f[b]].destroy(), delete a[f[b]]);\n            }\n          }, a !== p && c.hasRendered && e ? e : 0);\n        });\n        q && (q[q.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(q.strokeWidth())\n        }), q.isPlaced = !0, q[n ? \"show\" : \"hide\"](!0));\n        g && n && (f = b.getTitlePosition(), w(f.y) ? (g[g.isNew ? \"attr\" : \"animate\"](f), g.isNew = !1) : (g.attr(\"y\", -9999), g.isNew = !0));\n        I && I.enabled && b.renderStackTotals();\n        b.isDirty = !1;\n        h(this, \"afterRender\");\n      },\n      redraw: function redraw() {\n        this.visible && (this.render(), y(this.plotLinesAndBands, function (a) {\n          a.render();\n        }));\n        y(this.series, function (a) {\n          a.isDirty = !0;\n        });\n      },\n      keepProps: \"extKey hcEvents names series userMax userMin\".split(\" \"),\n      destroy: function destroy(a) {\n        var b = this,\n            c = b.stacks,\n            e = b.plotLinesAndBands,\n            l;\n        h(this, \"destroy\", {\n          keepEvents: a\n        });\n        a || r(b);\n        A(c, function (a, b) {\n          p(a);\n          c[b] = null;\n        });\n        y([b.ticks, b.minorTicks, b.alternateBands], function (a) {\n          p(a);\n        });\n        if (e) for (a = e.length; a--;) {\n          e[a].destroy();\n        }\n        y(\"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \"), function (a) {\n          b[a] && (b[a] = b[a].destroy());\n        });\n\n        for (l in b.plotLinesAndBandsGroups) {\n          b.plotLinesAndBandsGroups[l] = b.plotLinesAndBandsGroups[l].destroy();\n        }\n\n        A(b, function (a, c) {\n          -1 === f(c, b.keepProps) && delete b[c];\n        });\n      },\n      drawCrosshair: function drawCrosshair(a, b) {\n        var c,\n            f = this.crosshair,\n            e = F(f.snap, !0),\n            l,\n            r = this.cross;\n        h(this, \"drawCrosshair\", {\n          e: a,\n          point: b\n        });\n        a || (a = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (v(b) || !e)) {\n          e ? v(b) && (l = F(b.crosshairPos, this.isXAxis ? b.plotX : this.len - b.plotY)) : l = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);\n          v(l) && (c = this.getPlotLinePath(b && (this.isXAxis ? b.x : F(b.stackY, b.y)), null, null, null, l) || null);\n\n          if (!v(c)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          e = this.categories && !this.isRadial;\n          r || (this.cross = r = this.chart.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (e ? \"category \" : \"thin \") + f.className).attr({\n            zIndex: F(f.zIndex, 2)\n          }).add(), r.attr({\n            stroke: f.color || (e ? d(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": F(f.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), f.dashStyle && r.attr({\n            dashstyle: f.dashStyle\n          }));\n          r.show().attr({\n            d: c\n          });\n          e && !f.width && r.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = a;\n        } else this.hideCrosshair();\n\n        h(this, \"afterDrawCrosshair\", {\n          e: a,\n          point: b\n        });\n      },\n      hideCrosshair: function hideCrosshair() {\n        this.cross && this.cross.hide();\n      }\n    });\n    return a.Axis = J;\n  }(M);\n\n  (function (a) {\n    var B = a.Axis,\n        C = a.getMagnitude,\n        D = a.map,\n        n = a.normalizeTickInterval,\n        d = a.pick;\n\n    B.prototype.getLogTickPositions = function (a, u, v, q) {\n      var p = this.options,\n          k = this.len,\n          g = [];\n      q || (this._minorAutoInterval = null);\n      if (.5 <= a) a = Math.round(a), g = this.getLinearTickPositions(a, u, v);else if (.08 <= a) for (var k = Math.floor(u), h, m, b, c, f, p = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; k < v + 1 && !f; k++) {\n        for (m = p.length, h = 0; h < m && !f; h++) {\n          b = this.log2lin(this.lin2log(k) * p[h]), b > u && (!q || c <= v) && void 0 !== c && g.push(c), c > v && (f = !0), c = b;\n        }\n      } else u = this.lin2log(u), v = this.lin2log(v), a = q ? this.getMinorTickInterval() : p.tickInterval, a = d(\"auto\" === a ? null : a, this._minorAutoInterval, p.tickPixelInterval / (q ? 5 : 1) * (v - u) / ((q ? k / this.tickPositions.length : k) || 1)), a = n(a, null, C(a)), g = D(this.getLinearTickPositions(a, u, v), this.log2lin), q || (this._minorAutoInterval = a / 5);\n      q || (this.tickInterval = a);\n      return g;\n    };\n\n    B.prototype.log2lin = function (a) {\n      return Math.log(a) / Math.LN10;\n    };\n\n    B.prototype.lin2log = function (a) {\n      return Math.pow(10, a);\n    };\n  })(M);\n\n  (function (a, B) {\n    var C = a.arrayMax,\n        D = a.arrayMin,\n        n = a.defined,\n        d = a.destroyObjectProperties,\n        k = a.each,\n        u = a.erase,\n        v = a.merge,\n        q = a.pick;\n\n    a.PlotLineOrBand = function (a, d) {\n      this.axis = a;\n      d && (this.options = d, this.id = d.id);\n    };\n\n    a.PlotLineOrBand.prototype = {\n      render: function render() {\n        a.fireEvent(this, \"render\");\n        var d = this,\n            k = d.axis,\n            g = k.horiz,\n            h = d.options,\n            m = h.label,\n            b = d.label,\n            c = h.to,\n            f = h.from,\n            e = h.value,\n            w = n(f) && n(c),\n            G = n(e),\n            t = d.svgElem,\n            K = !t,\n            A = [],\n            F = h.color,\n            r = q(h.zIndex, 0),\n            I = h.events,\n            A = {\n          \"class\": \"highcharts-plot-\" + (w ? \"band \" : \"line \") + (h.className || \"\")\n        },\n            E = {},\n            L = k.chart.renderer,\n            J = w ? \"bands\" : \"lines\";\n        k.isLog && (f = k.log2lin(f), c = k.log2lin(c), e = k.log2lin(e));\n        G ? (A.stroke = F, A[\"stroke-width\"] = h.width, h.dashStyle && (A.dashstyle = h.dashStyle)) : w && (F && (A.fill = F), h.borderWidth && (A.stroke = h.borderColor, A[\"stroke-width\"] = h.borderWidth));\n        E.zIndex = r;\n        J += \"-\" + r;\n        (F = k.plotLinesAndBandsGroups[J]) || (k.plotLinesAndBandsGroups[J] = F = L.g(\"plot-\" + J).attr(E).add());\n        K && (d.svgElem = t = L.path().attr(A).add(F));\n        if (G) A = k.getPlotLinePath(e, t.strokeWidth());else if (w) A = k.getPlotBandPath(f, c, h);else return;\n        K && A && A.length ? (t.attr({\n          d: A\n        }), I && a.objectEach(I, function (a, b) {\n          t.on(b, function (a) {\n            I[b].apply(d, [a]);\n          });\n        })) : t && (A ? (t.show(), t.animate({\n          d: A\n        })) : (t.hide(), b && (d.label = b = b.destroy())));\n        m && n(m.text) && A && A.length && 0 < k.width && 0 < k.height && !A.isFlat ? (m = v({\n          align: g && w && \"center\",\n          x: g ? !w && 4 : 10,\n          verticalAlign: !g && w && \"middle\",\n          y: g ? w ? 16 : 10 : w ? 6 : -4,\n          rotation: g && !w && 90\n        }, m), this.renderLabel(m, A, w, r)) : b && b.hide();\n        return d;\n      },\n      renderLabel: function renderLabel(a, d, g, h) {\n        var m = this.label,\n            b = this.axis.chart.renderer;\n        m || (m = {\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (g ? \"band\" : \"line\") + \"-label \" + (a.className || \"\")\n        }, m.zIndex = h, this.label = m = b.text(a.text, 0, 0, a.useHTML).attr(m).add(), m.css(a.style));\n        h = d.xBounds || [d[1], d[4], g ? d[6] : d[1]];\n        d = d.yBounds || [d[2], d[5], g ? d[7] : d[2]];\n        g = D(h);\n        b = D(d);\n        m.align(a, !1, {\n          x: g,\n          y: b,\n          width: C(h) - g,\n          height: C(d) - b\n        });\n        m.show();\n      },\n      destroy: function destroy() {\n        u(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        d(this);\n      }\n    };\n    a.extend(B.prototype, {\n      getPlotBandPath: function getPlotBandPath(a, d) {\n        var g = this.getPlotLinePath(d, null, null, !0),\n            h = this.getPlotLinePath(a, null, null, !0),\n            m = [],\n            b = this.horiz,\n            c = 1,\n            f;\n        a = a < this.min && d < this.min || a > this.max && d > this.max;\n        if (h && g) for (a && (f = h.toString() === g.toString(), c = 0), a = 0; a < h.length; a += 6) {\n          b && g[a + 1] === h[a + 1] ? (g[a + 1] += c, g[a + 4] += c) : b || g[a + 2] !== h[a + 2] || (g[a + 2] += c, g[a + 5] += c), m.push(\"M\", h[a + 1], h[a + 2], \"L\", h[a + 4], h[a + 5], g[a + 4], g[a + 5], g[a + 1], g[a + 2], \"z\"), m.isFlat = f;\n        }\n        return m;\n      },\n      addPlotBand: function addPlotBand(a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      },\n      addPlotLine: function addPlotLine(a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      },\n      addPlotBandOrLine: function addPlotBandOrLine(d, k) {\n        var g = new a.PlotLineOrBand(this, d).render(),\n            h = this.userOptions;\n        g && (k && (h[k] = h[k] || [], h[k].push(d)), this.plotLinesAndBands.push(g));\n        return g;\n      },\n      removePlotBandOrLine: function removePlotBandOrLine(a) {\n        for (var d = this.plotLinesAndBands, g = this.options, h = this.userOptions, m = d.length; m--;) {\n          d[m].id === a && d[m].destroy();\n        }\n\n        k([g.plotLines || [], h.plotLines || [], g.plotBands || [], h.plotBands || []], function (b) {\n          for (m = b.length; m--;) {\n            b[m].id === a && u(b, b[m]);\n          }\n        });\n      },\n      removePlotBand: function removePlotBand(a) {\n        this.removePlotBandOrLine(a);\n      },\n      removePlotLine: function removePlotLine(a) {\n        this.removePlotBandOrLine(a);\n      }\n    });\n  })(M, W);\n\n  (function (a) {\n    var B = a.doc,\n        C = a.each,\n        D = a.extend,\n        n = a.format,\n        d = a.isNumber,\n        k = a.map,\n        u = a.merge,\n        v = a.pick,\n        q = a.splat,\n        p = a.syncTimeout,\n        y = a.timeUnits;\n\n    a.Tooltip = function () {\n      this.init.apply(this, arguments);\n    };\n\n    a.Tooltip.prototype = {\n      init: function init(a, d) {\n        this.chart = a;\n        this.options = d;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = d.split && !a.inverted;\n        this.shared = d.shared || this.split;\n        this.outside = d.outside && !this.split;\n      },\n      cleanSplit: function cleanSplit(a) {\n        C(this.chart.series, function (d) {\n          var h = d && d.tt;\n          h && (!h.isActive || a ? d.tt = h.destroy() : h.isActive = !1);\n        });\n      },\n      getLabel: function getLabel() {\n        var d = this.chart.renderer,\n            h = this.options,\n            m;\n        this.label || (this.outside && (this.container = m = a.doc.createElement(\"div\"), m.className = \"highcharts-tooltip-container\", a.css(m, {\n          position: \"absolute\",\n          top: \"1px\",\n          pointerEvents: h.style && h.style.pointerEvents\n        }), a.doc.body.appendChild(m), this.renderer = d = new a.Renderer(m, 0, 0)), this.split ? this.label = d.g(\"tooltip\") : (this.label = d.label(\"\", 0, 0, h.shape || \"callout\", null, null, h.useHTML, null, \"tooltip\").attr({\n          padding: h.padding,\n          r: h.borderRadius\n        }), this.label.attr({\n          fill: h.backgroundColor,\n          \"stroke-width\": h.borderWidth\n        }).css(h.style).shadow(h.shadow)), this.outside && (this.label.attr({\n          x: this.distance,\n          y: this.distance\n        }), this.label.xSetter = function (a) {\n          m.style.left = a + \"px\";\n        }, this.label.ySetter = function (a) {\n          m.style.top = a + \"px\";\n        }), this.label.attr({\n          zIndex: 8\n        }).add());\n        return this.label;\n      },\n      update: function update(a) {\n        this.destroy();\n        u(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, u(!0, this.options, a));\n      },\n      destroy: function destroy() {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), a.discardElement(this.container));\n        a.clearTimeout(this.hideTimer);\n        a.clearTimeout(this.tooltipTimeout);\n      },\n      move: function move(d, h, m, b) {\n        var c = this,\n            f = c.now,\n            e = !1 !== c.options.animation && !c.isHidden && (1 < Math.abs(d - f.x) || 1 < Math.abs(h - f.y)),\n            g = c.followPointer || 1 < c.len;\n        D(f, {\n          x: e ? (2 * f.x + d) / 3 : d,\n          y: e ? (f.y + h) / 2 : h,\n          anchorX: g ? void 0 : e ? (2 * f.anchorX + m) / 3 : m,\n          anchorY: g ? void 0 : e ? (f.anchorY + b) / 2 : b\n        });\n        c.getLabel().attr(f);\n        e && (a.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          c && c.move(d, h, m, b);\n        }, 32));\n      },\n      hide: function hide(d) {\n        var h = this;\n        a.clearTimeout(this.hideTimer);\n        d = v(d, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = p(function () {\n          h.getLabel()[d ? \"fadeOut\" : \"hide\"]();\n          h.isHidden = !0;\n        }, d));\n      },\n      getAnchor: function getAnchor(a, d) {\n        var h = this.chart,\n            b = h.pointer,\n            c = h.inverted,\n            f = h.plotTop,\n            e = h.plotLeft,\n            g = 0,\n            p = 0,\n            t,\n            n;\n        a = q(a);\n        this.followPointer && d ? (void 0 === d.chartX && (d = b.normalize(d)), a = [d.chartX - h.plotLeft, d.chartY - f]) : a[0].tooltipPos ? a = a[0].tooltipPos : (C(a, function (a) {\n          t = a.series.yAxis;\n          n = a.series.xAxis;\n          g += a.plotX + (!c && n ? n.left - e : 0);\n          p += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!c && t ? t.top - f : 0);\n        }), g /= a.length, p /= a.length, a = [c ? h.plotWidth - p : g, this.shared && !c && 1 < a.length && d ? d.chartY - f : c ? h.plotHeight - g : p]);\n        return k(a, Math.round);\n      },\n      getPosition: function getPosition(a, d, m) {\n        var b = this.chart,\n            c = this.distance,\n            f = {},\n            e = b.inverted && m.h || 0,\n            h,\n            g = this.outside,\n            t = g ? B.documentElement.clientWidth - 2 * c : b.chartWidth,\n            p = g ? Math.max(B.body.scrollHeight, B.documentElement.scrollHeight, B.body.offsetHeight, B.documentElement.offsetHeight, B.documentElement.clientHeight) : b.chartHeight,\n            A = b.pointer.chartPosition,\n            k = [\"y\", p, d, (g ? A.top - c : 0) + m.plotY + b.plotTop, g ? 0 : b.plotTop, g ? p : b.plotTop + b.plotHeight],\n            r = [\"x\", t, a, (g ? A.left - c : 0) + m.plotX + b.plotLeft, g ? 0 : b.plotLeft, g ? t : b.plotLeft + b.plotWidth],\n            I = !this.followPointer && v(m.ttBelow, !b.inverted === !!m.negative),\n            E = function E(a, b, l, r, d, h) {\n          var t = l < r - c,\n              g = r + c + l < b,\n              m = r - c - l;\n          r += c;\n          if (I && g) f[a] = r;else if (!I && t) f[a] = m;else if (t) f[a] = Math.min(h - l, 0 > m - e ? m : m - e);else if (g) f[a] = Math.max(d, r + e + l > b ? r : r + e);else return !1;\n        },\n            q = function q(a, b, e, l) {\n          var r;\n          l < c || l > b - c ? r = !1 : f[a] = l < e / 2 ? 1 : l > b - e / 2 ? b - e - 2 : l - e / 2;\n          return r;\n        },\n            n = function n(a) {\n          var b = k;\n          k = r;\n          r = b;\n          h = a;\n        },\n            l = function l() {\n          !1 !== E.apply(0, k) ? !1 !== q.apply(0, r) || h || (n(!0), l()) : h ? f.x = f.y = 0 : (n(!0), l());\n        };\n\n        (b.inverted || 1 < this.len) && n();\n        l();\n        return f;\n      },\n      defaultFormatter: function defaultFormatter(a) {\n        var d = this.points || q(this),\n            g;\n        g = [a.tooltipFooterHeaderFormatter(d[0])];\n        g = g.concat(a.bodyFormatter(d));\n        g.push(a.tooltipFooterHeaderFormatter(d[0], !0));\n        return g;\n      },\n      refresh: function refresh(d, h) {\n        var g,\n            b = this.options,\n            c,\n            f = d,\n            e,\n            w = {},\n            p = [];\n        g = b.formatter || this.defaultFormatter;\n        var w = this.shared,\n            t;\n        b.enabled && (a.clearTimeout(this.hideTimer), this.followPointer = q(f)[0].series.tooltipOptions.followPointer, e = this.getAnchor(f, h), h = e[0], c = e[1], !w || f.series && f.series.noSharedTooltip ? w = f.getLabelConfig() : (C(f, function (a) {\n          a.setState(\"hover\");\n          p.push(a.getLabelConfig());\n        }), w = {\n          x: f[0].category,\n          y: f[0].y\n        }, w.points = p, f = f[0]), this.len = p.length, w = g.call(w, this), t = f.series, this.distance = v(t.tooltipOptions.distance, 16), !1 === w ? this.hide() : (g = this.getLabel(), this.isHidden && g.attr({\n          opacity: 1\n        }).show(), this.split ? this.renderSplit(w, q(d)) : (b.style.width || g.css({\n          width: this.chart.spacingBox.width\n        }), g.attr({\n          text: w && w.join ? w.join(\"\") : w\n        }), g.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + v(f.colorIndex, t.colorIndex)), g.attr({\n          stroke: b.borderColor || f.color || t.color || \"#666666\"\n        }), this.updatePosition({\n          plotX: h,\n          plotY: c,\n          negative: f.negative,\n          ttBelow: f.ttBelow,\n          h: e[2] || 0\n        })), this.isHidden = !1));\n      },\n      renderSplit: function renderSplit(d, h) {\n        var g = this,\n            b = [],\n            c = this.chart,\n            f = c.renderer,\n            e = !0,\n            w = this.options,\n            p = 0,\n            t,\n            k = this.getLabel(),\n            A = c.plotTop;\n        a.isString(d) && (d = [!1, d]);\n        C(d.slice(0, h.length + 1), function (a, r) {\n          if (!1 !== a) {\n            r = h[r - 1] || {\n              isHeader: !0,\n              plotX: h[0].plotX\n            };\n            var d = r.series || g,\n                m = d.tt,\n                q = r.series || {},\n                n = \"highcharts-color-\" + v(r.colorIndex, q.colorIndex, \"none\");\n            m || (d.tt = m = f.label(null, null, null, \"callout\", null, null, w.useHTML).addClass(\"highcharts-tooltip-box \" + n + (r.isHeader ? \" highcharts-tooltip-header\" : \"\")).attr({\n              padding: w.padding,\n              r: w.borderRadius,\n              fill: w.backgroundColor,\n              stroke: w.borderColor || r.color || q.color || \"#333333\",\n              \"stroke-width\": w.borderWidth\n            }).add(k));\n            m.isActive = !0;\n            m.attr({\n              text: a\n            });\n            m.css(w.style).shadow(w.shadow);\n            a = m.getBBox();\n            q = a.width + m.strokeWidth();\n            r.isHeader ? (p = a.height, c.xAxis[0].opposite && (t = !0, A -= p), q = Math.max(0, Math.min(r.plotX + c.plotLeft - q / 2, c.chartWidth + (c.scrollablePixels ? c.scrollablePixels - c.marginRight : 0) - q))) : q = r.plotX + c.plotLeft - v(w.distance, 16) - q;\n            0 > q && (e = !1);\n            a = (r.series && r.series.yAxis && r.series.yAxis.pos) + (r.plotY || 0);\n            a -= A;\n            r.isHeader && (a = t ? -p : c.plotHeight + p);\n            b.push({\n              target: a,\n              rank: r.isHeader ? 1 : 0,\n              size: d.tt.getBBox().height + 1,\n              point: r,\n              x: q,\n              tt: m\n            });\n          }\n        });\n        this.cleanSplit();\n        a.distribute(b, c.plotHeight + p);\n        C(b, function (a) {\n          var b = a.point,\n              f = b.series;\n          a.tt.attr({\n            visibility: void 0 === a.pos ? \"hidden\" : \"inherit\",\n            x: e || b.isHeader ? a.x : b.plotX + c.plotLeft + v(w.distance, 16),\n            y: a.pos + A,\n            anchorX: b.isHeader ? b.plotX + c.plotLeft : b.plotX + f.xAxis.pos,\n            anchorY: b.isHeader ? c.plotTop + c.plotHeight / 2 : b.plotY + f.yAxis.pos\n          });\n        });\n      },\n      updatePosition: function updatePosition(a) {\n        var d = this.chart,\n            g = this.getLabel(),\n            b = (this.options.positioner || this.getPosition).call(this, g.width, g.height, a),\n            c = a.plotX + d.plotLeft;\n        a = a.plotY + d.plotTop;\n        var f;\n        this.outside && (f = (this.options.borderWidth || 0) + 2 * this.distance, this.renderer.setSize(g.width + f, g.height + f, !1), c += d.pointer.chartPosition.left - b.x, a += d.pointer.chartPosition.top - b.y);\n        this.move(Math.round(b.x), Math.round(b.y || 0), c, a);\n      },\n      getDateFormat: function getDateFormat(a, d, m, b) {\n        var c = this.chart.time,\n            f = c.dateFormat(\"%m-%d %H:%M:%S.%L\", d),\n            e,\n            h,\n            g = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            t = \"millisecond\";\n\n        for (h in y) {\n          if (a === y.week && +c.dateFormat(\"%w\", d) === m && \"00:00:00.000\" === f.substr(6)) {\n            h = \"week\";\n            break;\n          }\n\n          if (y[h] > a) {\n            h = t;\n            break;\n          }\n\n          if (g[h] && f.substr(g[h]) !== \"01-01 00:00:00.000\".substr(g[h])) break;\n          \"week\" !== h && (t = h);\n        }\n\n        h && (e = c.resolveDTLFormat(b[h]).main);\n        return e;\n      },\n      getXDateFormat: function getXDateFormat(a, d, m) {\n        d = d.dateTimeLabelFormats;\n        var b = m && m.closestPointRange;\n        return (b ? this.getDateFormat(b, a.x, m.options.startOfWeek, d) : d.day) || d.year;\n      },\n      tooltipFooterHeaderFormatter: function tooltipFooterHeaderFormatter(a, h) {\n        h = h ? \"footer\" : \"header\";\n        var g = a.series,\n            b = g.tooltipOptions,\n            c = b.xDateFormat,\n            f = g.xAxis,\n            e = f && \"datetime\" === f.options.type && d(a.key),\n            w = b[h + \"Format\"];\n        e && !c && (c = this.getXDateFormat(a, b, f));\n        e && c && C(a.point && a.point.tooltipDateKeys || [\"key\"], function (a) {\n          w = w.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + c + \"}\");\n        });\n        return n(w, {\n          point: a,\n          series: g\n        }, this.chart.time);\n      },\n      bodyFormatter: function bodyFormatter(a) {\n        return k(a, function (a) {\n          var d = a.series.tooltipOptions;\n          return (d[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, d[(a.point.formatPrefix || \"point\") + \"Format\"]);\n        });\n      }\n    };\n  })(M);\n\n  (function (a) {\n    var B = a.addEvent,\n        C = a.attr,\n        D = a.charts,\n        n = a.color,\n        d = a.css,\n        k = a.defined,\n        u = a.each,\n        v = a.extend,\n        q = a.find,\n        p = a.fireEvent,\n        y = a.isNumber,\n        g = a.isObject,\n        h = a.offset,\n        m = a.pick,\n        b = a.splat,\n        c = a.Tooltip;\n\n    a.Pointer = function (a, b) {\n      this.init(a, b);\n    };\n\n    a.Pointer.prototype = {\n      init: function init(a, b) {\n        this.options = b;\n        this.chart = a;\n        this.runChartClick = b.chart.events && !!b.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        c && (a.tooltip = new c(a, b.tooltip), this.followTouchMove = m(b.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      },\n      zoomOption: function zoomOption(a) {\n        var b = this.chart,\n            c = b.options.chart,\n            f = c.zoomType || \"\",\n            b = b.inverted;\n        /touch/.test(a.type) && (f = m(c.pinchType, f));\n        this.zoomX = a = /x/.test(f);\n        this.zoomY = f = /y/.test(f);\n        this.zoomHor = a && !b || f && b;\n        this.zoomVert = f && !b || a && b;\n        this.hasZoom = a || f;\n      },\n      normalize: function normalize(a, b) {\n        var c;\n        c = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;\n        b || (this.chartPosition = b = h(this.chart.container));\n        return v(a, {\n          chartX: Math.round(c.pageX - b.left),\n          chartY: Math.round(c.pageY - b.top)\n        });\n      },\n      getCoordinates: function getCoordinates(a) {\n        var b = {\n          xAxis: [],\n          yAxis: []\n        };\n        u(this.chart.axes, function (c) {\n          b[c.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: c,\n            value: c.toValue(a[c.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return b;\n      },\n      findNearestKDPoint: function findNearestKDPoint(a, b, c) {\n        var f;\n        u(a, function (a) {\n          var e = !(a.noSharedTooltip && b) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(c, e);\n          if ((e = g(a, !0)) && !(e = !g(f, !0))) var e = f.distX - a.distX,\n              d = f.dist - a.dist,\n              h = (a.series.group && a.series.group.zIndex) - (f.series.group && f.series.group.zIndex),\n              e = 0 < (0 !== e && b ? e : 0 !== d ? d : 0 !== h ? h : f.series.index > a.series.index ? -1 : 1);\n          e && (f = a);\n        });\n        return f;\n      },\n      getPointFromEvent: function getPointFromEvent(a) {\n        a = a.target;\n\n        for (var b; a && !b;) {\n          b = a.point, a = a.parentNode;\n        }\n\n        return b;\n      },\n      getChartCoordinatesFromPoint: function getChartCoordinatesFromPoint(a, b) {\n        var c = a.series,\n            f = c.xAxis,\n            c = c.yAxis,\n            e = m(a.clientX, a.plotX),\n            d = a.shapeArgs;\n        if (f && c) return b ? {\n          chartX: f.len + f.pos - e,\n          chartY: c.len + c.pos - a.plotY\n        } : {\n          chartX: e + f.pos,\n          chartY: a.plotY + c.pos\n        };\n        if (d && d.x && d.y) return {\n          chartX: d.x,\n          chartY: d.y\n        };\n      },\n      getHoverData: function getHoverData(b, c, d, h, t, p, k) {\n        var f,\n            e = [],\n            w = k && k.isBoosting;\n        h = !(!h || !b);\n        k = c && !c.stickyTracking ? [c] : a.grep(d, function (a) {\n          return a.visible && !(!t && a.directTouch) && m(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        c = (f = h ? b : this.findNearestKDPoint(k, t, p)) && f.series;\n        f && (t && !c.noSharedTooltip ? (k = a.grep(d, function (a) {\n          return a.visible && !(!t && a.directTouch) && m(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), u(k, function (a) {\n          var b = q(a.points, function (a) {\n            return a.x === f.x && !a.isNull;\n          });\n          g(b) && (w && (b = a.getPoint(b)), e.push(b));\n        })) : e.push(f));\n        return {\n          hoverPoint: f,\n          hoverSeries: c,\n          hoverPoints: e\n        };\n      },\n      runPointActions: function runPointActions(b, c) {\n        var f = this.chart,\n            e = f.tooltip && f.tooltip.options.enabled ? f.tooltip : void 0,\n            d = e ? e.shared : !1,\n            h = c || f.hoverPoint,\n            g = h && h.series || f.hoverSeries,\n            g = this.getHoverData(h, g, f.series, \"touchmove\" !== b.type && (!!c || g && g.directTouch && this.isDirectTouch), d, b, {\n          isBoosting: f.isBoosting\n        }),\n            p,\n            h = g.hoverPoint;\n        p = g.hoverPoints;\n        c = (g = g.hoverSeries) && g.tooltipOptions.followPointer;\n        d = d && g && !g.noSharedTooltip;\n\n        if (h && (h !== f.hoverPoint || e && e.isHidden)) {\n          u(f.hoverPoints || [], function (b) {\n            -1 === a.inArray(b, p) && b.setState();\n          });\n          u(p || [], function (a) {\n            a.setState(\"hover\");\n          });\n          if (f.hoverSeries !== g) g.onMouseOver();\n          f.hoverPoint && f.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!h.series) return;\n          h.firePointEvent(\"mouseOver\");\n          f.hoverPoints = p;\n          f.hoverPoint = h;\n          e && e.refresh(d ? p : h, b);\n        } else c && e && !e.isHidden && (h = e.getAnchor([{}], b), e.updatePosition({\n          plotX: h[0],\n          plotY: h[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = B(f.container.ownerDocument, \"mousemove\", function (b) {\n          var c = D[a.hoverChartIndex];\n          if (c) c.pointer.onDocumentMouseMove(b);\n        }));\n        u(f.axes, function (c) {\n          var f = m(c.crosshair.snap, !0),\n              e = f ? a.find(p, function (a) {\n            return a.series[c.coll] === c;\n          }) : void 0;\n          e || !f ? c.drawCrosshair(b, e) : c.hideCrosshair();\n        });\n      },\n      reset: function reset(a, c) {\n        var f = this.chart,\n            e = f.hoverSeries,\n            d = f.hoverPoint,\n            h = f.hoverPoints,\n            g = f.tooltip,\n            m = g && g.shared ? h : d;\n        a && m && u(b(m), function (b) {\n          b.series.isCartesian && void 0 === b.plotX && (a = !1);\n        });\n        if (a) g && m && (g.refresh(m), g.shared && h ? u(h, function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : d && (d.setState(d.state, !0), u(f.axes, function (a) {\n          a.crosshair && a.drawCrosshair(null, d);\n        })));else {\n          if (d) d.onMouseOut();\n          h && u(h, function (a) {\n            a.setState();\n          });\n          if (e) e.onMouseOut();\n          g && g.hide(c);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          u(f.axes, function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = f.hoverPoints = f.hoverPoint = null;\n        }\n      },\n      scaleGroups: function scaleGroups(a, b) {\n        var c = this.chart,\n            f;\n        u(c.series, function (e) {\n          f = a || e.getPlotBox();\n          e.xAxis && e.xAxis.zoomEnabled && e.group && (e.group.attr(f), e.markerGroup && (e.markerGroup.attr(f), e.markerGroup.clip(b ? c.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(f));\n        });\n        c.clipRect.attr(b || c.clipBox);\n      },\n      dragStart: function dragStart(a) {\n        var b = this.chart;\n        b.mouseIsDown = a.type;\n        b.cancelClick = !1;\n        b.mouseDownX = this.mouseDownX = a.chartX;\n        b.mouseDownY = this.mouseDownY = a.chartY;\n      },\n      drag: function drag(a) {\n        var b = this.chart,\n            c = b.options.chart,\n            f = a.chartX,\n            d = a.chartY,\n            h = this.zoomHor,\n            g = this.zoomVert,\n            m = b.plotLeft,\n            r = b.plotTop,\n            p = b.plotWidth,\n            E = b.plotHeight,\n            k,\n            q = this.selectionMarker,\n            l = this.mouseDownX,\n            x = this.mouseDownY,\n            u = c.panKey && a[c.panKey + \"Key\"];\n        q && q.touch || (f < m ? f = m : f > m + p && (f = m + p), d < r ? d = r : d > r + E && (d = r + E), this.hasDragged = Math.sqrt(Math.pow(l - f, 2) + Math.pow(x - d, 2)), 10 < this.hasDragged && (k = b.isInsidePlot(l - m, x - r), b.hasCartesianSeries && (this.zoomX || this.zoomY) && k && !u && !q && (this.selectionMarker = q = b.renderer.rect(m, r, h ? 1 : p, g ? 1 : E, 0).attr({\n          fill: c.selectionMarkerFill || n(\"#335cad\").setOpacity(.25).get(),\n          \"class\": \"highcharts-selection-marker\",\n          zIndex: 7\n        }).add()), q && h && (f -= l, q.attr({\n          width: Math.abs(f),\n          x: (0 < f ? 0 : f) + l\n        })), q && g && (f = d - x, q.attr({\n          height: Math.abs(f),\n          y: (0 < f ? 0 : f) + x\n        })), k && !q && c.panning && b.pan(a, c.panning)));\n      },\n      drop: function drop(a) {\n        var b = this,\n            c = this.chart,\n            f = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var h = {\n            originalEvent: a,\n            xAxis: [],\n            yAxis: []\n          },\n              g = this.selectionMarker,\n              m = g.attr ? g.attr(\"x\") : g.x,\n              q = g.attr ? g.attr(\"y\") : g.y,\n              r = g.attr ? g.attr(\"width\") : g.width,\n              I = g.attr ? g.attr(\"height\") : g.height,\n              E;\n          if (this.hasDragged || f) u(c.axes, function (c) {\n            if (c.zoomEnabled && k(c.min) && (f || b[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[c.coll]])) {\n              var e = c.horiz,\n                  l = \"touchend\" === a.type ? c.minPixelPadding : 0,\n                  d = c.toValue((e ? m : q) + l),\n                  e = c.toValue((e ? m + r : q + I) - l);\n              h[c.coll].push({\n                axis: c,\n                min: Math.min(d, e),\n                max: Math.max(d, e)\n              });\n              E = !0;\n            }\n          }), E && p(c, \"selection\", h, function (a) {\n            c.zoom(v(a, f ? {\n              animation: !1\n            } : null));\n          });\n          y(c.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          f && this.scaleGroups();\n        }\n\n        c && y(c.index) && (d(c.container, {\n          cursor: c._cursor\n        }), c.cancelClick = 10 < this.hasDragged, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      },\n      onContainerMouseDown: function onContainerMouseDown(a) {\n        a = this.normalize(a);\n        2 !== a.button && (this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a));\n      },\n      onDocumentMouseUp: function onDocumentMouseUp(b) {\n        D[a.hoverChartIndex] && D[a.hoverChartIndex].pointer.drop(b);\n      },\n      onDocumentMouseMove: function onDocumentMouseMove(a) {\n        var b = this.chart,\n            c = this.chartPosition;\n        a = this.normalize(a, c);\n        !c || this.inClass(a.target, \"highcharts-tracker\") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();\n      },\n      onContainerMouseLeave: function onContainerMouseLeave(b) {\n        var c = D[a.hoverChartIndex];\n        c && (b.relatedTarget || b.toElement) && (c.pointer.reset(), c.pointer.chartPosition = null);\n      },\n      onContainerMouseMove: function onContainerMouseMove(b) {\n        var c = this.chart;\n        k(a.hoverChartIndex) && D[a.hoverChartIndex] && D[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = c.index);\n        b = this.normalize(b);\n        b.returnValue = !1;\n        \"mousedown\" === c.mouseIsDown && this.drag(b);\n        !this.inClass(b.target, \"highcharts-tracker\") && !c.isInsidePlot(b.chartX - c.plotLeft, b.chartY - c.plotTop) || c.openMenu || this.runPointActions(b);\n      },\n      inClass: function inClass(a, b) {\n        for (var c; a;) {\n          if (c = C(a, \"class\")) {\n            if (-1 !== c.indexOf(b)) return !0;\n            if (-1 !== c.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          a = a.parentNode;\n        }\n      },\n      onTrackerMouseOut: function onTrackerMouseOut(a) {\n        var b = this.chart.hoverSeries;\n        a = a.relatedTarget || a.toElement;\n        this.isDirectTouch = !1;\n        if (!(!b || !a || b.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + b.index) && this.inClass(a, \"highcharts-tracker\"))) b.onMouseOut();\n      },\n      onContainerClick: function onContainerClick(a) {\n        var b = this.chart,\n            c = b.hoverPoint,\n            f = b.plotLeft,\n            d = b.plotTop;\n        a = this.normalize(a);\n        b.cancelClick || (c && this.inClass(a.target, \"highcharts-tracker\") ? (p(c.series, \"click\", v(a, {\n          point: c\n        })), b.hoverPoint && c.firePointEvent(\"click\", a)) : (v(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - f, a.chartY - d) && p(b, \"click\", a)));\n      },\n      setDOMEvents: function setDOMEvents() {\n        var b = this,\n            c = b.chart.container,\n            d = c.ownerDocument;\n\n        c.onmousedown = function (a) {\n          b.onContainerMouseDown(a);\n        };\n\n        c.onmousemove = function (a) {\n          b.onContainerMouseMove(a);\n        };\n\n        c.onclick = function (a) {\n          b.onContainerClick(a);\n        };\n\n        this.unbindContainerMouseLeave = B(c, \"mouseleave\", b.onContainerMouseLeave);\n        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = B(d, \"mouseup\", b.onDocumentMouseUp));\n        a.hasTouch && (c.ontouchstart = function (a) {\n          b.onContainerTouchStart(a);\n        }, c.ontouchmove = function (a) {\n          b.onContainerTouchMove(a);\n        }, a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = B(d, \"touchend\", b.onDocumentTouchEnd)));\n      },\n      destroy: function destroy() {\n        var b = this;\n        b.unDocMouseMove && b.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));\n        clearInterval(b.tooltipTimeout);\n        a.objectEach(b, function (a, c) {\n          b[c] = null;\n        });\n      }\n    };\n  })(M);\n\n  (function (a) {\n    var B = a.charts,\n        C = a.each,\n        D = a.extend,\n        n = a.map,\n        d = a.noop,\n        k = a.pick;\n    D(a.Pointer.prototype, {\n      pinchTranslate: function pinchTranslate(a, d, k, p, n, g) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, d, k, p, n, g);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, d, k, p, n, g);\n      },\n      pinchTranslateDirection: function pinchTranslateDirection(a, d, k, p, n, g, h, m) {\n        var b = this.chart,\n            c = a ? \"x\" : \"y\",\n            f = a ? \"X\" : \"Y\",\n            e = \"chart\" + f,\n            w = a ? \"width\" : \"height\",\n            q = b[\"plot\" + (a ? \"Left\" : \"Top\")],\n            t,\n            u,\n            A = m || 1,\n            F = b.inverted,\n            r = b.bounds[a ? \"h\" : \"v\"],\n            I = 1 === d.length,\n            E = d[0][e],\n            L = k[0][e],\n            J = !I && d[1][e],\n            l = !I && k[1][e],\n            x;\n\n        k = function k() {\n          !I && 20 < Math.abs(E - J) && (A = m || Math.abs(L - l) / Math.abs(E - J));\n          u = (q - L) / A + E;\n          t = b[\"plot\" + (a ? \"Width\" : \"Height\")] / A;\n        };\n\n        k();\n        d = u;\n        d < r.min ? (d = r.min, x = !0) : d + t > r.max && (d = r.max - t, x = !0);\n        x ? (L -= .8 * (L - h[c][0]), I || (l -= .8 * (l - h[c][1])), k()) : h[c] = [L, l];\n        F || (g[c] = u - q, g[w] = t);\n        g = F ? 1 / A : A;\n        n[w] = t;\n        n[c] = d;\n        p[F ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + f] = A;\n        p[\"translate\" + f] = g * q + (L - g * E);\n      },\n      pinch: function pinch(a) {\n        var u = this,\n            q = u.chart,\n            p = u.pinchDown,\n            y = a.touches,\n            g = y.length,\n            h = u.lastValidTouch,\n            m = u.hasZoom,\n            b = u.selectionMarker,\n            c = {},\n            f = 1 === g && (u.inClass(a.target, \"highcharts-tracker\") && q.runTrackerClick || u.runChartClick),\n            e = {};\n        1 < g && (u.initiated = !0);\n        m && u.initiated && !f && a.preventDefault();\n        n(y, function (a) {\n          return u.normalize(a);\n        });\n        \"touchstart\" === a.type ? (C(y, function (a, b) {\n          p[b] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), h.x = [p[0].chartX, p[1] && p[1].chartX], h.y = [p[0].chartY, p[1] && p[1].chartY], C(q.axes, function (a) {\n          if (a.zoomEnabled) {\n            var b = q.bounds[a.horiz ? \"h\" : \"v\"],\n                c = a.minPixelPadding,\n                f = a.toPixels(k(a.options.min, a.dataMin)),\n                e = a.toPixels(k(a.options.max, a.dataMax)),\n                d = Math.max(f, e);\n            b.min = Math.min(a.pos, Math.min(f, e) - c);\n            b.max = Math.max(a.pos + a.len, d + c);\n          }\n        }), u.res = !0) : u.followTouchMove && 1 === g ? this.runPointActions(u.normalize(a)) : p.length && (b || (u.selectionMarker = b = D({\n          destroy: d,\n          touch: !0\n        }, q.plotBox)), u.pinchTranslate(p, y, c, b, e, h), u.hasPinched = m, u.scaleGroups(c, e), u.res && (u.res = !1, this.reset(!1, 0)));\n      },\n      touch: function touch(d, n) {\n        var q = this.chart,\n            p,\n            u;\n        if (q.index !== a.hoverChartIndex) this.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        a.hoverChartIndex = q.index;\n        1 === d.touches.length ? (d = this.normalize(d), (u = q.isInsidePlot(d.chartX - q.plotLeft, d.chartY - q.plotTop)) && !q.openMenu ? (n && this.runPointActions(d), \"touchmove\" === d.type && (n = this.pinchDown, p = n[0] ? 4 <= Math.sqrt(Math.pow(n[0].chartX - d.chartX, 2) + Math.pow(n[0].chartY - d.chartY, 2)) : !1), k(p, !0) && this.pinch(d)) : n && this.reset()) : 2 === d.touches.length && this.pinch(d);\n      },\n      onContainerTouchStart: function onContainerTouchStart(a) {\n        this.zoomOption(a);\n        this.touch(a, !0);\n      },\n      onContainerTouchMove: function onContainerTouchMove(a) {\n        this.touch(a);\n      },\n      onDocumentTouchEnd: function onDocumentTouchEnd(d) {\n        B[a.hoverChartIndex] && B[a.hoverChartIndex].pointer.drop(d);\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.addEvent,\n        C = a.charts,\n        D = a.css,\n        n = a.doc,\n        d = a.extend,\n        k = a.noop,\n        u = a.Pointer,\n        v = a.removeEvent,\n        q = a.win,\n        p = a.wrap;\n\n    if (!a.hasTouch && (q.PointerEvent || q.MSPointerEvent)) {\n      var y = {},\n          g = !!q.PointerEvent,\n          h = function h() {\n        var b = [];\n\n        b.item = function (a) {\n          return this[a];\n        };\n\n        a.objectEach(y, function (a) {\n          b.push({\n            pageX: a.pageX,\n            pageY: a.pageY,\n            target: a.target\n          });\n        });\n        return b;\n      },\n          m = function m(b, c, f, e) {\n        \"touch\" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !C[a.hoverChartIndex] || (e(b), e = C[a.hoverChartIndex].pointer, e[c]({\n          type: f,\n          target: b.currentTarget,\n          preventDefault: k,\n          touches: h()\n        }));\n      };\n\n      d(u.prototype, {\n        onContainerPointerDown: function onContainerPointerDown(a) {\n          m(a, \"onContainerTouchStart\", \"touchstart\", function (a) {\n            y[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY,\n              target: a.currentTarget\n            };\n          });\n        },\n        onContainerPointerMove: function onContainerPointerMove(a) {\n          m(a, \"onContainerTouchMove\", \"touchmove\", function (a) {\n            y[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY\n            };\n            y[a.pointerId].target || (y[a.pointerId].target = a.currentTarget);\n          });\n        },\n        onDocumentPointerUp: function onDocumentPointerUp(a) {\n          m(a, \"onDocumentTouchEnd\", \"touchend\", function (a) {\n            delete y[a.pointerId];\n          });\n        },\n        batchMSEvents: function batchMSEvents(a) {\n          a(this.chart.container, g ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n          a(this.chart.container, g ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n          a(n, g ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n        }\n      });\n      p(u.prototype, \"init\", function (a, c, f) {\n        a.call(this, c, f);\n        this.hasZoom && D(c.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      });\n      p(u.prototype, \"setDOMEvents\", function (a) {\n        a.apply(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(B);\n      });\n      p(u.prototype, \"destroy\", function (a) {\n        this.batchMSEvents(v);\n        a.call(this);\n      });\n    }\n  })(M);\n\n  (function (a) {\n    var B = a.addEvent,\n        C = a.css,\n        D = a.discardElement,\n        n = a.defined,\n        d = a.each,\n        k = a.fireEvent,\n        u = a.isFirefox,\n        v = a.marginNames,\n        q = a.merge,\n        p = a.pick,\n        y = a.setAnimation,\n        g = a.stableSort,\n        h = a.win,\n        m = a.wrap;\n\n    a.Legend = function (a, c) {\n      this.init(a, c);\n    };\n\n    a.Legend.prototype = {\n      init: function init(a, c) {\n        this.chart = a;\n        this.setOptions(c);\n        c.enabled && (this.render(), B(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = B(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      },\n      setOptions: function setOptions(a) {\n        var b = p(a.padding, 8);\n        this.options = a;\n        this.itemStyle = a.itemStyle;\n        this.itemHiddenStyle = q(this.itemStyle, a.itemHiddenStyle);\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.padding = b;\n        this.initialItemY = b - 5;\n        this.symbolWidth = p(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n      },\n      update: function update(a, c) {\n        var b = this.chart;\n        this.setOptions(q(!0, this.options, a));\n        this.destroy();\n        b.isDirtyLegend = b.isDirtyBox = !0;\n        p(c, !0) && b.redraw();\n        k(this, \"afterUpdate\");\n      },\n      colorizeItem: function colorizeItem(a, c) {\n        a.legendGroup[c ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n        var b = this.options,\n            e = a.legendItem,\n            d = a.legendLine,\n            h = a.legendSymbol,\n            g = this.itemHiddenStyle.color,\n            b = c ? b.itemStyle.color : g,\n            m = c ? a.color || g : g,\n            p = a.options && a.options.marker,\n            q = {\n          fill: m\n        };\n        e && e.css({\n          fill: b,\n          color: b\n        });\n        d && d.attr({\n          stroke: m\n        });\n        h && (p && h.isMarker && (q = a.pointAttribs(), c || (q.stroke = q.fill = g)), h.attr(q));\n        k(this, \"afterColorizeItem\", {\n          item: a,\n          visible: c\n        });\n      },\n      positionItems: function positionItems() {\n        d(this.allItems, this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      },\n      positionItem: function positionItem(a) {\n        var b = this.options,\n            f = b.symbolPadding,\n            b = !b.rtl,\n            e = a._legendItemPos,\n            d = e[0],\n            e = e[1],\n            h = a.checkbox;\n        if ((a = a.legendGroup) && a.element) a[n(a.translateY) ? \"animate\" : \"attr\"]({\n          translateX: b ? d : this.legendWidth - d - 2 * f - 4,\n          translateY: e\n        });\n        h && (h.x = d, h.y = e);\n      },\n      destroyItem: function destroyItem(a) {\n        var b = a.checkbox;\n        d([\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"], function (b) {\n          a[b] && (a[b] = a[b].destroy());\n        });\n        b && D(a.checkbox);\n      },\n      destroy: function destroy() {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        d(this.getAllItems(), function (b) {\n          d([\"legendItem\", \"legendGroup\"], a, b);\n        });\n        d(\"clipRect up down pager nav box title group\".split(\" \"), a, this);\n        this.display = null;\n      },\n      positionCheckboxes: function positionCheckboxes() {\n        var a = this.group && this.group.alignAttr,\n            c,\n            f = this.clipHeight || this.legendHeight,\n            e = this.titleHeight;\n        a && (c = a.translateY, d(this.allItems, function (b) {\n          var d = b.checkbox,\n              h;\n          d && (h = c + e + d.y + (this.scrollOffset || 0) + 3, C(d, {\n            left: a.translateX + b.checkboxOffset + d.x - 20 + \"px\",\n            top: h + \"px\",\n            display: this.proximate || h > c - 6 && h < c + f - 6 ? \"\" : \"none\"\n          }));\n        }, this));\n      },\n      renderTitle: function renderTitle() {\n        var a = this.options,\n            c = this.padding,\n            f = a.title,\n            e = 0;\n        f.text && (this.title || (this.title = this.chart.renderer.label(f.text, c - 3, c - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }).css(f.style).add(this.group)), a = this.title.getBBox(), e = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: e\n        }));\n        this.titleHeight = e;\n      },\n      setText: function setText(b) {\n        var c = this.options;\n        b.legendItem.attr({\n          text: c.labelFormat ? a.format(c.labelFormat, b, this.chart.time) : c.labelFormatter.call(b)\n        });\n      },\n      renderItem: function renderItem(a) {\n        var b = this.chart,\n            f = b.renderer,\n            e = this.options,\n            d = this.symbolWidth,\n            h = e.symbolPadding,\n            g = this.itemStyle,\n            m = this.itemHiddenStyle,\n            k = \"horizontal\" === e.layout ? p(e.itemDistance, 20) : 0,\n            n = !e.rtl,\n            r = a.legendItem,\n            I = !a.series,\n            E = !I && a.series.drawLegendSymbol ? a.series : a,\n            L = E.options,\n            L = this.createCheckboxForItem && L && L.showCheckbox,\n            k = d + h + k + (L ? 20 : 0),\n            J = e.useHTML,\n            l = a.options.className;\n        r || (a.legendGroup = f.g(\"legend-item\").addClass(\"highcharts-\" + E.type + \"-series highcharts-color-\" + a.colorIndex + (l ? \" \" + l : \"\") + (I ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = r = f.text(\"\", n ? d + h : -h, this.baseline || 0, J).css(q(a.visible ? g : m)).attr({\n          align: n ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (d = g.fontSize, this.fontMetrics = f.fontMetrics(d, r), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, r.attr(\"y\", this.baseline)), this.symbolHeight = e.symbolHeight || this.fontMetrics.f, E.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, r, J), L && this.createCheckboxForItem(a));\n        this.colorizeItem(a, a.visible);\n        g.width || r.css({\n          width: (e.itemWidth || e.width || b.spacingBox.width) - k\n        });\n        this.setText(a);\n        b = r.getBBox();\n        a.itemWidth = a.checkboxOffset = e.itemWidth || a.legendItemWidth || b.width + k;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || b.height || this.symbolHeight);\n      },\n      layoutItem: function layoutItem(a) {\n        var b = this.options,\n            f = this.padding,\n            e = \"horizontal\" === b.layout,\n            d = a.itemHeight,\n            h = b.itemMarginBottom || 0,\n            g = this.itemMarginTop,\n            m = e ? p(b.itemDistance, 20) : 0,\n            k = b.width,\n            q = k || this.chart.spacingBox.width - 2 * f - b.x,\n            b = b.alignColumns && this.totalItemWidth > q ? this.maxItemWidth : a.itemWidth;\n        e && this.itemX - f + b > q && (this.itemX = f, this.itemY += g + this.lastLineHeight + h, this.lastLineHeight = 0);\n        this.lastItemY = g + this.itemY + h;\n        this.lastLineHeight = Math.max(d, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        e ? this.itemX += b : (this.itemY += g + d + h, this.lastLineHeight = d);\n        this.offsetWidth = k || Math.max((e ? this.itemX - f - (a.checkbox ? 0 : m) : b) + f, this.offsetWidth);\n      },\n      getAllItems: function getAllItems() {\n        var a = [];\n        d(this.chart.series, function (b) {\n          var c = b && b.options;\n          b && p(c.showInLegend, n(c.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || (\"point\" === c.legendType ? b.data : b)));\n        });\n        k(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      },\n      getAlignment: function getAlignment() {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      },\n      adjustMargins: function adjustMargins(a, c) {\n        var b = this.chart,\n            e = this.options,\n            h = this.getAlignment();\n        h && d([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function (f, d) {\n          f.test(h) && !n(a[d]) && (b[v[d]] = Math.max(b[v[d]], b.legend[(d + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][d] * e[d % 2 ? \"x\" : \"y\"] + p(e.margin, 12) + c[d] + (0 === d && void 0 !== b.options.title.margin ? b.titleOffset + b.options.title.margin : 0)));\n        });\n      },\n      proximatePositions: function proximatePositions() {\n        var b = this.chart,\n            c = [],\n            f = \"left\" === this.options.align;\n        d(this.allItems, function (d) {\n          var e, h;\n          e = f;\n          d.xAxis && d.points && (d.xAxis.options.reversed && (e = !e), e = a.find(e ? d.points : d.points.slice(0).reverse(), function (b) {\n            return a.isNumber(b.plotY);\n          }), h = d.legendGroup.getBBox().height, c.push({\n            target: d.visible ? (e ? e.plotY : d.xAxis.height) - .3 * h : b.plotHeight,\n            size: h,\n            item: d\n          }));\n        }, this);\n        a.distribute(c, b.plotHeight);\n        d(c, function (a) {\n          a.item._legendItemPos[1] = b.plotTop - b.spacing[0] + a.pos;\n        });\n      },\n      render: function render() {\n        var a = this.chart,\n            c = a.renderer,\n            f = this.group,\n            e,\n            h,\n            m,\n            t = this.box,\n            p = this.options,\n            k = this.padding;\n        this.itemX = k;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        f || (this.group = f = c.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = c.g().attr({\n          zIndex: 1\n        }).add(f), this.scrollGroup = c.g().add(this.contentGroup));\n        this.renderTitle();\n        e = this.getAllItems();\n        g(e, function (a, b) {\n          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n        });\n        p.reversed && e.reverse();\n        this.allItems = e;\n        this.display = h = !!e.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        d(e, this.renderItem, this);\n        d(e, this.layoutItem, this);\n        e = (p.width || this.offsetWidth) + k;\n        m = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        m = this.handleOverflow(m);\n        m += k;\n        t || (this.box = t = c.rect().addClass(\"highcharts-legend-box\").attr({\n          r: p.borderRadius\n        }).add(f), t.isNew = !0);\n        t.attr({\n          stroke: p.borderColor,\n          \"stroke-width\": p.borderWidth || 0,\n          fill: p.backgroundColor || \"none\"\n        }).shadow(p.shadow);\n        0 < e && 0 < m && (t[t.isNew ? \"attr\" : \"animate\"](t.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: e,\n          height: m\n        }, t.strokeWidth())), t.isNew = !1);\n        t[h ? \"show\" : \"hide\"]();\n        this.legendWidth = e;\n        this.legendHeight = m;\n        h && (c = a.spacingBox, /(lth|ct|rth)/.test(this.getAlignment()) && (c = q(c, {\n          y: c.y + a.titleOffset + a.options.title.margin\n        })), f.align(q(p, {\n          width: e,\n          height: m,\n          verticalAlign: this.proximate ? \"top\" : p.verticalAlign\n        }), !0, c));\n        this.proximate || this.positionItems();\n      },\n      handleOverflow: function handleOverflow(a) {\n        var b = this,\n            f = this.chart,\n            e = f.renderer,\n            h = this.options,\n            g = h.y,\n            m = this.padding,\n            f = f.spacingBox.height + (\"top\" === h.verticalAlign ? -g : g) - m,\n            g = h.maxHeight,\n            k,\n            q = this.clipRect,\n            n = h.navigation,\n            r = p(n.animation, !0),\n            I = n.arrowSize || 12,\n            E = this.nav,\n            L = this.pages,\n            J,\n            l = this.allItems,\n            x = function x(a) {\n          \"number\" === typeof a ? q.attr({\n            height: a\n          }) : q && (b.clipRect = q.destroy(), b.contentGroup.clip());\n          b.contentGroup.div && (b.contentGroup.div.style.clip = a ? \"rect(\" + m + \"px,9999px,\" + (m + a) + \"px,0)\" : \"auto\");\n        };\n\n        \"horizontal\" !== h.layout || \"middle\" === h.verticalAlign || h.floating || (f /= 2);\n        g && (f = Math.min(f, g));\n        L.length = 0;\n        a > f && !1 !== n.enabled ? (this.clipHeight = k = Math.max(f - 20 - this.titleHeight - m, 0), this.currentPage = p(this.currentPage, 1), this.fullHeight = a, d(l, function (a, b) {\n          var c = a._legendItemPos[1],\n              f = Math.round(a.legendItem.getBBox().height),\n              d = L.length;\n          if (!d || c - L[d - 1] > k && (J || c) !== L[d - 1]) L.push(J || c), d++;\n          a.pageIx = d - 1;\n          J && (l[b - 1].pageIx = d - 1);\n          b === l.length - 1 && c + f - L[d - 1] > k && (L.push(c), a.pageIx = d);\n          c !== J && (J = c);\n        }), q || (q = b.clipRect = e.clipRect(0, m, 9999, 0), b.contentGroup.clip(q)), x(k), E || (this.nav = E = e.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = e.symbol(\"triangle\", 0, 0, I, I).on(\"click\", function () {\n          b.scroll(-1, r);\n        }).add(E), this.pager = e.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\").css(n.style).add(E), this.down = e.symbol(\"triangle-down\", 0, 0, I, I).on(\"click\", function () {\n          b.scroll(1, r);\n        }).add(E)), b.scroll(0), a = f) : E && (x(), this.nav = E.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      },\n      scroll: function scroll(a, c) {\n        var b = this.pages,\n            d = b.length;\n        a = this.currentPage + a;\n        var h = this.clipHeight,\n            g = this.options.navigation,\n            m = this.pager,\n            p = this.padding;\n        a > d && (a = d);\n        0 < a && (void 0 !== c && y(c, this.chart), this.nav.attr({\n          translateX: p,\n          translateY: h + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), this.up.attr({\n          \"class\": 1 === a ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        }), m.attr({\n          text: a + \"/\" + d\n        }), this.down.attr({\n          x: 18 + this.pager.getBBox().width,\n          \"class\": a === d ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        }), this.up.attr({\n          fill: 1 === a ? g.inactiveColor : g.activeColor\n        }).css({\n          cursor: 1 === a ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: a === d ? g.inactiveColor : g.activeColor\n        }).css({\n          cursor: a === d ? \"default\" : \"pointer\"\n        }), this.scrollOffset = -b[a - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = a, this.positionCheckboxes());\n      }\n    };\n    a.LegendSymbolMixin = {\n      drawRectangle: function drawRectangle(a, c) {\n        var b = a.symbolHeight,\n            d = a.options.squareSymbol;\n        c.legendSymbol = this.chart.renderer.rect(d ? (a.symbolWidth - b) / 2 : 0, a.baseline - b + 1, d ? b : a.symbolWidth, b, p(a.options.symbolRadius, b / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(c.legendGroup);\n      },\n      drawLineMarker: function drawLineMarker(a) {\n        var b = this.options,\n            d = b.marker,\n            e = a.symbolWidth,\n            h = a.symbolHeight,\n            g = h / 2,\n            m = this.chart.renderer,\n            k = this.legendGroup;\n        a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n        var n;\n        n = {\n          \"stroke-width\": b.lineWidth || 0\n        };\n        b.dashStyle && (n.dashstyle = b.dashStyle);\n        this.legendLine = m.path([\"M\", 0, a, \"L\", e, a]).addClass(\"highcharts-graph\").attr(n).add(k);\n        d && !1 !== d.enabled && e && (b = Math.min(p(d.radius, g), g), 0 === this.symbol.indexOf(\"url\") && (d = q(d, {\n          width: h,\n          height: h\n        }), b = 0), this.legendSymbol = d = m.symbol(this.symbol, e / 2 - b, a - b, 2 * b, 2 * b, d).addClass(\"highcharts-point\").add(k), d.isMarker = !0);\n      }\n    };\n    (/Trident\\/7\\.0/.test(h.navigator.userAgent) || u) && m(a.Legend.prototype, \"positionItem\", function (a, c) {\n      var b = this,\n          d = function d() {\n        c._legendItemPos && a.call(b, c);\n      };\n\n      d();\n      setTimeout(d);\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.addEvent,\n        C = a.animate,\n        D = a.animObject,\n        n = a.attr,\n        d = a.doc,\n        k = a.Axis,\n        u = a.createElement,\n        v = a.defaultOptions,\n        q = a.discardElement,\n        p = a.charts,\n        y = a.css,\n        g = a.defined,\n        h = a.each,\n        m = a.extend,\n        b = a.find,\n        c = a.fireEvent,\n        f = a.grep,\n        e = a.isNumber,\n        w = a.isObject,\n        G = a.isString,\n        t = a.Legend,\n        K = a.marginNames,\n        A = a.merge,\n        F = a.objectEach,\n        r = a.Pointer,\n        I = a.pick,\n        E = a.pInt,\n        L = a.removeEvent,\n        J = a.seriesTypes,\n        l = a.splat,\n        x = a.syncTimeout,\n        N = a.win,\n        T = a.Chart = function () {\n      this.getArgs.apply(this, arguments);\n    };\n\n    a.chart = function (a, b, c) {\n      return new T(a, b, c);\n    };\n\n    m(T.prototype, {\n      callbacks: [],\n      getArgs: function getArgs() {\n        var a = [].slice.call(arguments);\n        if (G(a[0]) || a[0].nodeName) this.renderTo = a.shift();\n        this.init(a[0], a[1]);\n      },\n      init: function init(b, d) {\n        var f,\n            e,\n            l = b.series,\n            r = b.plotOptions || {};\n        c(this, \"init\", {\n          args: arguments\n        }, function () {\n          b.series = null;\n          f = A(v, b);\n\n          for (e in f.plotOptions) {\n            f.plotOptions[e].tooltip = r[e] && A(r[e].tooltip) || void 0;\n          }\n\n          f.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;\n          f.series = b.series = l;\n          this.userOptions = b;\n          var h = f.chart,\n              g = h.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = d;\n          this.isResizing = 0;\n          this.options = f;\n          this.axes = [];\n          this.series = [];\n          this.time = b.time && a.keys(b.time).length ? new a.Time(b.time) : a.time;\n          this.hasCartesianSeries = h.showAxes;\n          var m = this;\n          m.index = p.length;\n          p.push(m);\n          a.chartCount++;\n          g && F(g, function (a, b) {\n            B(m, b, a);\n          });\n          m.xAxis = [];\n          m.yAxis = [];\n          m.pointCount = m.colorCounter = m.symbolCounter = 0;\n          c(m, \"afterInit\");\n          m.firstRender();\n        });\n      },\n      initSeries: function initSeries(b) {\n        var c = this.options.chart;\n        (c = J[b.type || c.type || c.defaultSeriesType]) || a.error(17, !0);\n        c = new c();\n        c.init(this, b);\n        return c;\n      },\n      orderSeries: function orderSeries(a) {\n        var b = this.series;\n\n        for (a = a || 0; a < b.length; a++) {\n          b[a] && (b[a].index = a, b[a].name = b[a].getName());\n        }\n      },\n      isInsidePlot: function isInsidePlot(a, b, c) {\n        var d = c ? b : a;\n        a = c ? a : b;\n        return 0 <= d && d <= this.plotWidth && 0 <= a && a <= this.plotHeight;\n      },\n      redraw: function redraw(b) {\n        c(this, \"beforeRedraw\");\n        var d = this.axes,\n            f = this.series,\n            e = this.pointer,\n            l = this.legend,\n            r = this.userOptions.legend,\n            g = this.isDirtyLegend,\n            p,\n            t,\n            E = this.hasCartesianSeries,\n            k = this.isDirtyBox,\n            I,\n            q = this.renderer,\n            n = q.isHidden(),\n            x = [];\n        this.setResponsive && this.setResponsive(!1);\n        a.setAnimation(b, this);\n        n && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (b = f.length; b--;) {\n          if (I = f[b], I.options.stacking && (p = !0, I.isDirty)) {\n            t = !0;\n            break;\n          }\n        }\n\n        if (t) for (b = f.length; b--;) {\n          I = f[b], I.options.stacking && (I.isDirty = !0);\n        }\n        h(f, function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (a.updateTotals && a.updateTotals(), g = !0) : r && (r.labelFormatter || r.labelFormat) && (g = !0));\n          a.isDirtyData && c(a, \"updatedData\");\n        });\n        g && l && l.options.enabled && (l.render(), this.isDirtyLegend = !1);\n        p && this.getStacks();\n        E && h(d, function (a) {\n          a.updateNames();\n          a.updateYNames && a.updateYNames();\n          a.setScale();\n        });\n        this.getMargins();\n        E && (h(d, function (a) {\n          a.isDirty && (k = !0);\n        }), h(d, function (a) {\n          var b = a.min + \",\" + a.max;\n          a.extKey !== b && (a.extKey = b, x.push(function () {\n            c(a, \"afterSetExtremes\", m(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (k || p) && a.redraw();\n        }));\n        k && this.drawChartBox();\n        c(this, \"predraw\");\n        h(f, function (a) {\n          (k || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        e && e.reset(!0);\n        q.draw();\n        c(this, \"redraw\");\n        c(this, \"render\");\n        n && this.temporaryDisplay(!0);\n        h(x, function (a) {\n          a.call();\n        });\n      },\n      get: function get(a) {\n        function c(b) {\n          return b.id === a || b.options && b.options.id === a;\n        }\n\n        var d,\n            f = this.series,\n            e;\n        d = b(this.axes, c) || b(this.series, c);\n\n        for (e = 0; !d && e < f.length; e++) {\n          d = b(f[e].points || [], c);\n        }\n\n        return d;\n      },\n      getAxes: function getAxes() {\n        var a = this,\n            b = this.options,\n            d = b.xAxis = l(b.xAxis || {}),\n            b = b.yAxis = l(b.yAxis || {});\n        c(this, \"getAxes\");\n        h(d, function (a, b) {\n          a.index = b;\n          a.isX = !0;\n        });\n        h(b, function (a, b) {\n          a.index = b;\n        });\n        d = d.concat(b);\n        h(d, function (b) {\n          new k(a, b);\n        });\n        c(this, \"afterGetAxes\");\n      },\n      getSelectedPoints: function getSelectedPoints() {\n        var a = [];\n        h(this.series, function (b) {\n          a = a.concat(f(b.data || [], function (a) {\n            return a.selected;\n          }));\n        });\n        return a;\n      },\n      getSelectedSeries: function getSelectedSeries() {\n        return f(this.series, function (a) {\n          return a.selected;\n        });\n      },\n      setTitle: function setTitle(a, b, c) {\n        var d = this,\n            f = d.options,\n            e;\n        e = f.title = A({\n          style: {\n            color: \"#333333\",\n            fontSize: f.isStock ? \"16px\" : \"18px\"\n          }\n        }, f.title, a);\n        f = f.subtitle = A({\n          style: {\n            color: \"#666666\"\n          }\n        }, f.subtitle, b);\n        h([[\"title\", a, e], [\"subtitle\", b, f]], function (a, b) {\n          var c = a[0],\n              f = d[c],\n              e = a[1];\n          a = a[2];\n          f && e && (d[c] = f = f.destroy());\n          a && !f && (d[c] = d.renderer.text(a.text, 0, 0, a.useHTML).attr({\n            align: a.align,\n            \"class\": \"highcharts-\" + c,\n            zIndex: a.zIndex || 4\n          }).add(), d[c].update = function (a) {\n            d.setTitle(!b && a, b && a);\n          }, d[c].css(a.style));\n        });\n        d.layOutTitles(c);\n      },\n      layOutTitles: function layOutTitles(a) {\n        var b = 0,\n            c,\n            d = this.renderer,\n            f = this.spacingBox;\n        h([\"title\", \"subtitle\"], function (a) {\n          var c = this[a],\n              e = this.options[a];\n          a = \"title\" === a ? -3 : e.verticalAlign ? 0 : b + 2;\n          var l;\n          c && (l = e.style.fontSize, l = d.fontMetrics(l, c).b, c.css({\n            width: (e.width || f.width + e.widthAdjust) + \"px\"\n          }).align(m({\n            y: a + l\n          }, e), !1, \"spacingBox\"), e.floating || e.verticalAlign || (b = Math.ceil(b + c.getBBox(e.useHTML).height)));\n        }, this);\n        c = this.titleOffset !== b;\n        this.titleOffset = b;\n        !this.isDirtyBox && c && (this.isDirtyBox = this.isDirtyLegend = c, this.hasRendered && I(a, !0) && this.isDirtyBox && this.redraw());\n      },\n      getChartSize: function getChartSize() {\n        var b = this.options.chart,\n            c = b.width,\n            b = b.height,\n            d = this.renderTo;\n        g(c) || (this.containerWidth = a.getStyle(d, \"width\"));\n        g(b) || (this.containerHeight = a.getStyle(d, \"height\"));\n        this.chartWidth = Math.max(0, c || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, a.relativeLength(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      },\n      temporaryDisplay: function temporaryDisplay(b) {\n        var c = this.renderTo;\n        if (b) for (; c && c.style;) {\n          c.hcOrigStyle && (a.css(c, c.hcOrigStyle), delete c.hcOrigStyle), c.hcOrigDetached && (d.body.removeChild(c), c.hcOrigDetached = !1), c = c.parentNode;\n        } else for (; c && c.style;) {\n          d.body.contains(c) || c.parentNode || (c.hcOrigDetached = !0, d.body.appendChild(c));\n          if (\"none\" === a.getStyle(c, \"display\", !1) || c.hcOricDetached) c.hcOrigStyle = {\n            display: c.style.display,\n            height: c.style.height,\n            overflow: c.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, c !== this.renderTo && (b.height = 0), a.css(c, b), c.offsetWidth || c.style.setProperty(\"display\", \"block\", \"important\");\n          c = c.parentNode;\n          if (c === d.body) break;\n        }\n      },\n      setClassName: function setClassName(a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      },\n      getContainer: function getContainer() {\n        var b,\n            f = this.options,\n            l = f.chart,\n            r,\n            h;\n        b = this.renderTo;\n        var g = a.uniqueKey(),\n            t;\n        b || (this.renderTo = b = l.renderTo);\n        G(b) && (this.renderTo = b = d.getElementById(b));\n        b || a.error(13, !0);\n        r = E(n(b, \"data-highcharts-chart\"));\n        e(r) && p[r] && p[r].hasRendered && p[r].destroy();\n        n(b, \"data-highcharts-chart\", this.index);\n        b.innerHTML = \"\";\n        l.skipClone || b.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        r = this.chartWidth;\n        h = this.chartHeight;\n        t = m({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: r + \"px\",\n          height: h + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\"\n        }, l.style);\n        this.container = b = u(\"div\", {\n          id: g\n        }, t, b);\n        this._cursor = b.style.cursor;\n        this.renderer = new (a[l.renderer] || a.Renderer)(b, r, h, null, l.forExport, f.exporting && f.exporting.allowHTML);\n        this.setClassName(l.className);\n        this.renderer.setStyle(l.style);\n        this.renderer.chartIndex = this.index;\n        c(this, \"afterGetContainer\");\n      },\n      getMargins: function getMargins(a) {\n        var b = this.spacing,\n            d = this.margin,\n            f = this.titleOffset;\n        this.resetMargins();\n        f && !g(d[0]) && (this.plotTop = Math.max(this.plotTop, f + this.options.title.margin + b[0]));\n        this.legend && this.legend.display && this.legend.adjustMargins(d, b);\n        c(this, \"getMargins\");\n        a || this.getAxisMargins();\n      },\n      getAxisMargins: function getAxisMargins() {\n        var a = this,\n            b = a.axisOffset = [0, 0, 0, 0],\n            c = a.margin;\n        a.hasCartesianSeries && h(a.axes, function (a) {\n          a.visible && a.getOffset();\n        });\n        h(K, function (d, f) {\n          g(c[f]) || (a[d] += b[f]);\n        });\n        a.setChartSize();\n      },\n      reflow: function reflow(b) {\n        var c = this,\n            f = c.options.chart,\n            e = c.renderTo,\n            l = g(f.width) && g(f.height),\n            r = f.width || a.getStyle(e, \"width\"),\n            f = f.height || a.getStyle(e, \"height\"),\n            e = b ? b.target : N;\n\n        if (!l && !c.isPrinting && r && f && (e === N || e === d)) {\n          if (r !== c.containerWidth || f !== c.containerHeight) a.clearTimeout(c.reflowTimeout), c.reflowTimeout = x(function () {\n            c.container && c.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);\n          c.containerWidth = r;\n          c.containerHeight = f;\n        }\n      },\n      setReflow: function setReflow(a) {\n        var b = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = B(N, \"resize\", function (a) {\n          b.reflow(a);\n        }), B(this, \"destroy\", this.unbindReflow));\n      },\n      setSize: function setSize(b, d, f) {\n        var e = this,\n            l = e.renderer;\n        e.isResizing += 1;\n        a.setAnimation(f, e);\n        e.oldChartHeight = e.chartHeight;\n        e.oldChartWidth = e.chartWidth;\n        void 0 !== b && (e.options.chart.width = b);\n        void 0 !== d && (e.options.chart.height = d);\n        e.getChartSize();\n        b = l.globalAnimation;\n        (b ? C : y)(e.container, {\n          width: e.chartWidth + \"px\",\n          height: e.chartHeight + \"px\"\n        }, b);\n        e.setChartSize(!0);\n        l.setSize(e.chartWidth, e.chartHeight, f);\n        h(e.axes, function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        e.isDirtyLegend = !0;\n        e.isDirtyBox = !0;\n        e.layOutTitles();\n        e.getMargins();\n        e.redraw(f);\n        e.oldChartHeight = null;\n        c(e, \"resize\");\n        x(function () {\n          e && c(e, \"endResize\", null, function () {\n            --e.isResizing;\n          });\n        }, D(b).duration);\n      },\n      setChartSize: function setChartSize(a) {\n        var b = this.inverted,\n            d = this.renderer,\n            f = this.chartWidth,\n            e = this.chartHeight,\n            l = this.options.chart,\n            r = this.spacing,\n            g = this.clipOffset,\n            m,\n            p,\n            t,\n            E;\n        this.plotLeft = m = Math.round(this.plotLeft);\n        this.plotTop = p = Math.round(this.plotTop);\n        this.plotWidth = t = Math.max(0, Math.round(f - m - this.marginRight));\n        this.plotHeight = E = Math.max(0, Math.round(e - p - this.marginBottom));\n        this.plotSizeX = b ? E : t;\n        this.plotSizeY = b ? t : E;\n        this.plotBorderWidth = l.plotBorderWidth || 0;\n        this.spacingBox = d.spacingBox = {\n          x: r[3],\n          y: r[0],\n          width: f - r[3] - r[1],\n          height: e - r[0] - r[2]\n        };\n        this.plotBox = d.plotBox = {\n          x: m,\n          y: p,\n          width: t,\n          height: E\n        };\n        f = 2 * Math.floor(this.plotBorderWidth / 2);\n        b = Math.ceil(Math.max(f, g[3]) / 2);\n        d = Math.ceil(Math.max(f, g[0]) / 2);\n        this.clipBox = {\n          x: b,\n          y: d,\n          width: Math.floor(this.plotSizeX - Math.max(f, g[1]) / 2 - b),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(f, g[2]) / 2 - d))\n        };\n        a || h(this.axes, function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n        c(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      },\n      resetMargins: function resetMargins() {\n        var a = this,\n            b = a.options.chart;\n        h([\"margin\", \"spacing\"], function (c) {\n          var d = b[c],\n              f = w(d) ? d : [d, d, d, d];\n          h([\"Top\", \"Right\", \"Bottom\", \"Left\"], function (d, e) {\n            a[c][e] = I(b[c + d], f[e]);\n          });\n        });\n        h(K, function (b, c) {\n          a[b] = I(a.margin[c], a.spacing[c]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      },\n      drawChartBox: function drawChartBox() {\n        var a = this.options.chart,\n            b = this.renderer,\n            d = this.chartWidth,\n            f = this.chartHeight,\n            e = this.chartBackground,\n            l = this.plotBackground,\n            r = this.plotBorder,\n            h,\n            g = this.plotBGImage,\n            m = a.backgroundColor,\n            p = a.plotBackgroundColor,\n            t = a.plotBackgroundImage,\n            E,\n            k = this.plotLeft,\n            I = this.plotTop,\n            q = this.plotWidth,\n            n = this.plotHeight,\n            x = this.plotBox,\n            A = this.clipRect,\n            w = this.clipBox,\n            J = \"animate\";\n        e || (this.chartBackground = e = b.rect().addClass(\"highcharts-background\").add(), J = \"attr\");\n        h = a.borderWidth || 0;\n        E = h + (a.shadow ? 8 : 0);\n        m = {\n          fill: m || \"none\"\n        };\n        if (h || e[\"stroke-width\"]) m.stroke = a.borderColor, m[\"stroke-width\"] = h;\n        e.attr(m).shadow(a.shadow);\n        e[J]({\n          x: E / 2,\n          y: E / 2,\n          width: d - E - h % 2,\n          height: f - E - h % 2,\n          r: a.borderRadius\n        });\n        J = \"animate\";\n        l || (J = \"attr\", this.plotBackground = l = b.rect().addClass(\"highcharts-plot-background\").add());\n        l[J](x);\n        l.attr({\n          fill: p || \"none\"\n        }).shadow(a.plotShadow);\n        t && (g ? g.animate(x) : this.plotBGImage = b.image(t, k, I, q, n).add());\n        A ? A.animate({\n          width: w.width,\n          height: w.height\n        }) : this.clipRect = b.clipRect(w);\n        J = \"animate\";\n        r || (J = \"attr\", this.plotBorder = r = b.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        r.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        r[J](r.crisp({\n          x: k,\n          y: I,\n          width: q,\n          height: n\n        }, -r.strokeWidth()));\n        this.isDirtyBox = !1;\n        c(this, \"afterDrawChartBox\");\n      },\n      propFromSeries: function propFromSeries() {\n        var a = this,\n            b = a.options.chart,\n            c,\n            d = a.options.series,\n            f,\n            e;\n        h([\"inverted\", \"angular\", \"polar\"], function (l) {\n          c = J[b.type || b.defaultSeriesType];\n          e = b[l] || c && c.prototype[l];\n\n          for (f = d && d.length; !e && f--;) {\n            (c = J[d[f].type]) && c.prototype[l] && (e = !0);\n          }\n\n          a[l] = e;\n        });\n      },\n      linkSeries: function linkSeries() {\n        var a = this,\n            b = a.series;\n        h(b, function (a) {\n          a.linkedSeries.length = 0;\n        });\n        h(b, function (b) {\n          var c = b.options.linkedTo;\n          G(c) && (c = \":previous\" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, b.visible = I(b.options.visible, c.options.visible, b.visible));\n        });\n        c(this, \"afterLinkSeries\");\n      },\n      renderSeries: function renderSeries() {\n        h(this.series, function (a) {\n          a.translate();\n          a.render();\n        });\n      },\n      renderLabels: function renderLabels() {\n        var a = this,\n            b = a.options.labels;\n        b.items && h(b.items, function (c) {\n          var d = m(b.style, c.style),\n              f = E(d.left) + a.plotLeft,\n              e = E(d.top) + a.plotTop + 12;\n          delete d.left;\n          delete d.top;\n          a.renderer.text(c.html, f, e).attr({\n            zIndex: 2\n          }).css(d).add();\n        });\n      },\n      render: function render() {\n        var a = this.axes,\n            b = this.renderer,\n            c = this.options,\n            d,\n            f,\n            e;\n        this.setTitle();\n        this.legend = new t(this, c.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        c = this.plotWidth;\n        d = this.plotHeight = Math.max(this.plotHeight - 21, 0);\n        h(a, function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        f = 1.1 < c / this.plotWidth;\n        e = 1.05 < d / this.plotHeight;\n        if (f || e) h(a, function (a) {\n          (a.horiz && f || !a.horiz && e) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries && h(a, function (a) {\n          a.visible && a.render();\n        });\n        this.seriesGroup || (this.seriesGroup = b.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      },\n      addCredits: function addCredits(a) {\n        var b = this;\n        a = A(!0, this.options.credits, a);\n        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          a.href && (N.location.href = a.href);\n        }).attr({\n          align: a.position.align,\n          zIndex: 8\n        }).css(a.style).add().align(a.position), this.credits.update = function (a) {\n          b.credits = b.credits.destroy();\n          b.addCredits(a);\n        });\n      },\n      destroy: function destroy() {\n        var b = this,\n            d = b.axes,\n            f = b.series,\n            e = b.container,\n            l,\n            r = e && e.parentNode;\n        c(b, \"destroy\");\n        b.renderer.forExport ? a.erase(p, b) : p[b.index] = void 0;\n        a.chartCount--;\n        b.renderTo.removeAttribute(\"data-highcharts-chart\");\n        L(b);\n\n        for (l = d.length; l--;) {\n          d[l] = d[l].destroy();\n        }\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (l = f.length; l--;) {\n          f[l] = f[l].destroy();\n        }\n\n        h(\"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \"), function (a) {\n          var c = b[a];\n          c && c.destroy && (b[a] = c.destroy());\n        });\n        e && (e.innerHTML = \"\", L(e), r && q(e));\n        F(b, function (a, c) {\n          delete b[c];\n        });\n      },\n      firstRender: function firstRender() {\n        var a = this,\n            b = a.options;\n\n        if (!a.isReadyToRender || a.isReadyToRender()) {\n          a.getContainer();\n          a.resetMargins();\n          a.setChartSize();\n          a.propFromSeries();\n          a.getAxes();\n          h(b.series || [], function (b) {\n            a.initSeries(b);\n          });\n          a.linkSeries();\n          c(a, \"beforeRender\");\n          r && (a.pointer = new r(a, b));\n          a.render();\n          if (!a.renderer.imgCount && a.onload) a.onload();\n          a.temporaryDisplay(!0);\n        }\n      },\n      onload: function onload() {\n        h([this.callback].concat(this.callbacks), function (a) {\n          a && void 0 !== this.index && a.apply(this, [this]);\n        }, this);\n        c(this, \"load\");\n        c(this, \"render\");\n        g(this.index) && this.setReflow(this.options.chart.reflow);\n        this.onload = null;\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var B,\n        C = a.each,\n        D = a.extend,\n        n = a.erase,\n        d = a.fireEvent,\n        k = a.format,\n        u = a.isArray,\n        v = a.isNumber,\n        q = a.pick,\n        p = a.uniqueKey,\n        y = a.defined,\n        g = a.removeEvent;\n\n    a.Point = B = function B() {};\n\n    a.Point.prototype = {\n      init: function init(a, g, b) {\n        this.series = a;\n        this.color = a.color;\n        this.applyOptions(g, b);\n        this.id = y(this.id) ? this.id : p();\n        a.options.colorByPoint ? (g = a.options.colors || a.chart.options.colors, this.color = this.color || g[a.colorCounter], g = g.length, b = a.colorCounter, a.colorCounter++, a.colorCounter === g && (a.colorCounter = 0)) : b = a.colorIndex;\n        this.colorIndex = q(this.colorIndex, b);\n        a.chart.pointCount++;\n        d(this, \"afterInit\");\n        return this;\n      },\n      applyOptions: function applyOptions(a, d) {\n        var b = this.series,\n            c = b.options.pointValKey || b.pointValKey;\n        a = B.prototype.optionsToObject.call(this, a);\n        D(this, a);\n        this.options = this.options ? D(this.options, a) : a;\n        a.group && delete this.group;\n        a.dataLabels && delete this.dataLabels;\n        c && (this.y = this[c]);\n        this.isNull = q(this.isValid && !this.isValid(), null === this.x || !v(this.y, !0));\n        this.selected && (this.state = \"select\");\n        \"name\" in this && void 0 === d && b.xAxis && b.xAxis.hasNames && (this.x = b.xAxis.nameToX(this));\n        void 0 === this.x && b && (this.x = void 0 === d ? b.autoIncrement(this) : d);\n        return this;\n      },\n      setNestedProperty: function setNestedProperty(d, g, b) {\n        b = b.split(\".\");\n        a.reduce(b, function (b, d, e, h) {\n          b[d] = h.length - 1 === e ? g : a.isObject(b[d], !0) ? b[d] : {};\n          return b[d];\n        }, d);\n        return d;\n      },\n      optionsToObject: function optionsToObject(d) {\n        var g = {},\n            b = this.series,\n            c = b.options.keys,\n            f = c || b.pointArrayMap || [\"y\"],\n            e = f.length,\n            h = 0,\n            p = 0;\n        if (v(d) || null === d) g[f[0]] = d;else if (u(d)) for (!c && d.length > e && (b = typeof d[0], \"string\" === b ? g.name = d[0] : \"number\" === b && (g.x = d[0]), h++); p < e;) {\n          c && void 0 === d[h] || (0 < f[p].indexOf(\".\") ? a.Point.prototype.setNestedProperty(g, d[h], f[p]) : g[f[p]] = d[h]), h++, p++;\n        } else \"object\" === typeof d && (g = d, d.dataLabels && (b._hasPointLabels = !0), d.marker && (b._hasPointMarkers = !0));\n        return g;\n      },\n      getClassName: function getClassName() {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      },\n      getZone: function getZone() {\n        var a = this.series,\n            d = a.zones,\n            a = a.zoneAxis || \"y\",\n            b = 0,\n            c;\n\n        for (c = d[b]; this[a] >= c.value;) {\n          c = d[++b];\n        }\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;\n        return c;\n      },\n      destroy: function destroy() {\n        var a = this.series.chart,\n            d = a.hoverPoints,\n            b;\n        a.pointCount--;\n        d && (this.setState(), n(d, this), d.length || (a.hoverPoints = null));\n        if (this === a.hoverPoint) this.onMouseOut();\n        if (this.graphic || this.dataLabel || this.dataLabels) g(this), this.destroyElements();\n        this.legendItem && a.legend.destroyItem(this);\n\n        for (b in this) {\n          this[b] = null;\n        }\n      },\n      destroyElements: function destroyElements() {\n        for (var a = [\"graphic\", \"dataLabel\", \"dataLabelUpper\", \"connector\", \"shadowGroup\"], d, b = 6; b--;) {\n          d = a[b], this[d] && (this[d] = this[d].destroy());\n        }\n\n        this.dataLabels && (C(this.dataLabels, function (a) {\n          a.element && a.destroy();\n        }), delete this.dataLabels);\n        this.connectors && (C(this.connectors, function (a) {\n          a.element && a.destroy();\n        }), delete this.connectors);\n      },\n      getLabelConfig: function getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      },\n      tooltipFormatter: function tooltipFormatter(a) {\n        var d = this.series,\n            b = d.tooltipOptions,\n            c = q(b.valueDecimals, \"\"),\n            f = b.valuePrefix || \"\",\n            e = b.valueSuffix || \"\";\n        C(d.pointArrayMap || [\"y\"], function (b) {\n          b = \"{point.\" + b;\n          if (f || e) a = a.replace(RegExp(b + \"}\", \"g\"), f + b + \"}\" + e);\n          a = a.replace(RegExp(b + \"}\", \"g\"), b + \":,.\" + c + \"f}\");\n        });\n        return k(a, {\n          point: this,\n          series: this.series\n        }, d.chart.time);\n      },\n      firePointEvent: function firePointEvent(a, g, b) {\n        var c = this,\n            f = this.series.options;\n        (f.point.events[a] || c.options && c.options.events && c.options.events[a]) && this.importEvents();\n        \"click\" === a && f.allowPointSelect && (b = function b(a) {\n          c.select && c.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        d(this, a, g, b);\n      },\n      visible: !0\n    };\n  })(M);\n\n  (function (a) {\n    var B = a.addEvent,\n        C = a.animObject,\n        D = a.arrayMax,\n        n = a.arrayMin,\n        d = a.correctFloat,\n        k = a.defaultOptions,\n        u = a.defaultPlotOptions,\n        v = a.defined,\n        q = a.each,\n        p = a.erase,\n        y = a.extend,\n        g = a.fireEvent,\n        h = a.grep,\n        m = a.isArray,\n        b = a.isNumber,\n        c = a.isString,\n        f = a.merge,\n        e = a.objectEach,\n        w = a.pick,\n        G = a.removeEvent,\n        t = a.splat,\n        K = a.SVGElement,\n        A = a.syncTimeout,\n        F = a.win;\n    a.Series = a.seriesType(\"line\", null, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        lineWidth: 0,\n        lineColor: \"#ffffff\",\n        enabledThreshold: 2,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        align: \"center\",\n        formatter: function formatter() {\n          return null === this.y ? \"\" : a.numberFormat(this.y, -1);\n        },\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        padding: 5\n      },\n      cropThreshold: 300,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {}\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      isCartesian: !0,\n      pointClass: a.Point,\n      sorted: !0,\n      requireSorting: !0,\n      directTouch: !1,\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      colorCounter: 0,\n      parallelArrays: [\"x\", \"y\"],\n      coll: \"series\",\n      init: function init(a, b) {\n        var c = this,\n            d,\n            f = a.series,\n            l;\n        c.chart = a;\n        c.options = b = c.setOptions(b);\n        c.linkedSeries = [];\n        c.bindAxes();\n        y(c, {\n          name: b.name,\n          state: \"\",\n          visible: !1 !== b.visible,\n          selected: !0 === b.selected\n        });\n        d = b.events;\n        e(d, function (a, b) {\n          B(c, b, a);\n        });\n        if (d && d.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;\n        c.getColor();\n        c.getSymbol();\n        q(c.parallelArrays, function (a) {\n          c[a + \"Data\"] = [];\n        });\n        c.setData(b.data, !1);\n        c.isCartesian && (a.hasCartesianSeries = !0);\n        f.length && (l = f[f.length - 1]);\n        c._i = w(l && l._i, -1) + 1;\n        a.orderSeries(this.insert(f));\n        g(this, \"afterInit\");\n      },\n      insert: function insert(a) {\n        var c = this.options.index,\n            d;\n\n        if (b(c)) {\n          for (d = a.length; d--;) {\n            if (c >= w(a[d].options.index, a[d]._i)) {\n              a.splice(d + 1, 0, this);\n              break;\n            }\n          }\n\n          -1 === d && a.unshift(this);\n          d += 1;\n        } else a.push(this);\n\n        return w(d, a.length - 1);\n      },\n      bindAxes: function bindAxes() {\n        var b = this,\n            c = b.options,\n            d = b.chart,\n            f;\n        q(b.axisTypes || [], function (e) {\n          q(d[e], function (a) {\n            f = a.options;\n            if (c[e] === f.index || void 0 !== c[e] && c[e] === f.id || void 0 === c[e] && 0 === f.index) b.insert(a.series), b[e] = a, a.isDirty = !0;\n          });\n          b[e] || b.optionalAxis === e || a.error(18, !0);\n        });\n      },\n      updateParallelArrays: function updateParallelArrays(a, c) {\n        var d = a.series,\n            f = arguments,\n            e = b(c) ? function (b) {\n          var f = \"y\" === b && d.toYData ? d.toYData(a) : a[b];\n          d[b + \"Data\"][c] = f;\n        } : function (a) {\n          Array.prototype[c].apply(d[a + \"Data\"], Array.prototype.slice.call(f, 2));\n        };\n        q(d.parallelArrays, e);\n      },\n      autoIncrement: function autoIncrement() {\n        var a = this.options,\n            b = this.xIncrement,\n            c,\n            d = a.pointIntervalUnit,\n            f = this.chart.time,\n            b = w(b, a.pointStart, 0);\n        this.pointInterval = c = w(this.pointInterval, a.pointInterval, 1);\n        d && (a = new f.Date(b), \"day\" === d ? f.set(\"Date\", a, f.get(\"Date\", a) + c) : \"month\" === d ? f.set(\"Month\", a, f.get(\"Month\", a) + c) : \"year\" === d && f.set(\"FullYear\", a, f.get(\"FullYear\", a) + c), c = a.getTime() - b);\n        this.xIncrement = b + c;\n        return b;\n      },\n      setOptions: function setOptions(a) {\n        var b = this.chart,\n            c = b.options,\n            d = c.plotOptions,\n            e = (b.userOptions || {}).plotOptions || {},\n            l = d[this.type];\n        this.userOptions = a;\n        b = f(l, d.series, a);\n        this.tooltipOptions = f(k.tooltip, k.plotOptions.series && k.plotOptions.series.tooltip, k.plotOptions[this.type].tooltip, c.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, a.tooltip);\n        this.stickyTracking = w(a.stickyTracking, e[this.type] && e[this.type].stickyTracking, e.series && e.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : b.stickyTracking);\n        null === l.marker && delete b.marker;\n        this.zoneAxis = b.zoneAxis;\n        a = this.zones = (b.zones || []).slice();\n        !b.negativeColor && !b.negativeFillColor || b.zones || a.push({\n          value: b[this.zoneAxis + \"Threshold\"] || b.threshold || 0,\n          className: \"highcharts-negative\",\n          color: b.negativeColor,\n          fillColor: b.negativeFillColor\n        });\n        a.length && v(a[a.length - 1].value) && a.push({\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        g(this, \"afterSetOptions\", {\n          options: b\n        });\n        return b;\n      },\n      getName: function getName() {\n        return this.name || \"Series \" + (this.index + 1);\n      },\n      getCyclic: function getCyclic(a, b, c) {\n        var d,\n            f = this.chart,\n            e = this.userOptions,\n            g = a + \"Index\",\n            r = a + \"Counter\",\n            h = c ? c.length : w(f.options.chart[a + \"Count\"], f[a + \"Count\"]);\n        b || (d = w(e[g], e[\"_\" + g]), v(d) || (f.series.length || (f[r] = 0), e[\"_\" + g] = d = f[r] % h, f[r] += 1), c && (b = c[d]));\n        void 0 !== d && (this[g] = d);\n        this[a] = b;\n      },\n      getColor: function getColor() {\n        this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || u[this.type].color, this.chart.options.colors);\n      },\n      getSymbol: function getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,\n      updateData: function updateData(c) {\n        var d = this.options,\n            f = this.points,\n            e = [],\n            g,\n            l,\n            r,\n            h = this.requireSorting;\n        q(c, function (c) {\n          var l;\n          l = a.defined(c) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, c).x;\n          b(l) && (l = a.inArray(l, this.xData, r), -1 === l || f[l].touched ? e.push(c) : c !== d.data[l] ? (f[l].update(c, !1, null, !1), f[l].touched = !0, h && (r = l + 1)) : f[l] && (f[l].touched = !0), g = !0);\n        }, this);\n        if (g) for (c = f.length; c--;) {\n          l = f[c], l.touched || l.remove(!1), l.touched = !1;\n        } else if (c.length === f.length) q(c, function (a, b) {\n          f[b].update && a !== d.data[b] && f[b].update(a, !1, null, !1);\n        });else return !1;\n        q(e, function (a) {\n          this.addPoint(a, !1);\n        }, this);\n        return !0;\n      },\n      setData: function setData(d, f, e, g) {\n        var r = this,\n            l = r.points,\n            h = l && l.length || 0,\n            p,\n            t = r.options,\n            k = r.chart,\n            n = null,\n            E = r.xAxis,\n            I = t.turboThreshold,\n            A = this.xData,\n            F = this.yData,\n            L = (p = r.pointArrayMap) && p.length,\n            u;\n        d = d || [];\n        p = d.length;\n        f = w(f, !0);\n        !1 !== g && p && h && !r.cropped && !r.hasGroupedData && r.visible && !r.isSeriesBoosting && (u = this.updateData(d));\n\n        if (!u) {\n          r.xIncrement = null;\n          r.colorCounter = 0;\n          q(this.parallelArrays, function (a) {\n            r[a + \"Data\"].length = 0;\n          });\n\n          if (I && p > I) {\n            for (e = 0; null === n && e < p;) {\n              n = d[e], e++;\n            }\n\n            if (b(n)) for (e = 0; e < p; e++) {\n              A[e] = this.autoIncrement(), F[e] = d[e];\n            } else if (m(n)) {\n              if (L) for (e = 0; e < p; e++) {\n                n = d[e], A[e] = n[0], F[e] = n.slice(1, L + 1);\n              } else for (e = 0; e < p; e++) {\n                n = d[e], A[e] = n[0], F[e] = n[1];\n              }\n            } else a.error(12);\n          } else for (e = 0; e < p; e++) {\n            void 0 !== d[e] && (n = {\n              series: r\n            }, r.pointClass.prototype.applyOptions.apply(n, [d[e]]), r.updateParallelArrays(n, e));\n          }\n\n          F && c(F[0]) && a.error(14, !0);\n          r.data = [];\n          r.options.data = r.userOptions.data = d;\n\n          for (e = h; e--;) {\n            l[e] && l[e].destroy && l[e].destroy();\n          }\n\n          E && (E.minRange = E.userMinRange);\n          r.isDirty = k.isDirtyBox = !0;\n          r.isDirtyData = !!l;\n          e = !1;\n        }\n\n        \"point\" === t.legendType && (this.processData(), this.generatePoints());\n        f && k.redraw(e);\n      },\n      processData: function processData(b) {\n        var c = this.xData,\n            d = this.yData,\n            f = c.length,\n            e;\n        e = 0;\n        var l,\n            g,\n            r = this.xAxis,\n            h,\n            m = this.options;\n        h = m.cropThreshold;\n        var p = this.getExtremesFromAll || m.getExtremesFromAll,\n            t = this.isCartesian,\n            m = r && r.val2lin,\n            k = r && r.isLog,\n            q = this.requireSorting,\n            n,\n            A;\n        if (t && !this.isDirty && !r.isDirty && !this.yAxis.isDirty && !b) return !1;\n        r && (b = r.getExtremes(), n = b.min, A = b.max);\n        t && this.sorted && !p && (!h || f > h || this.forceCrop) && (c[f - 1] < n || c[0] > A ? (c = [], d = []) : this.yData && (c[0] < n || c[f - 1] > A) && (e = this.cropData(this.xData, this.yData, n, A), c = e.xData, d = e.yData, e = e.start, l = !0));\n\n        for (h = c.length || 1; --h;) {\n          f = k ? m(c[h]) - m(c[h - 1]) : c[h] - c[h - 1], 0 < f && (void 0 === g || f < g) ? g = f : 0 > f && q && (a.error(15), q = !1);\n        }\n\n        this.cropped = l;\n        this.cropStart = e;\n        this.processedXData = c;\n        this.processedYData = d;\n        this.closestPointRange = g;\n      },\n      cropData: function cropData(a, b, c, d, f) {\n        var e = a.length,\n            g = 0,\n            r = e,\n            h;\n        f = w(f, this.cropShoulder, 1);\n\n        for (h = 0; h < e; h++) {\n          if (a[h] >= c) {\n            g = Math.max(0, h - f);\n            break;\n          }\n        }\n\n        for (c = h; c < e; c++) {\n          if (a[c] > d) {\n            r = c + f;\n            break;\n          }\n        }\n\n        return {\n          xData: a.slice(g, r),\n          yData: b.slice(g, r),\n          start: g,\n          end: r\n        };\n      },\n      generatePoints: function generatePoints() {\n        var a = this.options,\n            b = a.data,\n            c = this.data,\n            d,\n            f = this.processedXData,\n            e = this.processedYData,\n            g = this.pointClass,\n            h = f.length,\n            m = this.cropStart || 0,\n            p,\n            k = this.hasGroupedData,\n            a = a.keys,\n            n,\n            q = [],\n            A;\n        c || k || (c = [], c.length = b.length, c = this.data = c);\n        a && k && (this.options.keys = !1);\n\n        for (A = 0; A < h; A++) {\n          p = m + A, k ? (n = new g().init(this, [f[A]].concat(t(e[A]))), n.dataGroup = this.groupMap[A], n.dataGroup.options && (n.options = n.dataGroup.options, y(n, n.dataGroup.options))) : (n = c[p]) || void 0 === b[p] || (c[p] = n = new g().init(this, b[p], f[A])), n && (n.index = p, q[A] = n);\n        }\n\n        this.options.keys = a;\n        if (c && (h !== (d = c.length) || k)) for (A = 0; A < d; A++) {\n          A !== m || k || (A += h), c[A] && (c[A].destroyElements(), c[A].plotX = void 0);\n        }\n        this.data = c;\n        this.points = q;\n      },\n      getExtremes: function getExtremes(a) {\n        var c = this.yAxis,\n            d = this.processedXData,\n            f,\n            e = [],\n            l = 0;\n        f = this.xAxis.getExtremes();\n        var g = f.min,\n            h = f.max,\n            r,\n            p,\n            t = this.requireSorting ? 1 : 0,\n            k,\n            q;\n        a = a || this.stackedYData || this.processedYData || [];\n        f = a.length;\n\n        for (q = 0; q < f; q++) {\n          if (p = d[q], k = a[q], r = (b(k, !0) || m(k)) && (!c.positiveValuesOnly || k.length || 0 < k), p = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (d[q + t] || p) >= g && (d[q - t] || p) <= h, r && p) if (r = k.length) for (; r--;) {\n            \"number\" === typeof k[r] && (e[l++] = k[r]);\n          } else e[l++] = k;\n        }\n\n        this.dataMin = n(e);\n        this.dataMax = D(e);\n      },\n      translate: function translate() {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options,\n            c = a.stacking,\n            f = this.xAxis,\n            e = f.categories,\n            h = this.yAxis,\n            l = this.points,\n            m = l.length,\n            p = !!this.modifyValue,\n            t = a.pointPlacement,\n            k = \"between\" === t || b(t),\n            n = a.threshold,\n            q = a.startFromThreshold ? n : 0,\n            A,\n            F,\n            u,\n            G,\n            y = Number.MAX_VALUE;\n        \"between\" === t && (t = .5);\n        b(t) && (t *= w(a.pointRange || f.pointRange));\n\n        for (a = 0; a < m; a++) {\n          var K = l[a],\n              C = K.x,\n              D = K.y;\n          F = K.low;\n          var B = c && h.stacks[(this.negStacks && D < (q ? 0 : n) ? \"-\" : \"\") + this.stackKey],\n              M;\n          h.positiveValuesOnly && null !== D && 0 >= D && (K.isNull = !0);\n          K.plotX = A = d(Math.min(Math.max(-1E5, f.translate(C, 0, 0, 0, 1, t, \"flags\" === this.type)), 1E5));\n          c && this.visible && !K.isNull && B && B[C] && (G = this.getStackIndicator(G, C, this.index), M = B[C], D = M.points[G.key], F = D[0], D = D[1], F === q && G.key === B[C].base && (F = w(b(n) && n, h.min)), h.positiveValuesOnly && 0 >= F && (F = null), K.total = K.stackTotal = M.total, K.percentage = M.total && K.y / M.total * 100, K.stackY = D, M.setOffset(this.pointXOffset || 0, this.barW || 0));\n          K.yBottom = v(F) ? Math.min(Math.max(-1E5, h.translate(F, 0, 1, 0, 1)), 1E5) : null;\n          p && (D = this.modifyValue(D, K));\n          K.plotY = F = \"number\" === typeof D && Infinity !== D ? Math.min(Math.max(-1E5, h.translate(D, 0, 1, 0, 1)), 1E5) : void 0;\n          K.isInside = void 0 !== F && 0 <= F && F <= h.len && 0 <= A && A <= f.len;\n          K.clientX = k ? d(f.translate(C, 0, 0, 0, 1, t)) : A;\n          K.negative = K.y < (n || 0);\n          K.category = e && void 0 !== e[K.x] ? e[K.x] : K.x;\n          K.isNull || (void 0 !== u && (y = Math.min(y, Math.abs(A - u))), u = A);\n          K.zone = this.zones.length && K.getZone();\n        }\n\n        this.closestPointRangePx = y;\n        g(this, \"afterTranslate\");\n      },\n      getValidPoints: function getValidPoints(a, b) {\n        var c = this.chart;\n        return h(a || this.points || [], function (a) {\n          return b && !c.isInsidePlot(a.plotX, a.plotY, c.inverted) ? !1 : !a.isNull;\n        });\n      },\n      setClip: function setClip(a) {\n        var b = this.chart,\n            c = this.options,\n            d = b.renderer,\n            f = b.inverted,\n            e = this.clipBox,\n            g = e || b.clipBox,\n            h = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, g.height, c.xAxis, c.yAxis].join(),\n            r = b[h],\n            m = b[h + \"m\"];\n        r || (a && (g.width = 0, f && (g.x = b.plotSizeX), b[h + \"m\"] = m = d.clipRect(f ? b.plotSizeX + 99 : -99, f ? -b.plotLeft : -b.plotTop, 99, f ? b.chartWidth : b.chartHeight)), b[h] = r = d.clipRect(g), r.count = {\n          length: 0\n        });\n        a && !r.count[this.index] && (r.count[this.index] = !0, r.count.length += 1);\n        !1 !== c.clip && (this.group.clip(a || e ? r : b.clipRect), this.markerGroup.clip(m), this.sharedClipKey = h);\n        a || (r.count[this.index] && (delete r.count[this.index], --r.count.length), 0 === r.count.length && h && b[h] && (e || (b[h] = b[h].destroy()), b[h + \"m\"] && (b[h + \"m\"] = b[h + \"m\"].destroy())));\n      },\n      animate: function animate(a) {\n        var b = this.chart,\n            c = C(this.options.animation),\n            d;\n        a ? this.setClip(c) : (d = this.sharedClipKey, (a = b[d]) && a.animate({\n          width: b.plotSizeX,\n          x: 0\n        }, c), b[d + \"m\"] && b[d + \"m\"].animate({\n          width: b.plotSizeX + 99,\n          x: 0\n        }, c), this.animate = null);\n      },\n      afterAnimate: function afterAnimate() {\n        this.setClip();\n        g(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function drawPoints() {\n        var a = this.points,\n            b = this.chart,\n            c,\n            d,\n            f,\n            e,\n            g = this.options.marker,\n            h,\n            m,\n            p,\n            t = this[this.specialGroup] || this.markerGroup,\n            k,\n            n = w(g.enabled, this.xAxis.isRadial ? !0 : null, this.closestPointRangePx >= g.enabledThreshold * g.radius);\n        if (!1 !== g.enabled || this._hasPointMarkers) for (c = 0; c < a.length; c++) {\n          d = a[c], e = d.graphic, h = d.marker || {}, m = !!d.marker, f = n && void 0 === h.enabled || h.enabled, p = d.isInside, f && !d.isNull ? (f = w(h.symbol, this.symbol), k = this.markerAttribs(d, d.selected && \"select\"), e ? e[p ? \"show\" : \"hide\"](!0).animate(k) : p && (0 < k.width || d.hasImage) && (d.graphic = e = b.renderer.symbol(f, k.x, k.y, k.width, k.height, m ? h : g).add(t)), e && e.attr(this.pointAttribs(d, d.selected && \"select\")), e && e.addClass(d.getClassName(), !0)) : e && (d.graphic = e.destroy());\n        }\n      },\n      markerAttribs: function markerAttribs(a, b) {\n        var c = this.options.marker,\n            d = a.marker || {},\n            f = d.symbol || c.symbol,\n            e = w(d.radius, c.radius);\n        b && (c = c.states[b], b = d.states && d.states[b], e = w(b && b.radius, c && c.radius, e + (c && c.radiusPlus || 0)));\n        a.hasImage = f && 0 === f.indexOf(\"url\");\n        a.hasImage && (e = 0);\n        a = {\n          x: Math.floor(a.plotX) - e,\n          y: a.plotY - e\n        };\n        e && (a.width = a.height = 2 * e);\n        return a;\n      },\n      pointAttribs: function pointAttribs(a, b) {\n        var c = this.options.marker,\n            d = a && a.options,\n            f = d && d.marker || {},\n            e = this.color,\n            g = d && d.color,\n            h = a && a.color,\n            d = w(f.lineWidth, c.lineWidth);\n        a = a && a.zone && a.zone.color;\n        e = g || a || h || e;\n        a = f.fillColor || c.fillColor || e;\n        e = f.lineColor || c.lineColor || e;\n        b && (c = c.states[b], b = f.states && f.states[b] || {}, d = w(b.lineWidth, c.lineWidth, d + w(b.lineWidthPlus, c.lineWidthPlus, 0)), a = b.fillColor || c.fillColor || a, e = b.lineColor || c.lineColor || e);\n        return {\n          stroke: e,\n          \"stroke-width\": d,\n          fill: a\n        };\n      },\n      destroy: function destroy() {\n        var b = this,\n            c = b.chart,\n            d = /AppleWebKit\\/533/.test(F.navigator.userAgent),\n            f,\n            h,\n            l = b.data || [],\n            m,\n            t;\n        g(b, \"destroy\");\n        G(b);\n        q(b.axisTypes || [], function (a) {\n          (t = b[a]) && t.series && (p(t.series, b), t.isDirty = t.forceRedraw = !0);\n        });\n        b.legendItem && b.chart.legend.destroyItem(b);\n\n        for (h = l.length; h--;) {\n          (m = l[h]) && m.destroy && m.destroy();\n        }\n\n        b.points = null;\n        a.clearTimeout(b.animationTimeout);\n        e(b, function (a, b) {\n          a instanceof K && !a.survive && (f = d && \"group\" === b ? \"hide\" : \"destroy\", a[f]());\n        });\n        c.hoverSeries === b && (c.hoverSeries = null);\n        p(c.series, b);\n        c.orderSeries();\n        e(b, function (a, c) {\n          delete b[c];\n        });\n      },\n      getGraphPath: function getGraphPath(a, b, c) {\n        var d = this,\n            f = d.options,\n            e = f.step,\n            g,\n            h = [],\n            r = [],\n            m;\n        a = a || d.points;\n        (g = a.reversed) && a.reverse();\n        (e = {\n          right: 1,\n          center: 2\n        }[e] || e && 3) && g && (e = 4 - e);\n        !f.connectNulls || b || c || (a = this.getValidPoints(a));\n        q(a, function (l, g) {\n          var p = l.plotX,\n              t = l.plotY,\n              k = a[g - 1];\n          (l.leftCliff || k && k.rightCliff) && !c && (m = !0);\n          l.isNull && !v(b) && 0 < g ? m = !f.connectNulls : l.isNull && !b ? m = !0 : (0 === g || m ? g = [\"M\", l.plotX, l.plotY] : d.getPointSpline ? g = d.getPointSpline(a, l, g) : e ? (g = 1 === e ? [\"L\", k.plotX, t] : 2 === e ? [\"L\", (k.plotX + p) / 2, k.plotY, \"L\", (k.plotX + p) / 2, t] : [\"L\", p, k.plotY], g.push(\"L\", p, t)) : g = [\"L\", p, t], r.push(l.x), e && (r.push(l.x), 2 === e && r.push(l.x)), h.push.apply(h, g), m = !1);\n        });\n        h.xMap = r;\n        return d.graphPath = h;\n      },\n      drawGraph: function drawGraph() {\n        var a = this,\n            b = this.options,\n            c = (this.gappedPath || this.getGraphPath).call(this),\n            d = [[\"graph\", \"highcharts-graph\", b.lineColor || this.color, b.dashStyle]],\n            d = a.getZonesGraphs(d);\n        q(d, function (d, e) {\n          var f = d[0],\n              l = a[f];\n          l ? (l.endX = a.preventGraphAnimation ? null : c.xMap, l.animate({\n            d: c\n          })) : c.length && (a[f] = a.chart.renderer.path(c).addClass(d[1]).attr({\n            zIndex: 1\n          }).add(a.group), l = {\n            stroke: d[2],\n            \"stroke-width\": b.lineWidth,\n            fill: a.fillGraph && a.color || \"none\"\n          }, d[3] ? l.dashstyle = d[3] : \"square\" !== b.linecap && (l[\"stroke-linecap\"] = l[\"stroke-linejoin\"] = \"round\"), l = a[f].attr(l).shadow(2 > e && b.shadow));\n          l && (l.startX = c.xMap, l.isArea = c.isArea);\n        });\n      },\n      getZonesGraphs: function getZonesGraphs(a) {\n        q(this.zones, function (b, c) {\n          a.push([\"zone-graph-\" + c, \"highcharts-graph highcharts-zone-graph-\" + c + \" \" + (b.className || \"\"), b.color || this.color, b.dashStyle || this.options.dashStyle]);\n        }, this);\n        return a;\n      },\n      applyZones: function applyZones() {\n        var a = this,\n            b = this.chart,\n            c = b.renderer,\n            d = this.zones,\n            e,\n            f,\n            g = this.clips || [],\n            h,\n            m = this.graph,\n            p = this.area,\n            t = Math.max(b.chartWidth, b.chartHeight),\n            k = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            n,\n            A,\n            F = b.inverted,\n            u,\n            G,\n            y,\n            K,\n            v = !1;\n        d.length && (m || p) && k && void 0 !== k.min && (A = k.reversed, u = k.horiz, m && !this.showLine && m.hide(), p && p.hide(), n = k.getExtremes(), q(d, function (d, l) {\n          e = A ? u ? b.plotWidth : 0 : u ? 0 : k.toPixels(n.min);\n          e = Math.min(Math.max(w(f, e), 0), t);\n          f = Math.min(Math.max(Math.round(k.toPixels(w(d.value, n.max), !0)), 0), t);\n          v && (e = f = k.toPixels(n.max));\n          G = Math.abs(e - f);\n          y = Math.min(e, f);\n          K = Math.max(e, f);\n          k.isXAxis ? (h = {\n            x: F ? K : y,\n            y: 0,\n            width: G,\n            height: t\n          }, u || (h.x = b.plotHeight - h.x)) : (h = {\n            x: 0,\n            y: F ? K : y,\n            width: t,\n            height: G\n          }, u && (h.y = b.plotWidth - h.y));\n          F && c.isVML && (h = k.isXAxis ? {\n            x: 0,\n            y: A ? y : K,\n            height: h.width,\n            width: b.chartWidth\n          } : {\n            x: h.y - b.plotLeft - b.spacingBox.x,\n            y: 0,\n            width: h.height,\n            height: b.chartHeight\n          });\n          g[l] ? g[l].animate(h) : (g[l] = c.clipRect(h), m && a[\"zone-graph-\" + l].clip(g[l]), p && a[\"zone-area-\" + l].clip(g[l]));\n          v = d.value > n.max;\n          a.resetZones && 0 === f && (f = void 0);\n        }), this.clips = g);\n      },\n      invertGroups: function invertGroups(a) {\n        function b() {\n          q([\"group\", \"markerGroup\"], function (b) {\n            c[b] && (d.renderer.isVML && c[b].attr({\n              width: c.yAxis.len,\n              height: c.xAxis.len\n            }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(a));\n          });\n        }\n\n        var c = this,\n            d = c.chart,\n            f;\n        c.xAxis && (f = B(d, \"resize\", b), B(c, \"destroy\", f), b(a), c.invertGroups = b);\n      },\n      plotGroup: function plotGroup(a, b, c, d, f) {\n        var e = this[a],\n            g = !e;\n        g && (this[a] = e = this.chart.renderer.g().attr({\n          zIndex: d || .1\n        }).add(f));\n        e.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (v(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (e.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        e.attr({\n          visibility: c\n        })[g ? \"attr\" : \"animate\"](this.getPlotBox());\n        return e;\n      },\n      getPlotBox: function getPlotBox() {\n        var a = this.chart,\n            b = this.xAxis,\n            c = this.yAxis;\n        a.inverted && (b = c, c = this.xAxis);\n        return {\n          translateX: b ? b.left : a.plotLeft,\n          translateY: c ? c.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      render: function render() {\n        var a = this,\n            b = a.chart,\n            c,\n            d = a.options,\n            e = !!a.animate && b.renderer.isSVG && C(d.animation).duration,\n            f = a.visible ? \"inherit\" : \"hidden\",\n            h = d.zIndex,\n            m = a.hasRendered,\n            p = b.seriesGroup,\n            t = b.inverted;\n        c = a.plotGroup(\"group\", \"series\", f, h, p);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", f, h, p);\n        e && a.animate(!0);\n        c.inverted = a.isCartesian ? t : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.drawDataLabels && a.drawDataLabels();\n        a.visible && a.drawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(t);\n        !1 === d.clip || a.sharedClipKey || m || c.clip(b.clipRect);\n        e && a.animate();\n        m || (a.animationTimeout = A(function () {\n          a.afterAnimate();\n        }, e));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        g(a, \"afterRender\");\n      },\n      redraw: function redraw() {\n        var a = this.chart,\n            b = this.isDirty || this.isDirtyData,\n            c = this.group,\n            d = this.xAxis,\n            e = this.yAxis;\n        c && (a.inverted && c.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), c.animate({\n          translateX: w(d && d.left, a.plotLeft),\n          translateY: w(e && e.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function searchPoint(a, b) {\n        var c = this.xAxis,\n            d = this.yAxis,\n            e = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: e ? c.len - a.chartY + c.pos : a.chartX - c.pos,\n          plotY: e ? d.len - a.chartX + d.pos : a.chartY - d.pos\n        }, b);\n      },\n      buildKDTree: function buildKDTree() {\n        function a(c, d, e) {\n          var f, l;\n          if (l = c && c.length) return f = b.kdAxisArray[d % e], c.sort(function (a, b) {\n            return a[f] - b[f];\n          }), l = Math.floor(l / 2), {\n            point: c[l],\n            left: a(c.slice(0, l), d + 1, e),\n            right: a(c.slice(l + 1), d + 1, e)\n          };\n        }\n\n        this.buildingKdTree = !0;\n        var b = this,\n            c = -1 < b.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete b.kdTree;\n        A(function () {\n          b.kdTree = a(b.getValidPoints(null, !b.directTouch), c, c);\n          b.buildingKdTree = !1;\n        }, b.options.kdNow ? 0 : 1);\n      },\n      searchKDTree: function searchKDTree(a, b) {\n        function c(a, b, l, h) {\n          var m = b.point,\n              p = d.kdAxisArray[l % h],\n              t,\n              k,\n              r = m;\n          k = v(a[e]) && v(m[e]) ? Math.pow(a[e] - m[e], 2) : null;\n          t = v(a[f]) && v(m[f]) ? Math.pow(a[f] - m[f], 2) : null;\n          t = (k || 0) + (t || 0);\n          m.dist = v(t) ? Math.sqrt(t) : Number.MAX_VALUE;\n          m.distX = v(k) ? Math.sqrt(k) : Number.MAX_VALUE;\n          p = a[p] - m[p];\n          t = 0 > p ? \"left\" : \"right\";\n          k = 0 > p ? \"right\" : \"left\";\n          b[t] && (t = c(a, b[t], l + 1, h), r = t[g] < r[g] ? t : m);\n          b[k] && Math.sqrt(p * p) < r[g] && (a = c(a, b[k], l + 1, h), r = a[g] < r[g] ? a : r);\n          return r;\n        }\n\n        var d = this,\n            e = this.kdAxisArray[0],\n            f = this.kdAxisArray[1],\n            g = b ? \"distX\" : \"dist\";\n        b = -1 < d.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree();\n        if (this.kdTree) return c(a, this.kdTree, b, b);\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.addEvent,\n        C = a.animate,\n        D = a.Axis,\n        n = a.createElement,\n        d = a.css,\n        k = a.defined,\n        u = a.each,\n        v = a.erase,\n        q = a.extend,\n        p = a.fireEvent,\n        y = a.inArray,\n        g = a.isNumber,\n        h = a.isObject,\n        m = a.isArray,\n        b = a.merge,\n        c = a.objectEach,\n        f = a.pick,\n        e = a.Point,\n        w = a.Series,\n        G = a.seriesTypes,\n        t = a.setAnimation,\n        K = a.splat;\n    q(a.Chart.prototype, {\n      addSeries: function addSeries(a, b, c) {\n        var d,\n            e = this;\n        a && (b = f(b, !0), p(e, \"addSeries\", {\n          options: a\n        }, function () {\n          d = e.initSeries(a);\n          e.isDirtyLegend = !0;\n          e.linkSeries();\n          p(e, \"afterAddSeries\");\n          b && e.redraw(c);\n        }));\n        return d;\n      },\n      addAxis: function addAxis(a, c, d, e) {\n        var g = c ? \"xAxis\" : \"yAxis\",\n            h = this.options;\n        a = b(a, {\n          index: this[g].length,\n          isX: c\n        });\n        c = new D(this, a);\n        h[g] = K(h[g] || {});\n        h[g].push(a);\n        f(d, !0) && this.redraw(e);\n        return c;\n      },\n      showLoading: function showLoading(a) {\n        var b = this,\n            c = b.options,\n            e = b.loadingDiv,\n            f = c.loading,\n            g = function g() {\n          e && d(e, {\n            left: b.plotLeft + \"px\",\n            top: b.plotTop + \"px\",\n            width: b.plotWidth + \"px\",\n            height: b.plotHeight + \"px\"\n          });\n        };\n\n        e || (b.loadingDiv = e = n(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, b.container), b.loadingSpan = n(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, e), B(b, \"redraw\", g));\n        e.className = \"highcharts-loading\";\n        b.loadingSpan.innerHTML = a || c.lang.loading;\n        d(e, q(f.style, {\n          zIndex: 10\n        }));\n        d(b.loadingSpan, f.labelStyle);\n        b.loadingShown || (d(e, {\n          opacity: 0,\n          display: \"\"\n        }), C(e, {\n          opacity: f.style.opacity || .5\n        }, {\n          duration: f.showDuration || 0\n        }));\n        b.loadingShown = !0;\n        g();\n      },\n      hideLoading: function hideLoading() {\n        var a = this.options,\n            b = this.loadingDiv;\n        b && (b.className = \"highcharts-loading highcharts-loading-hidden\", C(b, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function complete() {\n            d(b, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"),\n      update: function update(a, d, e, h) {\n        var m = this,\n            t = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\"\n        },\n            r = a.chart,\n            l,\n            n,\n            q = [];\n        p(m, \"update\", {\n          options: a\n        });\n\n        if (r) {\n          b(!0, m.options.chart, r);\n          \"className\" in r && m.setClassName(r.className);\n          \"reflow\" in r && m.setReflow(r.reflow);\n          if (\"inverted\" in r || \"polar\" in r || \"type\" in r) m.propFromSeries(), l = !0;\n          \"alignTicks\" in r && (l = !0);\n          c(r, function (a, b) {\n            -1 !== y(\"chart.\" + b, m.propsRequireUpdateSeries) && (n = !0);\n            -1 !== y(b, m.propsRequireDirtyBox) && (m.isDirtyBox = !0);\n          });\n          \"style\" in r && m.renderer.setStyle(r.style);\n        }\n\n        a.colors && (this.options.colors = a.colors);\n        a.plotOptions && b(!0, this.options.plotOptions, a.plotOptions);\n        c(a, function (a, b) {\n          if (m[b] && \"function\" === typeof m[b].update) m[b].update(a, !1);else if (\"function\" === typeof m[t[b]]) m[t[b]](a);\n          \"chart\" !== b && -1 !== y(b, m.propsRequireUpdateSeries) && (n = !0);\n        });\n        u(\"xAxis yAxis zAxis series colorAxis pane\".split(\" \"), function (b) {\n          var c;\n          a[b] && (\"series\" === b && (c = [], u(m[b], function (a, b) {\n            a.options.isInternal || c.push(b);\n          })), u(K(a[b]), function (a, d) {\n            (d = k(a.id) && m.get(a.id) || m[b][c ? c[d] : d]) && d.coll === b && (d.update(a, !1), e && (d.touched = !0));\n            if (!d && e) if (\"series\" === b) m.addSeries(a, !1).touched = !0;else if (\"xAxis\" === b || \"yAxis\" === b) m.addAxis(a, \"xAxis\" === b, !1).touched = !0;\n          }), e && u(m[b], function (a) {\n            a.touched || a.options.isInternal ? delete a.touched : q.push(a);\n          }));\n        });\n        u(q, function (a) {\n          a.remove && a.remove(!1);\n        });\n        l && u(m.axes, function (a) {\n          a.update({}, !1);\n        });\n        n && u(m.series, function (a) {\n          a.update({}, !1);\n        });\n        a.loading && b(!0, m.options.loading, a.loading);\n        l = r && r.width;\n        r = r && r.height;\n        g(l) && l !== m.chartWidth || g(r) && r !== m.chartHeight ? m.setSize(l, r, h) : f(d, !0) && m.redraw(h);\n        p(m, \"afterUpdate\", {\n          options: a\n        });\n      },\n      setSubtitle: function setSubtitle(a) {\n        this.setTitle(void 0, a);\n      }\n    });\n    q(e.prototype, {\n      update: function update(a, b, c, d) {\n        function e() {\n          g.applyOptions(a);\n          null === g.y && l && (g.graphic = l.destroy());\n          h(a, !0) && (l && l.element && a && a.marker && void 0 !== a.marker.symbol && (g.graphic = l.destroy()), a && a.dataLabels && g.dataLabel && (g.dataLabel = g.dataLabel.destroy()), g.connector && (g.connector = g.connector.destroy()));\n          p = g.index;\n          m.updateParallelArrays(g, p);\n          r.data[p] = h(r.data[p], !0) || h(a, !0) ? g.options : f(a, r.data[p]);\n          m.isDirty = m.isDirtyData = !0;\n          !m.fixedBox && m.hasCartesianSeries && (t.isDirtyBox = !0);\n          \"point\" === r.legendType && (t.isDirtyLegend = !0);\n          b && t.redraw(c);\n        }\n\n        var g = this,\n            m = g.series,\n            l = g.graphic,\n            p,\n            t = m.chart,\n            r = m.options;\n        b = f(b, !0);\n        !1 === d ? e() : g.firePointEvent(\"update\", {\n          options: a\n        }, e);\n      },\n      remove: function remove(a, b) {\n        this.series.removePoint(y(this, this.series.data), a, b);\n      }\n    });\n    q(w.prototype, {\n      addPoint: function addPoint(a, b, c, d) {\n        var e = this.options,\n            g = this.data,\n            h = this.chart,\n            l = this.xAxis,\n            l = l && l.hasNames && l.names,\n            m = e.data,\n            p,\n            t,\n            r = this.xData,\n            k,\n            n;\n        b = f(b, !0);\n        p = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(p, [a]);\n        n = p.x;\n        k = r.length;\n        if (this.requireSorting && n < r[k - 1]) for (t = !0; k && r[k - 1] > n;) {\n          k--;\n        }\n        this.updateParallelArrays(p, \"splice\", k, 0, 0);\n        this.updateParallelArrays(p, k);\n        l && p.name && (l[n] = p.name);\n        m.splice(k, 0, a);\n        t && (this.data.splice(k, 0, null), this.processData());\n        \"point\" === e.legendType && this.generatePoints();\n        c && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), this.updateParallelArrays(p, \"shift\"), m.shift()));\n        this.isDirtyData = this.isDirty = !0;\n        b && h.redraw(d);\n      },\n      removePoint: function removePoint(a, b, c) {\n        var d = this,\n            e = d.data,\n            g = e[a],\n            h = d.points,\n            l = d.chart,\n            m = function m() {\n          h && h.length === e.length && h.splice(a, 1);\n          e.splice(a, 1);\n          d.options.data.splice(a, 1);\n          d.updateParallelArrays(g || {\n            series: d\n          }, \"splice\", a, 1);\n          g && g.destroy();\n          d.isDirty = !0;\n          d.isDirtyData = !0;\n          b && l.redraw();\n        };\n\n        t(c, l);\n        b = f(b, !0);\n        g ? g.firePointEvent(\"remove\", null, m) : m();\n      },\n      remove: function remove(a, b, c) {\n        function d() {\n          e.destroy();\n          e.remove = null;\n          g.isDirtyLegend = g.isDirtyBox = !0;\n          g.linkSeries();\n          f(a, !0) && g.redraw(b);\n        }\n\n        var e = this,\n            g = e.chart;\n        !1 !== c ? p(e, \"remove\", null, d) : d();\n      },\n      update: function update(c, d) {\n        var e = this,\n            g = e.chart,\n            h = e.userOptions,\n            m = e.oldType || e.type,\n            t = c.type || h.type || g.options.chart.type,\n            l = G[m].prototype,\n            k,\n            n = [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n            w = [\"navigatorSeries\", \"baseSeries\"],\n            A = e.finishedAnimating && {\n          animation: !1\n        },\n            F = [\"data\", \"name\", \"turboThreshold\"],\n            K = a.keys(c),\n            v = 0 < K.length;\n        u(K, function (a) {\n          -1 === y(a, F) && (v = !1);\n        });\n        if (v) c.data && this.setData(c.data, !1), c.name && this.setName(c.name, !1);else {\n          w = n.concat(w);\n          u(w, function (a) {\n            w[a] = e[a];\n            delete e[a];\n          });\n          c = b(h, A, {\n            index: e.index,\n            pointStart: f(h.pointStart, e.xData[0])\n          }, {\n            data: e.options.data\n          }, c);\n          e.remove(!1, null, !1);\n\n          for (k in l) {\n            e[k] = void 0;\n          }\n\n          G[t || m] ? q(e, G[t || m].prototype) : a.error(17, !0);\n          u(w, function (a) {\n            e[a] = w[a];\n          });\n          e.init(g, c);\n          c.zIndex !== h.zIndex && u(n, function (a) {\n            e[a] && e[a].attr({\n              zIndex: c.zIndex\n            });\n          });\n          e.oldType = m;\n          g.linkSeries();\n        }\n        p(this, \"afterUpdate\");\n        f(d, !0) && g.redraw(v ? void 0 : !1);\n      },\n      setName: function setName(a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      }\n    });\n    q(D.prototype, {\n      update: function update(a, d) {\n        var e = this.chart,\n            g = a && a.events || {};\n        a = b(this.userOptions, a);\n        e.options[this.coll].indexOf && (e.options[this.coll][e.options[this.coll].indexOf(this.userOptions)] = a);\n        c(e.options[this.coll].events, function (a, b) {\n          \"undefined\" === typeof g[b] && (g[b] = void 0);\n        });\n        this.destroy(!0);\n        this.init(e, q(a, {\n          events: g\n        }));\n        e.isDirtyBox = !0;\n        f(d, !0) && e.redraw();\n      },\n      remove: function remove(a) {\n        for (var b = this.chart, c = this.coll, d = this.series, e = d.length; e--;) {\n          d[e] && d[e].remove(!1);\n        }\n\n        v(b.axes, this);\n        v(b[c], this);\n        m(b.options[c]) ? b.options[c].splice(this.options.index, 1) : delete b.options[c];\n        u(b[c], function (a, b) {\n          a.options.index = a.userOptions.index = b;\n        });\n        this.destroy();\n        b.isDirtyBox = !0;\n        f(a, !0) && b.redraw();\n      },\n      setTitle: function setTitle(a, b) {\n        this.update({\n          title: a\n        }, b);\n      },\n      setCategories: function setCategories(a, b) {\n        this.update({\n          categories: a\n        }, b);\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.animObject,\n        C = a.color,\n        D = a.each,\n        n = a.extend,\n        d = a.defined,\n        k = a.isNumber,\n        u = a.merge,\n        v = a.pick,\n        q = a.Series,\n        p = a.seriesType,\n        y = a.svg;\n    p(\"column\", \"line\", {\n      borderRadius: 0,\n      crisp: !0,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: null,\n        verticalAlign: null,\n        y: null\n      },\n      softThreshold: !1,\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function init() {\n        q.prototype.init.apply(this, arguments);\n        var a = this,\n            d = a.chart;\n        d.hasRendered && D(d.series, function (d) {\n          d.type === a.type && (d.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function getColumnMetrics() {\n        var a = this,\n            d = a.options,\n            m = a.xAxis,\n            b = a.yAxis,\n            c = m.options.reversedStacks,\n            c = m.reversed && !c || !m.reversed && c,\n            f,\n            e = {},\n            p = 0;\n        !1 === d.grouping ? p = 1 : D(a.chart.series, function (c) {\n          var d = c.options,\n              g = c.yAxis,\n              h;\n          c.type !== a.type || !c.visible && a.chart.options.chart.ignoreHiddenSeries || b.len !== g.len || b.pos !== g.pos || (d.stacking ? (f = c.stackKey, void 0 === e[f] && (e[f] = p++), h = e[f]) : !1 !== d.grouping && (h = p++), c.columnIndex = h);\n        });\n        var k = Math.min(Math.abs(m.transA) * (m.ordinalSlope || d.pointRange || m.closestPointRange || m.tickInterval || 1), m.len),\n            t = k * d.groupPadding,\n            n = (k - 2 * t) / (p || 1),\n            d = Math.min(d.maxPointWidth || m.len, v(d.pointWidth, n * (1 - 2 * d.pointPadding)));\n        a.columnMetrics = {\n          width: d,\n          offset: (n - d) / 2 + (t + ((a.columnIndex || 0) + (c ? 1 : 0)) * n - k / 2) * (c ? -1 : 1)\n        };\n        return a.columnMetrics;\n      },\n      crispCol: function crispCol(a, d, m, b) {\n        var c = this.chart,\n            f = this.borderWidth,\n            e = -(f % 2 ? .5 : 0),\n            f = f % 2 ? .5 : 1;\n        c.inverted && c.renderer.isVML && (f += 1);\n        this.options.crisp && (m = Math.round(a + m) + e, a = Math.round(a) + e, m -= a);\n        b = Math.round(d + b) + f;\n        e = .5 >= Math.abs(d) && .5 < b;\n        d = Math.round(d) + f;\n        b -= d;\n        e && b && (--d, b += 1);\n        return {\n          x: a,\n          y: d,\n          width: m,\n          height: b\n        };\n      },\n      translate: function translate() {\n        var a = this,\n            h = a.chart,\n            m = a.options,\n            b = a.dense = 2 > a.closestPointRange * a.xAxis.transA,\n            b = a.borderWidth = v(m.borderWidth, b ? 0 : 1),\n            c = a.yAxis,\n            f = m.threshold,\n            e = a.translatedThreshold = c.getThreshold(f),\n            p = v(m.minPointLength, 5),\n            k = a.getColumnMetrics(),\n            t = k.width,\n            n = a.barW = Math.max(t, 1 + 2 * b),\n            A = a.pointXOffset = k.offset;\n        h.inverted && (e -= .5);\n        m.pointPadding && (n = Math.ceil(n));\n        q.prototype.translate.apply(a);\n        D(a.points, function (b) {\n          var g = v(b.yBottom, e),\n              m = 999 + Math.abs(g),\n              k = t,\n              m = Math.min(Math.max(-m, b.plotY), c.len + m),\n              q = b.plotX + A,\n              w = n,\n              l = Math.min(m, g),\n              x,\n              u = Math.max(m, g) - l;\n          p && Math.abs(u) < p && (u = p, x = !c.reversed && !b.negative || c.reversed && b.negative, b.y === f && a.dataMax <= f && c.min < f && (x = !x), l = Math.abs(l - e) > p ? g - p : e - (x ? p : 0));\n          d(b.options.pointWidth) && (k = w = Math.ceil(b.options.pointWidth), q -= Math.round((k - t) / 2));\n          b.barX = q;\n          b.pointWidth = k;\n          b.tooltipPos = h.inverted ? [c.len + c.pos - h.plotLeft - m, a.xAxis.len - q - w / 2, u] : [q + w / 2, m + c.pos - h.plotTop, u];\n          b.shapeType = \"rect\";\n          b.shapeArgs = a.crispCol.apply(a, b.isNull ? [q, e, w, 0] : [q, l, w, u]);\n        });\n      },\n      getSymbol: a.noop,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      drawGraph: function drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function pointAttribs(a, d) {\n        var g = this.options,\n            b,\n            c = this.pointAttrToOptions || {};\n        b = c.stroke || \"borderColor\";\n        var f = c[\"stroke-width\"] || \"borderWidth\",\n            e = a && a.color || this.color,\n            h = a && a[b] || g[b] || this.color || e,\n            p = a && a[f] || g[f] || this[f] || 0,\n            c = g.dashStyle;\n        a && this.zones.length && (e = a.getZone(), e = a.options.color || e && e.color || this.color);\n        d && (a = u(g.states[d], a.options.states && a.options.states[d] || {}), d = a.brightness, e = a.color || void 0 !== d && C(e).brighten(a.brightness).get() || e, h = a[b] || h, p = a[f] || p, c = a.dashStyle || c);\n        b = {\n          fill: e,\n          stroke: h,\n          \"stroke-width\": p\n        };\n        c && (b.dashstyle = c);\n        return b;\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            d = this.chart,\n            m = a.options,\n            b = d.renderer,\n            c = m.animationLimit || 250,\n            f;\n        D(a.points, function (e) {\n          var g = e.graphic,\n              h = g && d.pointCount < c ? \"animate\" : \"attr\";\n\n          if (k(e.plotY) && null !== e.y) {\n            f = e.shapeArgs;\n            if (g) g[h](u(f));else e.graphic = g = b[e.shapeType](f).add(e.group || a.group);\n            m.borderRadius && g.attr({\n              r: m.borderRadius\n            });\n            g[h](a.pointAttribs(e, e.selected && \"select\")).shadow(m.shadow, null, m.stacking && !m.borderRadius);\n            g.addClass(e.getClassName(), !0);\n          } else g && (e.graphic = g.destroy());\n        });\n      },\n      animate: function animate(a) {\n        var d = this,\n            g = this.yAxis,\n            b = d.options,\n            c = this.chart.inverted,\n            f = {},\n            e = c ? \"translateX\" : \"translateY\",\n            p;\n        y && (a ? (f.scaleY = .001, a = Math.min(g.pos + g.len, Math.max(g.pos, g.toPixels(b.threshold))), c ? f.translateX = a - g.len : f.translateY = a, d.group.attr(f)) : (p = d.group.attr(e), d.group.animate({\n          scaleY: 1\n        }, n(B(d.options.animation), {\n          step: function step(a, b) {\n            f[e] = p + b.pos * (g.pos - p);\n            d.group.attr(f);\n          }\n        })), d.animate = null));\n      },\n      remove: function remove() {\n        var a = this,\n            d = a.chart;\n        d.hasRendered && D(d.series, function (d) {\n          d.type === a.type && (d.isDirty = !0);\n        });\n        q.prototype.remove.apply(a, arguments);\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.Series;\n    a = a.seriesType;\n    a(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> <span style=\\\"font-size: 0.85em\\\"> {series.name}</span><br/>\",\n        pointFormat: \"x: \\x3cb\\x3e{point.x}\\x3c/b\\x3e\\x3cbr/\\x3ey: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function drawGraph() {\n        this.options.lineWidth && B.prototype.drawGraph.call(this);\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.addEvent,\n        C = a.arrayMax,\n        D = a.defined,\n        n = a.each,\n        d = a.extend,\n        k = a.format,\n        u = a.map,\n        v = a.merge,\n        q = a.noop,\n        p = a.pick,\n        y = a.relativeLength,\n        g = a.Series,\n        h = a.seriesTypes,\n        m = a.some,\n        b = a.stableSort,\n        c = a.isArray,\n        f = a.splat;\n\n    a.distribute = function (c, d, f) {\n      function e(a, b) {\n        return a.target - b.target;\n      }\n\n      var g,\n          h = !0,\n          k = c,\n          r = [],\n          q;\n      q = 0;\n      var w = k.reducedLen || d;\n\n      for (g = c.length; g--;) {\n        q += c[g].size;\n      }\n\n      if (q > w) {\n        b(c, function (a, b) {\n          return (b.rank || 0) - (a.rank || 0);\n        });\n\n        for (q = g = 0; q <= w;) {\n          q += c[g].size, g++;\n        }\n\n        r = c.splice(g - 1, c.length);\n      }\n\n      b(c, e);\n\n      for (c = u(c, function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: p(a.align, .5)\n        };\n      }); h;) {\n        for (g = c.length; g--;) {\n          h = c[g], q = (Math.min.apply(0, h.targets) + Math.max.apply(0, h.targets)) / 2, h.pos = Math.min(Math.max(0, q - h.size * h.align), d - h.size);\n        }\n\n        g = c.length;\n\n        for (h = !1; g--;) {\n          0 < g && c[g - 1].pos + c[g - 1].size > c[g].pos && (c[g - 1].size += c[g].size, c[g - 1].targets = c[g - 1].targets.concat(c[g].targets), c[g - 1].align = .5, c[g - 1].pos + c[g - 1].size > d && (c[g - 1].pos = d - c[g - 1].size), c.splice(g, 1), h = !0);\n        }\n      }\n\n      k.push.apply(k, r);\n      g = 0;\n      m(c, function (b) {\n        var c = 0;\n        if (m(b.targets, function () {\n          k[g].pos = b.pos + c;\n          if (Math.abs(k[g].pos - k[g].target) > f) return n(k.slice(0, g + 1), function (a) {\n            delete a.pos;\n          }), k.reducedLen = (k.reducedLen || d) - .1 * d, k.reducedLen > .1 * d && a.distribute(k, d, f), !0;\n          c += k[g].size;\n          g++;\n        })) return !0;\n      });\n      b(k, e);\n    };\n\n    g.prototype.drawDataLabels = function () {\n      function b(a, b) {\n        var c = b.filter;\n        return c ? (b = c.operator, a = a[c.property], c = c.value, \"\\x3e\" === b && a > c || \"\\x3c\" === b && a < c || \"\\x3e\\x3d\" === b && a >= c || \"\\x3c\\x3d\" === b && a <= c || \"\\x3d\\x3d\" === b && a == c || \"\\x3d\\x3d\\x3d\" === b && a === c ? !0 : !1) : !0;\n      }\n\n      function d(a, b) {\n        var d = [],\n            e;\n        if (c(a) && !c(b)) d = u(a, function (a) {\n          return v(a, b);\n        });else if (c(b) && !c(a)) d = u(b, function (b) {\n          return v(a, b);\n        });else if (c(a) || c(b)) for (e = Math.max(a.length, b.length); e--;) {\n          d[e] = v(a[e], b[e]);\n        } else d = v(a, b);\n        return d;\n      }\n\n      var g = this,\n          h = g.chart,\n          m = g.options,\n          q = m.dataLabels,\n          y = g.points,\n          r,\n          I = g.hasRendered || 0,\n          E,\n          C = p(q.defer, !!m.animation),\n          J = h.renderer,\n          q = d(d(h.options.plotOptions && h.options.plotOptions.series && h.options.plotOptions.series.dataLabels, h.options.plotOptions && h.options.plotOptions[g.type] && h.options.plotOptions[g.type].dataLabels), q);\n      if (c(q) || q.enabled || g._hasPointLabels) E = g.plotGroup(\"dataLabelsGroup\", \"data-labels\", C && !I ? \"hidden\" : \"visible\", q.zIndex || 6), C && (E.attr({\n        opacity: +I\n      }), I || B(g, \"afterAnimate\", function () {\n        g.visible && E.show(!0);\n        E[m.animation ? \"animate\" : \"attr\"]({\n          opacity: 1\n        }, {\n          duration: 200\n        });\n      })), n(y, function (c) {\n        r = f(d(q, c.dlOptions || c.options && c.options.dataLabels));\n        n(r, function (d, e) {\n          var f = d.enabled && !c.isNull && b(c, d),\n              l,\n              t,\n              r,\n              n,\n              q = c.dataLabels ? c.dataLabels[e] : c.dataLabel,\n              w = c.connectors ? c.connectors[e] : c.connector,\n              A = !q;\n          f && (l = c.getLabelConfig(), t = d[c.formatPrefix + \"Format\"] || d.format, l = D(t) ? k(t, l, h.time) : (d[c.formatPrefix + \"Formatter\"] || d.formatter).call(l, d), t = d.style, r = d.rotation, t.color = p(d.color, t.color, g.color, \"#000000\"), \"contrast\" === t.color && (c.contrastColor = J.getContrast(c.color || g.color), t.color = d.inside || 0 > p(d.distance, c.labelDistance) || m.stacking ? c.contrastColor : \"#000000\"), m.cursor && (t.cursor = m.cursor), n = {\n            fill: d.backgroundColor,\n            stroke: d.borderColor,\n            \"stroke-width\": d.borderWidth,\n            r: d.borderRadius || 0,\n            rotation: r,\n            padding: d.padding,\n            zIndex: 1\n          }, a.objectEach(n, function (a, b) {\n            void 0 === a && delete n[b];\n          }));\n          !q || f && D(l) ? f && D(l) && (q ? n.text = l : (c.dataLabels = c.dataLabels || [], q = c.dataLabels[e] = r ? J.text(l, 0, -9999).addClass(\"highcharts-data-label\") : J.label(l, 0, -9999, d.shape, null, null, d.useHTML, null, \"data-label\"), e || (c.dataLabel = q), q.addClass(\" highcharts-data-label-color-\" + c.colorIndex + \" \" + (d.className || \"\") + (d.useHTML ? \" highcharts-tracker\" : \"\"))), q.options = d, q.attr(n), q.css(t).shadow(d.shadow), q.added || q.add(E), g.alignDataLabel(c, q, d, null, A)) : (c.dataLabel = c.dataLabel.destroy(), c.dataLabels && (1 === c.dataLabels.length ? delete c.dataLabels : delete c.dataLabels[e]), e || delete c.dataLabel, w && (c.connector = c.connector.destroy(), c.connectors && (1 === c.connectors.length ? delete c.connectors : delete c.connectors[e])));\n        });\n      });\n      a.fireEvent(this, \"afterDrawDataLabels\");\n    };\n\n    g.prototype.alignDataLabel = function (a, b, c, f, g) {\n      var e = this.chart,\n          h = e.inverted,\n          m = p(a.dlBox && a.dlBox.centerX, a.plotX, -9999),\n          k = p(a.plotY, -9999),\n          t = b.getBBox(),\n          n,\n          q = c.rotation,\n          l = c.align,\n          w = this.visible && (a.series.forceDL || e.isInsidePlot(m, Math.round(k), h) || f && e.isInsidePlot(m, h ? f.x + 1 : f.y + f.height - 1, h)),\n          u = \"justify\" === p(c.overflow, \"justify\");\n      if (w && (n = c.style.fontSize, n = e.renderer.fontMetrics(n, b).b, f = d({\n        x: h ? this.yAxis.len - k : m,\n        y: Math.round(h ? this.xAxis.len - m : k),\n        width: 0,\n        height: 0\n      }, f), d(c, {\n        width: t.width,\n        height: t.height\n      }), q ? (u = !1, m = e.renderer.rotCorr(n, q), m = {\n        x: f.x + c.x + f.width / 2 + m.x,\n        y: f.y + c.y + {\n          top: 0,\n          middle: .5,\n          bottom: 1\n        }[c.verticalAlign] * f.height\n      }, b[g ? \"attr\" : \"animate\"](m).attr({\n        align: l\n      }), k = (q + 720) % 360, k = 180 < k && 360 > k, \"left\" === l ? m.y -= k ? t.height : 0 : \"center\" === l ? (m.x -= t.width / 2, m.y -= t.height / 2) : \"right\" === l && (m.x -= t.width, m.y -= k ? 0 : t.height), b.placed = !0, b.alignAttr = m) : (b.align(c, null, f), m = b.alignAttr), u && 0 <= f.height ? a.isLabelJustified = this.justifyDataLabel(b, c, m, t, f, g) : p(c.crop, !0) && (w = e.isInsidePlot(m.x, m.y) && e.isInsidePlot(m.x + t.width, m.y + t.height)), c.shape && !q)) b[g ? \"attr\" : \"animate\"]({\n        anchorX: h ? e.plotWidth - a.plotY : a.plotX,\n        anchorY: h ? e.plotHeight - a.plotX : a.plotY\n      });\n      w || (b.attr({\n        y: -9999\n      }), b.placed = !1);\n    };\n\n    g.prototype.justifyDataLabel = function (a, b, c, d, f, g) {\n      var e = this.chart,\n          h = b.align,\n          m = b.verticalAlign,\n          p,\n          k,\n          t = a.box ? 0 : a.padding || 0;\n      p = c.x + t;\n      0 > p && (\"right\" === h ? b.align = \"left\" : b.x = -p, k = !0);\n      p = c.x + d.width - t;\n      p > e.plotWidth && (\"left\" === h ? b.align = \"right\" : b.x = e.plotWidth - p, k = !0);\n      p = c.y + t;\n      0 > p && (\"bottom\" === m ? b.verticalAlign = \"top\" : b.y = -p, k = !0);\n      p = c.y + d.height - t;\n      p > e.plotHeight && (\"top\" === m ? b.verticalAlign = \"bottom\" : b.y = e.plotHeight - p, k = !0);\n      k && (a.placed = !g, a.align(b, null, f));\n      return k;\n    };\n\n    h.pie && (h.pie.prototype.drawDataLabels = function () {\n      var b = this,\n          c = b.data,\n          d,\n          f = b.chart,\n          h = b.options.dataLabels,\n          m = p(h.connectorPadding, 10),\n          k = p(h.connectorWidth, 1),\n          q = f.plotWidth,\n          u = f.plotHeight,\n          y = Math.round(f.chartWidth / 3),\n          v,\n          J = b.center,\n          l = J[2] / 2,\n          x = J[1],\n          B,\n          M,\n          H,\n          P,\n          Q = [[], []],\n          z,\n          O,\n          S,\n          R,\n          U = [0, 0, 0, 0];\n      b.visible && (h.enabled || b._hasPointLabels) && (n(c, function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), g.prototype.drawDataLabels.apply(b), n(c, function (a) {\n        a.dataLabel && (a.visible ? (Q[a.half].push(a), a.dataLabel._pos = null, !D(h.style.width) && !D(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > y && (a.dataLabel.css({\n          width: .7 * y\n        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n      }), n(Q, function (c, e) {\n        var g,\n            k,\n            t = c.length,\n            r = [],\n            w;\n        if (t) for (b.sortByAngle(c, e - .5), 0 < b.maxLabelDistance && (g = Math.max(0, x - l - b.maxLabelDistance), k = Math.min(x + l + b.maxLabelDistance, f.plotHeight), n(c, function (a) {\n          0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, x - l - a.labelDistance), a.bottom = Math.min(x + l + a.labelDistance, f.plotHeight), w = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n            target: a.labelPos[1] - a.top + w / 2,\n            size: w,\n            rank: a.y\n          }, r.push(a.distributeBox));\n        }), g = k + w - g, a.distribute(r, g, g / 5)), R = 0; R < t; R++) {\n          d = c[R], H = d.labelPos, B = d.dataLabel, S = !1 === d.visible ? \"hidden\" : \"inherit\", O = g = H[1], r && D(d.distributeBox) && (void 0 === d.distributeBox.pos ? S = \"hidden\" : (P = d.distributeBox.size, O = d.top + d.distributeBox.pos)), delete d.positionIndex, z = h.justify ? J[0] + (e ? -1 : 1) * (l + d.labelDistance) : b.getX(O < d.top + 2 || O > d.bottom - 2 ? g : O, e, d), B._attr = {\n            visibility: S,\n            align: H[6]\n          }, B._pos = {\n            x: z + h.x + ({\n              left: m,\n              right: -m\n            }[H[6]] || 0),\n            y: O + h.y - 10\n          }, H.x = z, H.y = O, p(h.crop, !0) && (M = B.getBBox().width, g = null, z - M < m && 1 === e ? (g = Math.round(M - z + m), U[3] = Math.max(g, U[3])) : z + M > q - m && 0 === e && (g = Math.round(z + M - q + m), U[1] = Math.max(g, U[1])), 0 > O - P / 2 ? U[0] = Math.max(Math.round(-O + P / 2), U[0]) : O + P / 2 > u && (U[2] = Math.max(Math.round(O + P / 2 - u), U[2])), B.sideOverflow = g);\n        }\n      }), 0 === C(U) || this.verifyDataLabelOverflow(U)) && (this.placeDataLabels(), k && n(this.points, function (a) {\n        var c;\n        v = a.connector;\n\n        if ((B = a.dataLabel) && B._pos && a.visible && 0 < a.labelDistance) {\n          S = B._attr.visibility;\n          if (c = !v) a.connector = v = f.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + a.colorIndex + (a.className ? \" \" + a.className : \"\")).add(b.dataLabelsGroup), v.attr({\n            \"stroke-width\": k,\n            stroke: h.connectorColor || a.color || \"#666666\"\n          });\n          v[c ? \"attr\" : \"animate\"]({\n            d: b.connectorPath(a.labelPos)\n          });\n          v.attr(\"visibility\", S);\n        } else v && (a.connector = v.destroy());\n      }));\n    }, h.pie.prototype.connectorPath = function (a) {\n      var b = a.x,\n          c = a.y;\n      return p(this.options.dataLabels.softConnector, !0) ? [\"M\", b + (\"left\" === a[6] ? 5 : -5), c, \"C\", b, c, 2 * a[2] - a[4], 2 * a[3] - a[5], a[2], a[3], \"L\", a[4], a[5]] : [\"M\", b + (\"left\" === a[6] ? 5 : -5), c, \"L\", a[2], a[3], \"L\", a[4], a[5]];\n    }, h.pie.prototype.placeDataLabels = function () {\n      n(this.points, function (a) {\n        var b = a.dataLabel;\n        b && a.visible && ((a = b._pos) ? (b.sideOverflow && (b._attr.width = b.getBBox().width - b.sideOverflow, b.css({\n          width: b._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), b.shortened = !0), b.attr(b._attr), b[b.moved ? \"animate\" : \"attr\"](a), b.moved = !0) : b && b.attr({\n          y: -9999\n        }));\n      }, this);\n    }, h.pie.prototype.alignDataLabel = q, h.pie.prototype.verifyDataLabelOverflow = function (a) {\n      var b = this.center,\n          c = this.options,\n          d = c.center,\n          f = c.minSize || 80,\n          e,\n          g = null !== c.size;\n      g || (null !== d[0] ? e = Math.max(b[2] - Math.max(a[1], a[3]), f) : (e = Math.max(b[2] - a[1] - a[3], f), b[0] += (a[3] - a[1]) / 2), null !== d[1] ? e = Math.max(Math.min(e, b[2] - Math.max(a[0], a[2])), f) : (e = Math.max(Math.min(e, b[2] - a[0] - a[2]), f), b[1] += (a[0] - a[2]) / 2), e < b[2] ? (b[2] = e, b[3] = Math.min(y(c.innerSize || 0, e), e), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : g = !0);\n      return g;\n    });\n    h.column && (h.column.prototype.alignDataLabel = function (a, b, c, d, f) {\n      var e = this.chart.inverted,\n          h = a.series,\n          m = a.dlBox || a.shapeArgs,\n          k = p(a.below, a.plotY > p(this.translatedThreshold, h.yAxis.len)),\n          t = p(c.inside, !!this.options.stacking);\n      m && (d = v(m), 0 > d.y && (d.height += d.y, d.y = 0), m = d.y + d.height - h.yAxis.len, 0 < m && (d.height -= m), e && (d = {\n        x: h.yAxis.len - d.y - d.height,\n        y: h.xAxis.len - d.x - d.width,\n        width: d.height,\n        height: d.width\n      }), t || (e ? (d.x += k ? 0 : d.width, d.width = 0) : (d.y += k ? d.height : 0, d.height = 0)));\n      c.align = p(c.align, !e || t ? \"center\" : k ? \"right\" : \"left\");\n      c.verticalAlign = p(c.verticalAlign, e || t ? \"middle\" : k ? \"top\" : \"bottom\");\n      g.prototype.alignDataLabel.call(this, a, b, c, d, f);\n      a.isLabelJustified && a.contrastColor && b.css({\n        color: a.contrastColor\n      });\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.Chart,\n        C = a.each,\n        D = a.isArray,\n        n = a.objectEach,\n        d = a.pick;\n    a = a.addEvent;\n    a(B, \"render\", function () {\n      var a = [];\n      C(this.labelCollectors || [], function (d) {\n        a = a.concat(d());\n      });\n      C(this.yAxis || [], function (d) {\n        d.options.stackLabels && !d.options.stackLabels.allowOverlap && n(d.stacks, function (d) {\n          n(d, function (d) {\n            a.push(d.label);\n          });\n        });\n      });\n      C(this.series || [], function (k) {\n        var n = k.options.dataLabels;\n        k.visible && (!1 !== n.enabled || k._hasPointLabels) && C(k.points, function (k) {\n          if (k.visible) {\n            var p = D(k.dataLabels) ? k.dataLabels : k.dataLabel ? [k.dataLabel] : [];\n            C(p, function (p) {\n              var g = p.options;\n              p.labelrank = d(g.labelrank, k.labelrank, k.shapeArgs && k.shapeArgs.height);\n              g.allowOverlap || a.push(p);\n            });\n          }\n        });\n      });\n      this.hideOverlappingLabels(a);\n    });\n\n    B.prototype.hideOverlappingLabels = function (a) {\n      var d = a.length,\n          k = this.renderer,\n          n,\n          p,\n          y,\n          g,\n          h,\n          m,\n          b = function b(a, _b, d, g, h, m, p, k) {\n        return !(h > a + d || h + p < a || m > _b + g || m + k < _b);\n      };\n\n      y = function y(a) {\n        var b,\n            c,\n            d,\n            g = a.box ? 0 : a.padding || 0;\n        d = 0;\n        if (a && (!a.alignAttr || a.placed)) return b = a.alignAttr || {\n          x: a.attr(\"x\"),\n          y: a.attr(\"y\")\n        }, c = a.parentGroup, a.width || (d = a.getBBox(), a.width = d.width, a.height = d.height, d = k.fontMetrics(null, a.element).h), {\n          x: b.x + (c.translateX || 0) + g,\n          y: b.y + (c.translateY || 0) + g - d,\n          width: a.width - 2 * g,\n          height: a.height - 2 * g\n        };\n      };\n\n      for (p = 0; p < d; p++) {\n        if (n = a[p]) n.oldOpacity = n.opacity, n.newOpacity = 1, n.absoluteBox = y(n);\n      }\n\n      a.sort(function (a, b) {\n        return (b.labelrank || 0) - (a.labelrank || 0);\n      });\n\n      for (p = 0; p < d; p++) {\n        for (m = (y = a[p]) && y.absoluteBox, n = p + 1; n < d; ++n) {\n          if (h = (g = a[n]) && g.absoluteBox, m && h && y !== g && 0 !== y.newOpacity && 0 !== g.newOpacity && (h = b(m.x, m.y, m.width, m.height, h.x, h.y, h.width, h.height))) (y.labelrank < g.labelrank ? y : g).newOpacity = 0;\n        }\n      }\n\n      C(a, function (a) {\n        var b, c;\n        a && (c = a.newOpacity, a.oldOpacity !== c && (a.alignAttr && a.placed ? (c ? a.show(!0) : b = function b() {\n          a.hide();\n        }, a.alignAttr.opacity = c, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, b)) : a.attr({\n          opacity: c\n        })), a.isOld = !0);\n      });\n    };\n  })(M);\n\n  (function (a) {\n    var B = a.addEvent,\n        C = a.Chart,\n        D = a.createElement,\n        n = a.css,\n        d = a.defaultOptions,\n        k = a.defaultPlotOptions,\n        u = a.each,\n        v = a.extend,\n        q = a.fireEvent,\n        p = a.hasTouch,\n        y = a.inArray,\n        g = a.isObject,\n        h = a.Legend,\n        m = a.merge,\n        b = a.pick,\n        c = a.Point,\n        f = a.Series,\n        e = a.seriesTypes,\n        w = a.svg,\n        G;\n    G = a.TrackerMixin = {\n      drawTrackerPoint: function drawTrackerPoint() {\n        var a = this,\n            b = a.chart.pointer,\n            c = function c(a) {\n          var c = b.getPointFromEvent(a);\n          void 0 !== c && (b.isDirectTouch = !0, c.onMouseOver(a));\n        };\n\n        u(a.points, function (a) {\n          a.graphic && (a.graphic.element.point = a);\n          a.dataLabel && (a.dataLabel.div ? a.dataLabel.div.point = a : a.dataLabel.element.point = a);\n        });\n        a._hasTracking || (u(a.trackerGroups, function (d) {\n          if (a[d]) {\n            a[d].addClass(\"highcharts-tracker\").on(\"mouseover\", c).on(\"mouseout\", function (a) {\n              b.onTrackerMouseOut(a);\n            });\n            if (p) a[d].on(\"touchstart\", c);\n            a.options.cursor && a[d].css(n).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        q(this, \"afterDrawTracker\");\n      },\n      drawTrackerGraph: function drawTrackerGraph() {\n        var a = this,\n            b = a.options,\n            c = b.trackByArea,\n            d = [].concat(c ? a.areaPath : a.graphPath),\n            f = d.length,\n            e = a.chart,\n            g = e.pointer,\n            h = e.renderer,\n            m = e.options.tooltip.snap,\n            l = a.tracker,\n            k,\n            n = function n() {\n          if (e.hoverSeries !== a) a.onMouseOver();\n        },\n            y = \"rgba(192,192,192,\" + (w ? .0001 : .002) + \")\";\n\n        if (f && !c) for (k = f + 1; k--;) {\n          \"M\" === d[k] && d.splice(k + 1, 0, d[k + 1] - m, d[k + 2], \"L\"), (k && \"M\" === d[k] || k === f) && d.splice(k, 0, \"L\", d[k - 2] + m, d[k - 1]);\n        }\n        l ? l.attr({\n          d: d\n        }) : a.graph && (a.tracker = h.path(d).attr({\n          \"stroke-linejoin\": \"round\",\n          stroke: y,\n          fill: c ? y : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (c ? 0 : 2 * m),\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(c ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), u([a.tracker, a.markerGroup], function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", n).on(\"mouseout\", function (a) {\n            g.onTrackerMouseOut(a);\n          });\n          b.cursor && a.css({\n            cursor: b.cursor\n          });\n          if (p) a.on(\"touchstart\", n);\n        }));\n        q(this, \"afterDrawTracker\");\n      }\n    };\n    e.column && (e.column.prototype.drawTracker = G.drawTrackerPoint);\n    e.pie && (e.pie.prototype.drawTracker = G.drawTrackerPoint);\n    e.scatter && (e.scatter.prototype.drawTracker = G.drawTrackerPoint);\n    d.legend.itemStyle.cursor = \"pointer\";\n    v(h.prototype, {\n      setItemEvents: function setItemEvents(a, b, d) {\n        var f = this,\n            e = f.chart.renderer.boxWrapper,\n            g = \"highcharts-legend-\" + (a instanceof c ? \"point\" : \"series\") + \"-active\";\n        (d ? b : a.legendGroup).on(\"mouseover\", function () {\n          a.setState(\"hover\");\n          e.addClass(g);\n          b.css(f.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          b.css(m(a.visible ? f.itemStyle : f.itemHiddenStyle));\n          e.removeClass(g);\n          a.setState();\n        }).on(\"click\", function (b) {\n          var c = function c() {\n            a.setVisible && a.setVisible();\n          };\n\n          e.removeClass(g);\n          b = {\n            browserEvent: b\n          };\n          a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, c) : q(a, \"legendItemClick\", b, c);\n        });\n      },\n      createCheckboxForItem: function createCheckboxForItem(a) {\n        a.checkbox = D(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        B(a.checkbox, \"click\", function (b) {\n          q(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    v(C.prototype, {\n      showResetZoom: function showResetZoom() {\n        function a() {\n          b.zoomOut();\n        }\n\n        var b = this,\n            c = d.lang,\n            f = b.options.chart.resetZoomButton,\n            e = f.theme,\n            g = e.states,\n            h = \"chart\" === f.relativeTo ? null : \"plotBox\";\n        q(this, \"beforeShowResetZoom\", null, function () {\n          b.resetZoomButton = b.renderer.button(c.resetZoom, null, null, a, e, g && g.hover).attr({\n            align: f.position.align,\n            title: c.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(f.position, !1, h);\n        });\n      },\n      zoomOut: function zoomOut() {\n        q(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      },\n      zoom: function zoom(a) {\n        var c,\n            d = this.pointer,\n            f = !1,\n            e;\n        !a || a.resetSelection ? (u(this.axes, function (a) {\n          c = a.zoom();\n        }), d.initiated = !1) : u(a.xAxis.concat(a.yAxis), function (a) {\n          var b = a.axis;\n          d[b.isXAxis ? \"zoomX\" : \"zoomY\"] && (c = b.zoom(a.min, a.max), b.displayBtn && (f = !0));\n        });\n        e = this.resetZoomButton;\n        f && !e ? this.showResetZoom() : !f && g(e) && (this.resetZoomButton = e.destroy());\n        c && this.redraw(b(this.options.chart.animation, a && a.animation, 100 > this.pointCount));\n      },\n      pan: function pan(a, b) {\n        var c = this,\n            d = c.hoverPoints,\n            f;\n        d && u(d, function (a) {\n          a.setState();\n        });\n        u(\"xy\" === b ? [1, 0] : [1], function (b) {\n          b = c[b ? \"xAxis\" : \"yAxis\"][0];\n          var d = b.horiz,\n              e = a[d ? \"chartX\" : \"chartY\"],\n              d = d ? \"mouseDownX\" : \"mouseDownY\",\n              g = c[d],\n              h = (b.pointRange || 0) / 2,\n              m = b.reversed && !c.inverted || !b.reversed && c.inverted ? -1 : 1,\n              k = b.getExtremes(),\n              p = b.toValue(g - e, !0) + h * m,\n              m = b.toValue(g + b.len - e, !0) - h * m,\n              n = m < p,\n              g = n ? m : p,\n              p = n ? p : m,\n              m = Math.min(k.dataMin, h ? k.min : b.toValue(b.toPixels(k.min) - b.minPixelPadding)),\n              h = Math.max(k.dataMax, h ? k.max : b.toValue(b.toPixels(k.max) + b.minPixelPadding)),\n              n = m - g;\n          0 < n && (p += n, g = m);\n          n = p - h;\n          0 < n && (p = h, g -= n);\n          b.series.length && g !== k.min && p !== k.max && (b.setExtremes(g, p, !1, !1, {\n            trigger: \"pan\"\n          }), f = !0);\n          c[d] = e;\n        });\n        f && c.redraw(!1);\n        n(c.container, {\n          cursor: \"move\"\n        });\n      }\n    });\n    v(c.prototype, {\n      select: function select(a, c) {\n        var d = this,\n            f = d.series,\n            e = f.chart;\n        a = b(a, !d.selected);\n        d.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: c\n        }, function () {\n          d.selected = d.options.selected = a;\n          f.options.data[y(d, f.data)] = d.options;\n          d.setState(a && \"select\");\n          c || u(e.getSelectedPoints(), function (a) {\n            a.selected && a !== d && (a.selected = a.options.selected = !1, f.options.data[y(a, f.data)] = a.options, a.setState(\"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n      },\n      onMouseOver: function onMouseOver(a) {\n        var b = this.series.chart,\n            c = b.pointer;\n        a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);\n        c.runPointActions(a, this);\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        u(a.hoverPoints || [], function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function importEvents() {\n        if (!this.hasImportedEvents) {\n          var b = this,\n              c = m(b.series.options.point, b.options).events;\n          b.events = c;\n          a.objectEach(c, function (a, c) {\n            B(b, c, a);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function setState(a, c) {\n        var d = Math.floor(this.plotX),\n            f = this.plotY,\n            e = this.series,\n            g = e.options.states[a || \"normal\"] || {},\n            h = k[e.type].marker && e.options.marker,\n            m = h && !1 === h.enabled,\n            p = h && h.states && h.states[a || \"normal\"] || {},\n            l = !1 === p.enabled,\n            n = e.stateMarkerGraphic,\n            t = this.marker || {},\n            u = e.chart,\n            w = e.halo,\n            y,\n            G = h && e.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !c || this.selected && \"select\" !== a || !1 === g.enabled || a && (l || m && !1 === p.enabled) || a && t.states && t.states[a] && !1 === t.states[a].enabled)) {\n          G && (y = e.markerAttribs(this, a));\n          if (this.graphic) this.state && this.graphic.removeClass(\"highcharts-point-\" + this.state), a && this.graphic.addClass(\"highcharts-point-\" + a), this.graphic.animate(e.pointAttribs(this, a), b(u.options.chart.animation, g.animation)), y && this.graphic.animate(y, b(u.options.chart.animation, p.animation, h.animation)), n && n.hide();else {\n            if (a && p) {\n              h = t.symbol || e.symbol;\n              n && n.currentSymbol !== h && (n = n.destroy());\n              if (n) n[c ? \"animate\" : \"attr\"]({\n                x: y.x,\n                y: y.y\n              });else h && (e.stateMarkerGraphic = n = u.renderer.symbol(h, y.x, y.y, y.width, y.height).add(e.markerGroup), n.currentSymbol = h);\n              n && n.attr(e.pointAttribs(this, a));\n            }\n\n            n && (n[a && u.isInsidePlot(d, f, u.inverted) ? \"show\" : \"hide\"](), n.element.point = this);\n          }\n          (d = g.halo) && d.size ? (w || (e.halo = w = u.renderer.path().add((this.graphic || n).parentGroup)), w.show()[c ? \"animate\" : \"attr\"]({\n            d: this.haloPath(d.size)\n          }), w.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + b(this.colorIndex, e.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            zIndex: -1\n          }), w.point = this, w.attr(v({\n            fill: this.color || e.color,\n            \"fill-opacity\": d.opacity\n          }, d.attributes))) : w && w.point && w.point.haloPath && w.animate({\n            d: w.point.haloPath(0)\n          }, null, w.hide);\n          this.state = a;\n          q(this, \"afterSetState\");\n        }\n      },\n      haloPath: function haloPath(a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    v(f.prototype, {\n      onMouseOver: function onMouseOver() {\n        var a = this.chart,\n            b = a.hoverSeries;\n        if (b && b !== this) b.onMouseOut();\n        this.options.events.mouseOver && q(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.options,\n            b = this.chart,\n            c = b.tooltip,\n            d = b.hoverPoint;\n        b.hoverSeries = null;\n        if (d) d.onMouseOut();\n        this && a.events.mouseOut && q(this, \"mouseOut\");\n        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();\n        this.setState();\n      },\n      setState: function setState(a) {\n        var c = this,\n            d = c.options,\n            f = c.graph,\n            e = d.states,\n            g = d.lineWidth,\n            d = 0;\n        a = a || \"\";\n        if (c.state !== a && (u([c.group, c.markerGroup, c.dataLabelsGroup], function (b) {\n          b && (c.state && b.removeClass(\"highcharts-series-\" + c.state), a && b.addClass(\"highcharts-series-\" + a));\n        }), c.state = a, !e[a] || !1 !== e[a].enabled) && (a && (g = e[a].lineWidth || g + (e[a].lineWidthPlus || 0)), f && !f.dashstyle)) for (g = {\n          \"stroke-width\": g\n        }, f.animate(g, b(e[a || \"normal\"] && e[a || \"normal\"].animation, c.chart.options.chart.animation)); c[\"zone-graph-\" + d];) {\n          c[\"zone-graph-\" + d].attr(g), d += 1;\n        }\n      },\n      setVisible: function setVisible(a, b) {\n        var c = this,\n            d = c.chart,\n            f = c.legendItem,\n            e,\n            g = d.options.chart.ignoreHiddenSeries,\n            h = c.visible;\n        e = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !h : a) ? \"show\" : \"hide\";\n        u([\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"], function (a) {\n          if (c[a]) c[a][e]();\n        });\n        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();\n        f && d.legend.colorizeItem(c, a);\n        c.isDirty = !0;\n        c.options.stacking && u(d.series, function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        u(c.linkedSeries, function (b) {\n          b.setVisible(a, !1);\n        });\n        g && (d.isDirtyBox = !0);\n        q(c, e);\n        !1 !== b && d.redraw();\n      },\n      show: function show() {\n        this.setVisible(!0);\n      },\n      hide: function hide() {\n        this.setVisible(!1);\n      },\n      select: function select(a) {\n        this.selected = a = void 0 === a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        q(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: G.drawTrackerGraph\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.Chart,\n        C = a.each,\n        D = a.inArray,\n        n = a.isArray,\n        d = a.isObject,\n        k = a.pick,\n        u = a.splat;\n\n    B.prototype.setResponsive = function (d) {\n      var k = this.options.responsive,\n          p = [],\n          n = this.currentResponsive;\n      k && k.rules && C(k.rules, function (g) {\n        void 0 === g._id && (g._id = a.uniqueKey());\n        this.matchResponsiveRule(g, p, d);\n      }, this);\n      var g = a.merge.apply(0, a.map(p, function (d) {\n        return a.find(k.rules, function (a) {\n          return a._id === d;\n        }).chartOptions;\n      })),\n          p = p.toString() || void 0;\n      p !== (n && n.ruleIds) && (n && this.update(n.undoOptions, d), p ? (this.currentResponsive = {\n        ruleIds: p,\n        mergedOptions: g,\n        undoOptions: this.currentOptions(g)\n      }, this.update(g, d)) : this.currentResponsive = void 0);\n    };\n\n    B.prototype.matchResponsiveRule = function (a, d) {\n      var p = a.condition;\n      (p.callback || function () {\n        return this.chartWidth <= k(p.maxWidth, Number.MAX_VALUE) && this.chartHeight <= k(p.maxHeight, Number.MAX_VALUE) && this.chartWidth >= k(p.minWidth, 0) && this.chartHeight >= k(p.minHeight, 0);\n      }).call(this) && d.push(a._id);\n    };\n\n    B.prototype.currentOptions = function (k) {\n      function q(k, g, h, m) {\n        var b;\n        a.objectEach(k, function (a, f) {\n          if (!m && -1 < D(f, [\"series\", \"xAxis\", \"yAxis\"])) for (a = u(a), h[f] = [], b = 0; b < a.length; b++) {\n            g[f][b] && (h[f][b] = {}, q(a[b], g[f][b], h[f][b], m + 1));\n          } else d(a) ? (h[f] = n(a) ? [] : {}, q(a, g[f] || {}, h[f], m + 1)) : h[f] = g[f] || null;\n        });\n      }\n\n      var p = {};\n      q(k, this.options, p, 0);\n      return p;\n    };\n  })(M);\n\n  (function (a) {\n    var B = a.addEvent,\n        C = a.Axis,\n        D = a.each,\n        n = a.pick;\n    B(C, \"getSeriesExtremes\", function () {\n      var a = [];\n      this.isXAxis && (D(this.series, function (d, n) {\n        d.useMapGeometry && (a[n] = d.xData, d.xData = []);\n      }), this.seriesXData = a);\n    });\n    B(C, \"afterGetSeriesExtremes\", function () {\n      var a = this.seriesXData,\n          k,\n          u,\n          v;\n      this.isXAxis && (k = n(this.dataMin, Number.MAX_VALUE), u = n(this.dataMax, -Number.MAX_VALUE), D(this.series, function (d, p) {\n        d.useMapGeometry && (k = Math.min(k, n(d.minX, k)), u = Math.max(u, n(d.maxX, u)), d.xData = a[p], v = !0);\n      }), v && (this.dataMin = k, this.dataMax = u), delete this.seriesXData);\n    });\n    B(C, \"afterSetAxisTranslation\", function () {\n      var a = this.chart,\n          k;\n      k = a.plotWidth / a.plotHeight;\n      var a = a.xAxis[0],\n          n;\n      \"yAxis\" === this.coll && void 0 !== a.transA && D(this.series, function (a) {\n        a.preserveAspectRatio && (n = !0);\n      });\n\n      if (n && (this.transA = a.transA = Math.min(this.transA, a.transA), k /= (a.max - a.min) / (this.max - this.min), k = 1 > k ? this : a, a = (k.max - k.min) * k.transA, k.pixelPadding = k.len - a, k.minPixelPadding = k.pixelPadding / 2, a = k.fixTo)) {\n        a = a[1] - k.toValue(a[0], !0);\n        a *= k.transA;\n        if (Math.abs(a) > k.minPixelPadding || k.min === k.dataMin && k.max === k.dataMax) a = 0;\n        k.minPixelPadding -= a;\n      }\n    });\n    B(C, \"render\", function () {\n      this.fixTo = null;\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.addEvent,\n        C = a.Axis,\n        D = a.Chart,\n        n = a.color,\n        d,\n        k = a.each,\n        u = a.extend,\n        v = a.isNumber,\n        q = a.Legend,\n        p = a.LegendSymbolMixin,\n        y = a.noop,\n        g = a.merge,\n        h = a.pick;\n    a.ColorAxis || (d = a.ColorAxis = function () {\n      this.init.apply(this, arguments);\n    }, u(d.prototype, C.prototype), u(d.prototype, {\n      defaultColorAxisOptions: {\n        lineWidth: 0,\n        minPadding: 0,\n        maxPadding: 0,\n        gridLineWidth: 1,\n        tickPixelInterval: 72,\n        startOnTick: !0,\n        endOnTick: !0,\n        offset: 0,\n        marker: {\n          animation: {\n            duration: 50\n          },\n          width: .01,\n          color: \"#999999\"\n        },\n        labels: {\n          overflow: \"justify\",\n          rotation: 0\n        },\n        minColor: \"#e6ebf5\",\n        maxColor: \"#003399\",\n        tickLength: 5,\n        showInLegend: !0\n      },\n      keepProps: [\"legendGroup\", \"legendItemHeight\", \"legendItemWidth\", \"legendItem\", \"legendSymbol\"].concat(C.prototype.keepProps),\n      init: function init(a, b) {\n        var c = \"vertical\" !== a.options.legend.layout,\n            d;\n        this.coll = \"colorAxis\";\n        d = g(this.defaultColorAxisOptions, {\n          side: c ? 2 : 1,\n          reversed: !c\n        }, b, {\n          opposite: !c,\n          showEmpty: !1,\n          title: null,\n          visible: a.options.legend.enabled\n        });\n        C.prototype.init.call(this, a, d);\n        b.dataClasses && this.initDataClasses(b);\n        this.initStops();\n        this.horiz = c;\n        this.zoomEnabled = !1;\n        this.defaultLegendLength = 200;\n      },\n      initDataClasses: function initDataClasses(a) {\n        var b = this.chart,\n            c,\n            d = 0,\n            e = b.options.chart.colorCount,\n            h = this.options,\n            m = a.dataClasses.length;\n        this.dataClasses = c = [];\n        this.legendItems = [];\n        k(a.dataClasses, function (a, f) {\n          a = g(a);\n          c.push(a);\n          a.color || (\"category\" === h.dataClassColor ? (f = b.options.colors, e = f.length, a.color = f[d], a.colorIndex = d, d++, d === e && (d = 0)) : a.color = n(h.minColor).tweenTo(n(h.maxColor), 2 > m ? .5 : f / (m - 1)));\n        });\n      },\n      setTickPositions: function setTickPositions() {\n        if (!this.dataClasses) return C.prototype.setTickPositions.call(this);\n      },\n      initStops: function initStops() {\n        this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];\n        k(this.stops, function (a) {\n          a.color = n(a[1]);\n        });\n      },\n      setOptions: function setOptions(a) {\n        C.prototype.setOptions.call(this, a);\n        this.options.crosshair = this.options.marker;\n      },\n      setAxisSize: function setAxisSize() {\n        var a = this.legendSymbol,\n            b = this.chart,\n            c = b.options.legend || {},\n            d,\n            e;\n        a ? (this.left = c = a.attr(\"x\"), this.top = d = a.attr(\"y\"), this.width = e = a.attr(\"width\"), this.height = a = a.attr(\"height\"), this.right = b.chartWidth - c - e, this.bottom = b.chartHeight - d - a, this.len = this.horiz ? e : a, this.pos = this.horiz ? c : d) : this.len = (this.horiz ? c.symbolWidth : c.symbolHeight) || this.defaultLegendLength;\n      },\n      normalizedValue: function normalizedValue(a) {\n        this.isLog && (a = this.val2lin(a));\n        return 1 - (this.max - a) / (this.max - this.min || 1);\n      },\n      toColor: function toColor(a, b) {\n        var c = this.stops,\n            d,\n            e,\n            g = this.dataClasses,\n            h,\n            m;\n        if (g) for (m = g.length; m--;) {\n          if (h = g[m], d = h.from, c = h.to, (void 0 === d || a >= d) && (void 0 === c || a <= c)) {\n            e = h.color;\n            b && (b.dataClass = m, b.colorIndex = h.colorIndex);\n            break;\n          }\n        } else {\n          a = this.normalizedValue(a);\n\n          for (m = c.length; m-- && !(a > c[m][0]);) {\n            ;\n          }\n\n          d = c[m] || c[m + 1];\n          c = c[m + 1] || d;\n          a = 1 - (c[0] - a) / (c[0] - d[0] || 1);\n          e = d.color.tweenTo(c.color, a);\n        }\n        return e;\n      },\n      getOffset: function getOffset() {\n        var a = this.legendGroup,\n            b = this.chart.axisOffset[this.side];\n        a && (this.axisParent = a, C.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = b);\n      },\n      setLegendColor: function setLegendColor() {\n        var a,\n            b = this.reversed;\n        a = b ? 1 : 0;\n        b = b ? 0 : 1;\n        a = this.horiz ? [a, 0, b, 0] : [0, b, 0, a];\n        this.legendColor = {\n          linearGradient: {\n            x1: a[0],\n            y1: a[1],\n            x2: a[2],\n            y2: a[3]\n          },\n          stops: this.stops\n        };\n      },\n      drawLegendSymbol: function drawLegendSymbol(a, b) {\n        var c = a.padding,\n            d = a.options,\n            e = this.horiz,\n            g = h(d.symbolWidth, e ? this.defaultLegendLength : 12),\n            m = h(d.symbolHeight, e ? 12 : this.defaultLegendLength),\n            k = h(d.labelPadding, e ? 16 : 30),\n            d = h(d.itemDistance, 10);\n        this.setLegendColor();\n        b.legendSymbol = this.chart.renderer.rect(0, a.baseline - 11, g, m).attr({\n          zIndex: 1\n        }).add(b.legendGroup);\n        this.legendItemWidth = g + c + (e ? d : k);\n        this.legendItemHeight = m + c + (e ? k : 0);\n      },\n      setState: function setState(a) {\n        k(this.series, function (b) {\n          b.setState(a);\n        });\n      },\n      visible: !0,\n      setVisible: y,\n      getSeriesExtremes: function getSeriesExtremes() {\n        var a = this.series,\n            b = a.length;\n        this.dataMin = Infinity;\n\n        for (this.dataMax = -Infinity; b--;) {\n          a[b].getExtremes(), void 0 !== a[b].valueMin && (this.dataMin = Math.min(this.dataMin, a[b].valueMin), this.dataMax = Math.max(this.dataMax, a[b].valueMax));\n        }\n      },\n      drawCrosshair: function drawCrosshair(a, b) {\n        var c = b && b.plotX,\n            d = b && b.plotY,\n            e,\n            g = this.pos,\n            h = this.len;\n        b && (e = this.toPixels(b[b.series.colorKey]), e < g ? e = g - 2 : e > g + h && (e = g + h + 2), b.plotX = e, b.plotY = this.len - e, C.prototype.drawCrosshair.call(this, a, b), b.plotX = c, b.plotY = d, this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass(\"highcharts-coloraxis-marker\").add(this.legendGroup), this.cross.addedToColorAxis = !0, this.cross.attr({\n          fill: this.crosshair.color\n        })));\n      },\n      getPlotLinePath: function getPlotLinePath(a, b, c, d, e) {\n        return v(e) ? this.horiz ? [\"M\", e - 4, this.top - 6, \"L\", e + 4, this.top - 6, e, this.top, \"Z\"] : [\"M\", this.left, e, \"L\", this.left - 6, e + 6, this.left - 6, e - 6, \"Z\"] : C.prototype.getPlotLinePath.call(this, a, b, c, d);\n      },\n      update: function update(a, b) {\n        var c = this.chart,\n            d = c.legend;\n        k(this.series, function (a) {\n          a.isDirtyData = !0;\n        });\n        a.dataClasses && d.allItems && (k(d.allItems, function (a) {\n          a.isDataClass && a.legendGroup && a.legendGroup.destroy();\n        }), c.isDirtyLegend = !0);\n        c.options[this.coll] = g(this.userOptions, a);\n        C.prototype.update.call(this, a, b);\n        this.legendItem && (this.setLegendColor(), d.colorizeItem(this, !0));\n      },\n      remove: function remove() {\n        this.legendItem && this.chart.legend.destroyItem(this);\n        C.prototype.remove.call(this);\n      },\n      getDataClassLegendSymbols: function getDataClassLegendSymbols() {\n        var d = this,\n            b = this.chart,\n            c = this.legendItems,\n            f = b.options.legend,\n            e = f.valueDecimals,\n            g = f.valueSuffix || \"\",\n            h;\n        c.length || k(this.dataClasses, function (f, m) {\n          var n = !0,\n              q = f.from,\n              r = f.to;\n          h = \"\";\n          void 0 === q ? h = \"\\x3c \" : void 0 === r && (h = \"\\x3e \");\n          void 0 !== q && (h += a.numberFormat(q, e) + g);\n          void 0 !== q && void 0 !== r && (h += \" - \");\n          void 0 !== r && (h += a.numberFormat(r, e) + g);\n          c.push(u({\n            chart: b,\n            name: h,\n            options: {},\n            drawLegendSymbol: p.drawRectangle,\n            visible: !0,\n            setState: y,\n            isDataClass: !0,\n            setVisible: function setVisible() {\n              n = this.visible = !n;\n              k(d.series, function (a) {\n                k(a.points, function (a) {\n                  a.dataClass === m && a.setVisible(n);\n                });\n              });\n              b.legend.colorizeItem(this, n);\n            }\n          }, f));\n        });\n        return c;\n      },\n      name: \"\"\n    }), k([\"fill\", \"stroke\"], function (d) {\n      a.Fx.prototype[d + \"Setter\"] = function () {\n        this.elem.attr(d, n(this.start).tweenTo(n(this.end), this.pos), null, !0);\n      };\n    }), B(D, \"afterGetAxes\", function () {\n      var a = this.options.colorAxis;\n      this.colorAxis = [];\n      a && new d(this, a);\n    }), B(q, \"afterGetAllItems\", function (d) {\n      var b = [],\n          c = this.chart.colorAxis[0];\n      c && c.options && c.options.showInLegend && (c.options.dataClasses ? b = c.getDataClassLegendSymbols() : b.push(c), k(c.series, function (b) {\n        a.erase(d.allItems, b);\n      }));\n\n      for (c = b.length; c--;) {\n        d.allItems.unshift(b[c]);\n      }\n    }), B(q, \"afterColorizeItem\", function (a) {\n      a.visible && a.item.legendColor && a.item.legendSymbol.attr({\n        fill: a.item.legendColor\n      });\n    }), B(q, \"afterUpdate\", function (a, b, c) {\n      this.chart.colorAxis[0] && this.chart.colorAxis[0].update({}, c);\n    }));\n  })(M);\n\n  (function (a) {\n    var B = a.defined,\n        C = a.each,\n        D = a.noop,\n        n = a.seriesTypes;\n    a.colorPointMixin = {\n      isValid: function isValid() {\n        return null !== this.value && Infinity !== this.value && -Infinity !== this.value;\n      },\n      setVisible: function setVisible(a) {\n        var d = this,\n            n = a ? \"show\" : \"hide\";\n        d.visible = !!a;\n        C([\"graphic\", \"dataLabel\"], function (a) {\n          if (d[a]) d[a][n]();\n        });\n      },\n      setState: function setState(d) {\n        a.Point.prototype.setState.call(this, d);\n        this.graphic && this.graphic.attr({\n          zIndex: \"hover\" === d ? 1 : 0\n        });\n      }\n    };\n    a.colorSeriesMixin = {\n      pointArrayMap: [\"value\"],\n      axisTypes: [\"xAxis\", \"yAxis\", \"colorAxis\"],\n      optionalAxis: \"colorAxis\",\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      getSymbol: D,\n      parallelArrays: [\"x\", \"y\", \"value\"],\n      colorKey: \"value\",\n      pointAttribs: n.column.prototype.pointAttribs,\n      translateColors: function translateColors() {\n        var a = this,\n            k = this.options.nullColor,\n            n = this.colorAxis,\n            v = this.colorKey;\n        C(this.data, function (d) {\n          var p = d[v];\n          if (p = d.options.color || (d.isNull ? k : n && void 0 !== p ? n.toColor(p, d) : d.color || a.color)) d.color = p;\n        });\n      },\n      colorAttribs: function colorAttribs(a) {\n        var d = {};\n        B(a.color) && (d[this.colorProp || \"fill\"] = a.color);\n        return d;\n      }\n    };\n  })(M);\n\n  (function (a) {\n    function B(a) {\n      a && (a.preventDefault && a.preventDefault(), a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0);\n    }\n\n    function C(a) {\n      this.init(a);\n    }\n\n    var D = a.addEvent,\n        n = a.Chart,\n        d = a.doc,\n        k = a.each,\n        u = a.extend,\n        v = a.merge,\n        q = a.pick;\n\n    C.prototype.init = function (a) {\n      this.chart = a;\n      a.mapNavButtons = [];\n    };\n\n    C.prototype.update = function (d) {\n      var k = this.chart,\n          g = k.options.mapNavigation,\n          h,\n          m,\n          b,\n          c,\n          f,\n          e = function e(a) {\n        this.handler.call(k, a);\n        B(a);\n      },\n          p = k.mapNavButtons;\n\n      d && (g = k.options.mapNavigation = v(k.options.mapNavigation, d));\n\n      for (; p.length;) {\n        p.pop().destroy();\n      }\n\n      q(g.enableButtons, g.enabled) && !k.renderer.forExport && a.objectEach(g.buttons, function (a, d) {\n        h = v(g.buttonOptions, a);\n        m = h.theme;\n        m.style = v(h.theme.style, h.style);\n        c = (b = m.states) && b.hover;\n        f = b && b.select;\n        a = k.renderer.button(h.text, 0, 0, e, m, c, f, 0, \"zoomIn\" === d ? \"topbutton\" : \"bottombutton\").addClass(\"highcharts-map-navigation\").attr({\n          width: h.width,\n          height: h.height,\n          title: k.options.lang[d],\n          padding: h.padding,\n          zIndex: 5\n        }).add();\n        a.handler = h.onclick;\n        a.align(u(h, {\n          width: a.width,\n          height: 2 * a.height\n        }), null, h.alignTo);\n        D(a.element, \"dblclick\", B);\n        p.push(a);\n      });\n      this.updateEvents(g);\n    };\n\n    C.prototype.updateEvents = function (a) {\n      var k = this.chart;\n      q(a.enableDoubleClickZoom, a.enabled) || a.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || D(k.container, \"dblclick\", function (a) {\n        k.pointer.onContainerDblClick(a);\n      }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick());\n      q(a.enableMouseWheelZoom, a.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || D(k.container, void 0 === d.onmousewheel ? \"DOMMouseScroll\" : \"mousewheel\", function (a) {\n        k.pointer.onContainerMouseWheel(a);\n        B(a);\n        return !1;\n      }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());\n    };\n\n    u(n.prototype, {\n      fitToBox: function fitToBox(a, d) {\n        k([[\"x\", \"width\"], [\"y\", \"height\"]], function (g) {\n          var h = g[0];\n          g = g[1];\n          a[h] + a[g] > d[h] + d[g] && (a[g] > d[g] ? (a[g] = d[g], a[h] = d[h]) : a[h] = d[h] + d[g] - a[g]);\n          a[g] > d[g] && (a[g] = d[g]);\n          a[h] < d[h] && (a[h] = d[h]);\n        });\n        return a;\n      },\n      mapZoom: function mapZoom(a, d, g, h, m) {\n        var b = this.xAxis[0],\n            c = b.max - b.min,\n            f = q(d, b.min + c / 2),\n            e = c * a,\n            c = this.yAxis[0],\n            k = c.max - c.min,\n            p = q(g, c.min + k / 2),\n            k = k * a,\n            f = this.fitToBox({\n          x: f - e * (h ? (h - b.pos) / b.len : .5),\n          y: p - k * (m ? (m - c.pos) / c.len : .5),\n          width: e,\n          height: k\n        }, {\n          x: b.dataMin,\n          y: c.dataMin,\n          width: b.dataMax - b.dataMin,\n          height: c.dataMax - c.dataMin\n        }),\n            e = f.x <= b.dataMin && f.width >= b.dataMax - b.dataMin && f.y <= c.dataMin && f.height >= c.dataMax - c.dataMin;\n        h && (b.fixTo = [h - b.pos, d]);\n        m && (c.fixTo = [m - c.pos, g]);\n        void 0 === a || e ? (b.setExtremes(void 0, void 0, !1), c.setExtremes(void 0, void 0, !1)) : (b.setExtremes(f.x, f.x + f.width, !1), c.setExtremes(f.y, f.y + f.height, !1));\n        this.redraw();\n      }\n    });\n    D(n, \"beforeRender\", function () {\n      this.mapNavigation = new C(this);\n      this.mapNavigation.update();\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.extend,\n        C = a.pick,\n        D = a.Pointer;\n    a = a.wrap;\n    B(D.prototype, {\n      onContainerDblClick: function onContainerDblClick(a) {\n        var d = this.chart;\n        a = this.normalize(a);\n        d.options.mapNavigation.enableDoubleClickZoomTo ? d.pointer.inClass(a.target, \"highcharts-tracker\") && d.hoverPoint && d.hoverPoint.zoomTo() : d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop) && d.mapZoom(.5, d.xAxis[0].toValue(a.chartX), d.yAxis[0].toValue(a.chartY), a.chartX, a.chartY);\n      },\n      onContainerMouseWheel: function onContainerMouseWheel(a) {\n        var d = this.chart,\n            k;\n        a = this.normalize(a);\n        k = a.detail || -(a.wheelDelta / 120);\n        d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop) && d.mapZoom(Math.pow(d.options.mapNavigation.mouseWheelSensitivity, k), d.xAxis[0].toValue(a.chartX), d.yAxis[0].toValue(a.chartY), a.chartX, a.chartY);\n      }\n    });\n    a(D.prototype, \"zoomOption\", function (a) {\n      var d = this.chart.options.mapNavigation;\n      C(d.enableTouchZoom, d.enabled) && (this.chart.options.chart.pinchType = \"xy\");\n      a.apply(this, [].slice.call(arguments, 1));\n    });\n    a(D.prototype, \"pinchTranslate\", function (a, d, k, u, v, q, p) {\n      a.call(this, d, k, u, v, q, p);\n      \"map\" === this.chart.options.chart.type && this.hasZoom && (a = u.scaleX > u.scaleY, this.pinchTranslateDirection(!a, d, k, u, v, q, p, a ? u.scaleX : u.scaleY));\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.colorPointMixin,\n        C = a.each,\n        D = a.extend,\n        n = a.isNumber,\n        d = a.map,\n        k = a.merge,\n        u = a.noop,\n        v = a.pick,\n        q = a.isArray,\n        p = a.Point,\n        y = a.Series,\n        g = a.seriesType,\n        h = a.seriesTypes,\n        m = a.splat;\n    g(\"map\", \"scatter\", {\n      allAreas: !0,\n      animation: !1,\n      nullColor: \"#f7f7f7\",\n      borderColor: \"#cccccc\",\n      borderWidth: 1,\n      marker: null,\n      stickyTracking: !1,\n      joinBy: \"hc-key\",\n      dataLabels: {\n        formatter: function formatter() {\n          return this.point.value;\n        },\n        inside: !0,\n        verticalAlign: \"middle\",\n        crop: !1,\n        overflow: !1,\n        padding: 0\n      },\n      turboThreshold: 0,\n      tooltip: {\n        followPointer: !0,\n        pointFormat: \"{point.name}: {point.value}\\x3cbr/\\x3e\"\n      },\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          halo: null,\n          brightness: .2\n        },\n        select: {\n          color: \"#cccccc\"\n        }\n      }\n    }, k(a.colorSeriesMixin, {\n      type: \"map\",\n      getExtremesFromAll: !0,\n      useMapGeometry: !0,\n      forceDL: !0,\n      searchPoint: u,\n      directTouch: !0,\n      preserveAspectRatio: !0,\n      pointArrayMap: [\"value\"],\n      getBox: function getBox(b) {\n        var c = Number.MAX_VALUE,\n            d = -c,\n            e = c,\n            g = -c,\n            h = c,\n            m = c,\n            k = this.xAxis,\n            p = this.yAxis,\n            q;\n        C(b || [], function (b) {\n          if (b.path) {\n            \"string\" === typeof b.path && (b.path = a.splitPath(b.path));\n            var f = b.path || [],\n                k = f.length,\n                p = !1,\n                r = -c,\n                l = c,\n                t = -c,\n                u = c,\n                w = b.properties;\n\n            if (!b._foundBox) {\n              for (; k--;) {\n                n(f[k]) && (p ? (r = Math.max(r, f[k]), l = Math.min(l, f[k])) : (t = Math.max(t, f[k]), u = Math.min(u, f[k])), p = !p);\n              }\n\n              b._midX = l + (r - l) * v(b.middleX, w && w[\"hc-middle-x\"], .5);\n              b._midY = u + (t - u) * v(b.middleY, w && w[\"hc-middle-y\"], .5);\n              b._maxX = r;\n              b._minX = l;\n              b._maxY = t;\n              b._minY = u;\n              b.labelrank = v(b.labelrank, (r - l) * (t - u));\n              b._foundBox = !0;\n            }\n\n            d = Math.max(d, b._maxX);\n            e = Math.min(e, b._minX);\n            g = Math.max(g, b._maxY);\n            h = Math.min(h, b._minY);\n            m = Math.min(b._maxX - b._minX, b._maxY - b._minY, m);\n            q = !0;\n          }\n        });\n        q && (this.minY = Math.min(h, v(this.minY, c)), this.maxY = Math.max(g, v(this.maxY, -c)), this.minX = Math.min(e, v(this.minX, c)), this.maxX = Math.max(d, v(this.maxX, -c)), k && void 0 === k.options.minRange && (k.minRange = Math.min(5 * m, (this.maxX - this.minX) / 5, k.minRange || c)), p && void 0 === p.options.minRange && (p.minRange = Math.min(5 * m, (this.maxY - this.minY) / 5, p.minRange || c)));\n      },\n      getExtremes: function getExtremes() {\n        y.prototype.getExtremes.call(this, this.valueData);\n        this.chart.hasRendered && this.isDirtyData && this.getBox(this.options.data);\n        this.valueMin = this.dataMin;\n        this.valueMax = this.dataMax;\n        this.dataMin = this.minY;\n        this.dataMax = this.maxY;\n      },\n      translatePath: function translatePath(a) {\n        var b = !1,\n            d = this.xAxis,\n            e = this.yAxis,\n            g = d.min,\n            h = d.transA,\n            d = d.minPixelPadding,\n            k = e.min,\n            m = e.transA,\n            e = e.minPixelPadding,\n            p,\n            q = [];\n        if (a) for (p = a.length; p--;) {\n          n(a[p]) ? (q[p] = b ? (a[p] - g) * h + d : (a[p] - k) * m + e, b = !b) : q[p] = a[p];\n        }\n        return q;\n      },\n      setData: function setData(b, c, f, e) {\n        var g = this.options,\n            h = this.chart.options.chart,\n            p = h && h.map,\n            u = g.mapData,\n            v = g.joinBy,\n            D = null === v,\n            r = g.keys || this.pointArrayMap,\n            B = [],\n            E = {},\n            L = this.chart.mapTransforms;\n        !u && p && (u = \"string\" === typeof p ? a.maps[p] : p);\n        D && (v = \"_i\");\n        v = this.joinBy = m(v);\n        v[1] || (v[1] = v[0]);\n        b && C(b, function (c, d) {\n          var e = 0;\n          if (n(c)) b[d] = {\n            value: c\n          };else if (q(c)) {\n            b[d] = {};\n            !g.keys && c.length > r.length && \"string\" === typeof c[0] && (b[d][\"hc-key\"] = c[0], ++e);\n\n            for (var f = 0; f < r.length; ++f, ++e) {\n              r[f] && void 0 !== c[e] && (0 < r[f].indexOf(\".\") ? a.Point.prototype.setNestedProperty(b[d], c[e], r[f]) : b[d][r[f]] = c[e]);\n            }\n          }\n          D && (b[d]._i = d);\n        });\n        this.getBox(b);\n        (this.chart.mapTransforms = L = h && h.mapTransforms || u && u[\"hc-transform\"] || L) && a.objectEach(L, function (a) {\n          a.rotation && (a.cosAngle = Math.cos(a.rotation), a.sinAngle = Math.sin(a.rotation));\n        });\n\n        if (u) {\n          \"FeatureCollection\" === u.type && (this.mapTitle = u.title, u = a.geojson(u, this.type, this));\n          this.mapData = u;\n          this.mapMap = {};\n\n          for (L = 0; L < u.length; L++) {\n            h = u[L], p = h.properties, h._i = L, v[0] && p && p[v[0]] && (h[v[0]] = p[v[0]]), E[h[v[0]]] = h;\n          }\n\n          this.mapMap = E;\n          b && v[1] && C(b, function (a) {\n            E[a[v[1]]] && B.push(E[a[v[1]]]);\n          });\n          g.allAreas ? (this.getBox(u), b = b || [], v[1] && C(b, function (a) {\n            B.push(a[v[1]]);\n          }), B = \"|\" + d(B, function (a) {\n            return a && a[v[0]];\n          }).join(\"|\") + \"|\", C(u, function (a) {\n            v[0] && -1 !== B.indexOf(\"|\" + a[v[0]] + \"|\") || (b.push(k(a, {\n              value: null\n            })), e = !1);\n          })) : this.getBox(B);\n        }\n\n        y.prototype.setData.call(this, b, c, f, e);\n      },\n      drawGraph: u,\n      drawDataLabels: u,\n      doFullTranslate: function doFullTranslate() {\n        return this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML || !this.baseTrans;\n      },\n      translate: function translate() {\n        var a = this,\n            c = a.xAxis,\n            d = a.yAxis,\n            e = a.doFullTranslate();\n        a.generatePoints();\n        C(a.data, function (b) {\n          b.plotX = c.toPixels(b._midX, !0);\n          b.plotY = d.toPixels(b._midY, !0);\n          e && (b.shapeType = \"path\", b.shapeArgs = {\n            d: a.translatePath(b.path)\n          });\n        });\n        a.translateColors();\n      },\n      pointAttribs: function pointAttribs(a, c) {\n        c = h.column.prototype.pointAttribs.call(this, a, c);\n        c[\"stroke-width\"] = v(a.options[this.pointAttrToOptions && this.pointAttrToOptions[\"stroke-width\"] || \"borderWidth\"], \"inherit\");\n        return c;\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            c = a.xAxis,\n            d = a.yAxis,\n            e = a.group,\n            g = a.chart,\n            k = g.renderer,\n            m,\n            p,\n            n,\n            q,\n            r = this.baseTrans,\n            u,\n            v,\n            y,\n            B,\n            l;\n        a.transformGroup || (a.transformGroup = k.g().attr({\n          scaleX: 1,\n          scaleY: 1\n        }).add(e), a.transformGroup.survive = !0);\n        a.doFullTranslate() ? (g.hasRendered && C(a.points, function (b) {\n          b.shapeArgs && (b.shapeArgs.fill = a.pointAttribs(b, b.state).fill);\n        }), a.group = a.transformGroup, h.column.prototype.drawPoints.apply(a), a.group = e, C(a.points, function (a) {\n          a.graphic && (a.name && a.graphic.addClass(\"highcharts-name-\" + a.name.replace(/ /g, \"-\").toLowerCase()), a.properties && a.properties[\"hc-key\"] && a.graphic.addClass(\"highcharts-key-\" + a.properties[\"hc-key\"].toLowerCase()));\n        }), this.baseTrans = {\n          originX: c.min - c.minPixelPadding / c.transA,\n          originY: d.min - d.minPixelPadding / d.transA + (d.reversed ? 0 : d.len / d.transA),\n          transAX: c.transA,\n          transAY: d.transA\n        }, this.transformGroup.animate({\n          translateX: 0,\n          translateY: 0,\n          scaleX: 1,\n          scaleY: 1\n        })) : (m = c.transA / r.transAX, p = d.transA / r.transAY, n = c.toPixels(r.originX, !0), q = d.toPixels(r.originY, !0), .99 < m && 1.01 > m && .99 < p && 1.01 > p && (p = m = 1, n = Math.round(n), q = Math.round(q)), u = this.transformGroup, g.renderer.globalAnimation ? (v = u.attr(\"translateX\"), y = u.attr(\"translateY\"), B = u.attr(\"scaleX\"), l = u.attr(\"scaleY\"), u.attr({\n          animator: 0\n        }).animate({\n          animator: 1\n        }, {\n          step: function step(a, b) {\n            u.attr({\n              translateX: v + (n - v) * b.pos,\n              translateY: y + (q - y) * b.pos,\n              scaleX: B + (m - B) * b.pos,\n              scaleY: l + (p - l) * b.pos\n            });\n          }\n        })) : u.attr({\n          translateX: n,\n          translateY: q,\n          scaleX: m,\n          scaleY: p\n        }));\n        e.element.setAttribute(\"stroke-width\", (a.options[a.pointAttrToOptions && a.pointAttrToOptions[\"stroke-width\"] || \"borderWidth\"] || 1) / (m || 1));\n        this.drawMapDataLabels();\n      },\n      drawMapDataLabels: function drawMapDataLabels() {\n        y.prototype.drawDataLabels.call(this);\n        this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);\n      },\n      render: function render() {\n        var a = this,\n            c = y.prototype.render;\n        a.chart.renderer.isVML && 3E3 < a.data.length ? setTimeout(function () {\n          c.call(a);\n        }) : c.call(a);\n      },\n      animate: function animate(a) {\n        var b = this.options.animation,\n            d = this.group,\n            e = this.xAxis,\n            g = this.yAxis,\n            h = e.pos,\n            m = g.pos;\n        this.chart.renderer.isSVG && (!0 === b && (b = {\n          duration: 1E3\n        }), a ? d.attr({\n          translateX: h + e.len / 2,\n          translateY: m + g.len / 2,\n          scaleX: .001,\n          scaleY: .001\n        }) : (d.animate({\n          translateX: h,\n          translateY: m,\n          scaleX: 1,\n          scaleY: 1\n        }, b), this.animate = null));\n      },\n      animateDrilldown: function animateDrilldown(a) {\n        var b = this.chart.plotBox,\n            d = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1],\n            e = d.bBox,\n            g = this.chart.options.drilldown.animation;\n        a || (a = Math.min(e.width / b.width, e.height / b.height), d.shapeArgs = {\n          scaleX: a,\n          scaleY: a,\n          translateX: e.x,\n          translateY: e.y\n        }, C(this.points, function (a) {\n          a.graphic && a.graphic.attr(d.shapeArgs).animate({\n            scaleX: 1,\n            scaleY: 1,\n            translateX: 0,\n            translateY: 0\n          }, g);\n        }), this.animate = null);\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      animateDrillupFrom: function animateDrillupFrom(a) {\n        h.column.prototype.animateDrillupFrom.call(this, a);\n      },\n      animateDrillupTo: function animateDrillupTo(a) {\n        h.column.prototype.animateDrillupTo.call(this, a);\n      }\n    }), D({\n      applyOptions: function applyOptions(a, c) {\n        a = p.prototype.applyOptions.call(this, a, c);\n        c = this.series;\n        var b = c.joinBy;\n        c.mapData && ((b = void 0 !== a[b[1]] && c.mapMap[a[b[1]]]) ? (c.xyFromShape && (a.x = b._midX, a.y = b._midY), D(a, b)) : a.value = a.value || null);\n        return a;\n      },\n      onMouseOver: function onMouseOver(b) {\n        a.clearTimeout(this.colorInterval);\n        if (null !== this.value || this.series.options.nullInteraction) p.prototype.onMouseOver.call(this, b);else this.series.onMouseOut(b);\n      },\n      zoomTo: function zoomTo() {\n        var a = this.series;\n        a.xAxis.setExtremes(this._minX, this._maxX, !1);\n        a.yAxis.setExtremes(this._minY, this._maxY, !1);\n        a.chart.redraw();\n      }\n    }, B));\n  })(M);\n\n  (function (a) {\n    var B = a.seriesType,\n        C = a.seriesTypes;\n    B(\"mapline\", \"map\", {\n      lineWidth: 1,\n      fillColor: \"none\"\n    }, {\n      type: \"mapline\",\n      colorProp: \"stroke\",\n      pointAttrToOptions: {\n        stroke: \"color\",\n        \"stroke-width\": \"lineWidth\"\n      },\n      pointAttribs: function pointAttribs(a, n) {\n        a = C.map.prototype.pointAttribs.call(this, a, n);\n        a.fill = this.options.fillColor;\n        return a;\n      },\n      drawLegendSymbol: C.line.prototype.drawLegendSymbol\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.merge,\n        C = a.Point;\n    a = a.seriesType;\n    a(\"mappoint\", \"scatter\", {\n      dataLabels: {\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.name;\n        },\n        crop: !1,\n        defer: !1,\n        overflow: !1,\n        style: {\n          color: \"#000000\"\n        }\n      }\n    }, {\n      type: \"mappoint\",\n      forceDL: !0\n    }, {\n      applyOptions: function applyOptions(a, n) {\n        a = void 0 !== a.lat && void 0 !== a.lon ? B(a, this.series.chart.fromLatLonToPoint(a)) : a;\n        return C.prototype.applyOptions.call(this, a, n);\n      }\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.arrayMax,\n        C = a.arrayMin,\n        D = a.Axis,\n        n = a.color,\n        d = a.each,\n        k = a.isNumber,\n        u = a.noop,\n        v = a.pick,\n        q = a.pInt,\n        p = a.Point,\n        y = a.Series,\n        g = a.seriesType,\n        h = a.seriesTypes;\n    g(\"bubble\", \"scatter\", {\n      dataLabels: {\n        formatter: function formatter() {\n          return this.point.z;\n        },\n        inside: !0,\n        verticalAlign: \"middle\"\n      },\n      animationLimit: 250,\n      marker: {\n        lineColor: null,\n        lineWidth: 1,\n        fillOpacity: .5,\n        radius: null,\n        states: {\n          hover: {\n            radiusPlus: 0\n          }\n        },\n        symbol: \"circle\"\n      },\n      minSize: 8,\n      maxSize: \"20%\",\n      softThreshold: !1,\n      states: {\n        hover: {\n          halo: {\n            size: 5\n          }\n        }\n      },\n      tooltip: {\n        pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n      },\n      turboThreshold: 0,\n      zThreshold: 0,\n      zoneAxis: \"z\"\n    }, {\n      pointArrayMap: [\"y\", \"z\"],\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      bubblePadding: !0,\n      zoneAxis: \"z\",\n      directTouch: !0,\n      pointAttribs: function pointAttribs(a, b) {\n        var c = this.options.marker.fillOpacity;\n        a = y.prototype.pointAttribs.call(this, a, b);\n        1 !== c && (a.fill = n(a.fill).setOpacity(c).get(\"rgba\"));\n        return a;\n      },\n      getRadii: function getRadii(a, b, c, d) {\n        var e,\n            f,\n            g,\n            h = this.zData,\n            m = [],\n            p = this.options,\n            n = \"width\" !== p.sizeBy,\n            q = p.zThreshold,\n            u = b - a;\n        f = 0;\n\n        for (e = h.length; f < e; f++) {\n          g = h[f], p.sizeByAbsoluteValue && null !== g && (g = Math.abs(g - q), b = u = Math.max(b - q, Math.abs(a - q)), a = 0), k(g) ? g < a ? g = c / 2 - 1 : (g = 0 < u ? (g - a) / u : .5, n && 0 <= g && (g = Math.sqrt(g)), g = Math.ceil(c + g * (d - c)) / 2) : g = null, m.push(g);\n        }\n\n        this.radii = m;\n      },\n      animate: function animate(a) {\n        !a && this.points.length < this.options.animationLimit && (d(this.points, function (a) {\n          var b = a.graphic,\n              d;\n          b && b.width && (d = {\n            x: b.x,\n            y: b.y,\n            width: b.width,\n            height: b.height\n          }, b.attr({\n            x: a.plotX,\n            y: a.plotY,\n            width: 1,\n            height: 1\n          }), b.animate(d, this.options.animation));\n        }, this), this.animate = null);\n      },\n      translate: function translate() {\n        var d,\n            b = this.data,\n            c,\n            f,\n            e = this.radii;\n        h.scatter.prototype.translate.call(this);\n\n        for (d = b.length; d--;) {\n          c = b[d], f = e ? e[d] : 0, k(f) && f >= this.minPxSize / 2 ? (c.marker = a.extend(c.marker, {\n            radius: f,\n            width: 2 * f,\n            height: 2 * f\n          }), c.dlBox = {\n            x: c.plotX - f,\n            y: c.plotY - f,\n            width: 2 * f,\n            height: 2 * f\n          }) : c.shapeArgs = c.plotY = c.dlBox = void 0;\n        }\n      },\n      alignDataLabel: h.column.prototype.alignDataLabel,\n      buildKDTree: u,\n      applyZones: u\n    }, {\n      haloPath: function haloPath(a) {\n        return p.prototype.haloPath.call(this, 0 === a ? 0 : (this.marker ? this.marker.radius || 0 : 0) + a);\n      },\n      ttBelow: !1\n    });\n\n    D.prototype.beforePadding = function () {\n      var g = this,\n          b = this.len,\n          c = this.chart,\n          f = 0,\n          e = b,\n          h = this.isXAxis,\n          p = h ? \"xData\" : \"yData\",\n          n = this.min,\n          u = {},\n          y = Math.min(c.plotWidth, c.plotHeight),\n          D = Number.MAX_VALUE,\n          r = -Number.MAX_VALUE,\n          I = this.max - n,\n          E = b / I,\n          L = [];\n      d(this.series, function (b) {\n        var e = b.options;\n        !b.bubblePadding || !b.visible && c.options.chart.ignoreHiddenSeries || (g.allowZoomOutside = !0, L.push(b), h && (d([\"minSize\", \"maxSize\"], function (a) {\n          var b = e[a],\n              c = /%$/.test(b),\n              b = q(b);\n          u[a] = c ? y * b / 100 : b;\n        }), b.minPxSize = u.minSize, b.maxPxSize = Math.max(u.maxSize, u.minSize), b = a.grep(b.zData, a.isNumber), b.length && (D = v(e.zMin, Math.min(D, Math.max(C(b), !1 === e.displayNegative ? e.zThreshold : -Number.MAX_VALUE))), r = v(e.zMax, Math.max(r, B(b))))));\n      });\n      d(L, function (a) {\n        var b = a[p],\n            c = b.length,\n            d;\n        h && a.getRadii(D, r, a.minPxSize, a.maxPxSize);\n        if (0 < I) for (; c--;) {\n          k(b[c]) && g.dataMin <= b[c] && b[c] <= g.dataMax && (d = a.radii[c], f = Math.min((b[c] - n) * E - d, f), e = Math.max((b[c] - n) * E + d, e));\n        }\n      });\n      L.length && 0 < I && !this.isLog && (e -= b, E *= (b + Math.max(0, f) - Math.min(e, b)) / b, d([[\"min\", \"userMin\", f], [\"max\", \"userMax\", e]], function (a) {\n        void 0 === v(g.options[a[0]], g[a[1]]) && (g[a[0]] += a[2] / E);\n      }));\n    };\n  })(M);\n\n  (function (a) {\n    var B = a.merge,\n        C = a.Point,\n        D = a.seriesType,\n        n = a.seriesTypes;\n    n.bubble && D(\"mapbubble\", \"bubble\", {\n      animationLimit: 500,\n      tooltip: {\n        pointFormat: \"{point.name}: {point.z}\"\n      }\n    }, {\n      xyFromShape: !0,\n      type: \"mapbubble\",\n      pointArrayMap: [\"z\"],\n      getMapData: n.map.prototype.getMapData,\n      getBox: n.map.prototype.getBox,\n      setData: n.map.prototype.setData\n    }, {\n      applyOptions: function applyOptions(a, k) {\n        return a && void 0 !== a.lat && void 0 !== a.lon ? C.prototype.applyOptions.call(this, B(a, this.series.chart.fromLatLonToPoint(a)), k) : n.map.prototype.pointClass.prototype.applyOptions.call(this, a, k);\n      },\n      isValid: function isValid() {\n        return \"number\" === typeof this.z;\n      },\n      ttBelow: !1\n    });\n  })(M);\n\n  (function (a) {\n    var B = a.colorPointMixin,\n        C = a.each,\n        D = a.merge,\n        n = a.noop,\n        d = a.pick,\n        k = a.Series,\n        u = a.seriesType,\n        v = a.seriesTypes;\n    u(\"heatmap\", \"scatter\", {\n      animation: !1,\n      borderWidth: 0,\n      nullColor: \"#f7f7f7\",\n      dataLabels: {\n        formatter: function formatter() {\n          return this.point.value;\n        },\n        inside: !0,\n        verticalAlign: \"middle\",\n        crop: !1,\n        overflow: !1,\n        padding: 0\n      },\n      marker: null,\n      pointRange: null,\n      tooltip: {\n        pointFormat: \"{point.x}, {point.y}: {point.value}\\x3cbr/\\x3e\"\n      },\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .2\n        }\n      }\n    }, D(a.colorSeriesMixin, {\n      pointArrayMap: [\"y\", \"value\"],\n      hasPointSpecificOptions: !0,\n      getExtremesFromAll: !0,\n      directTouch: !0,\n      init: function init() {\n        var a;\n        v.scatter.prototype.init.apply(this, arguments);\n        a = this.options;\n        a.pointRange = d(a.pointRange, a.colsize || 1);\n        this.yAxis.axisPointRange = a.rowsize || 1;\n      },\n      translate: function translate() {\n        var a = this.options,\n            k = this.xAxis,\n            n = this.yAxis,\n            g = a.pointPadding || 0,\n            h = function h(a, b, c) {\n          return Math.min(Math.max(b, a), c);\n        };\n\n        this.generatePoints();\n        C(this.points, function (m) {\n          var b = (a.colsize || 1) / 2,\n              c = (a.rowsize || 1) / 2,\n              f = h(Math.round(k.len - k.translate(m.x - b, 0, 1, 0, 1)), -k.len, 2 * k.len),\n              b = h(Math.round(k.len - k.translate(m.x + b, 0, 1, 0, 1)), -k.len, 2 * k.len),\n              e = h(Math.round(n.translate(m.y - c, 0, 1, 0, 1)), -n.len, 2 * n.len),\n              c = h(Math.round(n.translate(m.y + c, 0, 1, 0, 1)), -n.len, 2 * n.len),\n              p = d(m.pointPadding, g);\n          m.plotX = m.clientX = (f + b) / 2;\n          m.plotY = (e + c) / 2;\n          m.shapeType = \"rect\";\n          m.shapeArgs = {\n            x: Math.min(f, b) + p,\n            y: Math.min(e, c) + p,\n            width: Math.abs(b - f) - 2 * p,\n            height: Math.abs(c - e) - 2 * p\n          };\n        });\n        this.translateColors();\n      },\n      drawPoints: function drawPoints() {\n        v.column.prototype.drawPoints.call(this);\n        C(this.points, function (a) {\n          a.graphic.attr(this.colorAttribs(a));\n        }, this);\n      },\n      animate: n,\n      getBox: n,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      alignDataLabel: v.column.prototype.alignDataLabel,\n      getExtremes: function getExtremes() {\n        k.prototype.getExtremes.call(this, this.valueData);\n        this.valueMin = this.dataMin;\n        this.valueMax = this.dataMax;\n        k.prototype.getExtremes.call(this);\n      }\n    }), a.extend({\n      haloPath: function haloPath(a) {\n        if (!a) return [];\n        var d = this.shapeArgs;\n        return [\"M\", d.x - a, d.y - a, \"L\", d.x - a, d.y + d.height + a, d.x + d.width + a, d.y + d.height + a, d.x + d.width + a, d.y - a, \"Z\"];\n      }\n    }, B));\n  })(M);\n\n  (function (a) {\n    function B(a, d) {\n      var k,\n          g,\n          h,\n          m = !1,\n          b = a.x,\n          c = a.y;\n      a = 0;\n\n      for (k = d.length - 1; a < d.length; k = a++) {\n        g = d[a][1] > c, h = d[k][1] > c, g !== h && b < (d[k][0] - d[a][0]) * (c - d[a][1]) / (d[k][1] - d[a][1]) + d[a][0] && (m = !m);\n      }\n\n      return m;\n    }\n\n    var C = a.Chart,\n        D = a.each,\n        n = a.extend,\n        d = a.format,\n        k = a.merge,\n        u = a.win,\n        v = a.wrap;\n\n    C.prototype.transformFromLatLon = function (d, k) {\n      if (void 0 === u.proj4) return a.error(21), {\n        x: 0,\n        y: null\n      };\n      d = u.proj4(k.crs, [d.lon, d.lat]);\n      var p = k.cosAngle || k.rotation && Math.cos(k.rotation),\n          g = k.sinAngle || k.rotation && Math.sin(k.rotation);\n      d = k.rotation ? [d[0] * p + d[1] * g, -d[0] * g + d[1] * p] : d;\n      return {\n        x: ((d[0] - (k.xoffset || 0)) * (k.scale || 1) + (k.xpan || 0)) * (k.jsonres || 1) + (k.jsonmarginX || 0),\n        y: (((k.yoffset || 0) - d[1]) * (k.scale || 1) + (k.ypan || 0)) * (k.jsonres || 1) - (k.jsonmarginY || 0)\n      };\n    };\n\n    C.prototype.transformToLatLon = function (d, k) {\n      if (void 0 === u.proj4) a.error(21);else {\n        d = {\n          x: ((d.x - (k.jsonmarginX || 0)) / (k.jsonres || 1) - (k.xpan || 0)) / (k.scale || 1) + (k.xoffset || 0),\n          y: ((-d.y - (k.jsonmarginY || 0)) / (k.jsonres || 1) + (k.ypan || 0)) / (k.scale || 1) + (k.yoffset || 0)\n        };\n        var p = k.cosAngle || k.rotation && Math.cos(k.rotation),\n            g = k.sinAngle || k.rotation && Math.sin(k.rotation);\n        k = u.proj4(k.crs, \"WGS84\", k.rotation ? {\n          x: d.x * p + d.y * -g,\n          y: d.x * g + d.y * p\n        } : d);\n        return {\n          lat: k.y,\n          lon: k.x\n        };\n      }\n    };\n\n    C.prototype.fromPointToLatLon = function (d) {\n      var k = this.mapTransforms,\n          n;\n\n      if (k) {\n        for (n in k) {\n          if (k.hasOwnProperty(n) && k[n].hitZone && B({\n            x: d.x,\n            y: -d.y\n          }, k[n].hitZone.coordinates[0])) return this.transformToLatLon(d, k[n]);\n        }\n\n        return this.transformToLatLon(d, k[\"default\"]);\n      }\n\n      a.error(22);\n    };\n\n    C.prototype.fromLatLonToPoint = function (d) {\n      var k = this.mapTransforms,\n          n,\n          g;\n      if (!k) return a.error(22), {\n        x: 0,\n        y: null\n      };\n\n      for (n in k) {\n        if (k.hasOwnProperty(n) && k[n].hitZone && (g = this.transformFromLatLon(d, k[n]), B({\n          x: g.x,\n          y: -g.y\n        }, k[n].hitZone.coordinates[0]))) return g;\n      }\n\n      return this.transformFromLatLon(d, k[\"default\"]);\n    };\n\n    a.geojson = function (a, k, u) {\n      var g = [],\n          h = [],\n          m = function m(a) {\n        var b,\n            d = a.length;\n        h.push(\"M\");\n\n        for (b = 0; b < d; b++) {\n          1 === b && h.push(\"L\"), h.push(a[b][0], -a[b][1]);\n        }\n      };\n\n      k = k || \"map\";\n      D(a.features, function (a) {\n        var b = a.geometry,\n            d = b.type,\n            b = b.coordinates;\n        a = a.properties;\n        var e;\n        h = [];\n        \"map\" === k || \"mapbubble\" === k ? (\"Polygon\" === d ? (D(b, m), h.push(\"Z\")) : \"MultiPolygon\" === d && (D(b, function (a) {\n          D(a, m);\n        }), h.push(\"Z\")), h.length && (e = {\n          path: h\n        })) : \"mapline\" === k ? (\"LineString\" === d ? m(b) : \"MultiLineString\" === d && D(b, m), h.length && (e = {\n          path: h\n        })) : \"mappoint\" === k && \"Point\" === d && (e = {\n          x: b[0],\n          y: -b[1]\n        });\n        e && g.push(n(e, {\n          name: a.name || a.NAME,\n          properties: a\n        }));\n      });\n      u && a.copyrightShort && (u.chart.mapCredits = d(u.chart.options.credits.mapText, {\n        geojson: a\n      }), u.chart.mapCreditsFull = d(u.chart.options.credits.mapTextFull, {\n        geojson: a\n      }));\n      return g;\n    };\n\n    v(C.prototype, \"addCredits\", function (a, d) {\n      d = k(!0, this.options.credits, d);\n      this.mapCredits && (d.href = null);\n      a.call(this, d);\n      this.credits && this.mapCreditsFull && this.credits.attr({\n        title: this.mapCreditsFull\n      });\n    });\n  })(M);\n\n  (function (a) {\n    function B(a, d, h, k, b, c, f, e) {\n      return [\"M\", a + b, d, \"L\", a + h - c, d, \"C\", a + h - c / 2, d, a + h, d + c / 2, a + h, d + c, \"L\", a + h, d + k - f, \"C\", a + h, d + k - f / 2, a + h - f / 2, d + k, a + h - f, d + k, \"L\", a + e, d + k, \"C\", a + e / 2, d + k, a, d + k - e / 2, a, d + k - e, \"L\", a, d + b, \"C\", a, d + b / 2, a + b / 2, d, a + b, d, \"Z\"];\n    }\n\n    var C = a.Chart,\n        D = a.defaultOptions,\n        n = a.each,\n        d = a.extend,\n        k = a.merge,\n        u = a.pick,\n        v = a.Renderer,\n        q = a.SVGRenderer,\n        p = a.VMLRenderer;\n    d(D.lang, {\n      zoomIn: \"Zoom in\",\n      zoomOut: \"Zoom out\"\n    });\n    D.mapNavigation = {\n      buttonOptions: {\n        alignTo: \"plotBox\",\n        align: \"left\",\n        verticalAlign: \"top\",\n        x: 0,\n        width: 18,\n        height: 18,\n        padding: 5,\n        style: {\n          fontSize: \"15px\",\n          fontWeight: \"bold\"\n        },\n        theme: {\n          \"stroke-width\": 1,\n          \"text-align\": \"center\"\n        }\n      },\n      buttons: {\n        zoomIn: {\n          onclick: function onclick() {\n            this.mapZoom(.5);\n          },\n          text: \"+\",\n          y: 0\n        },\n        zoomOut: {\n          onclick: function onclick() {\n            this.mapZoom(2);\n          },\n          text: \"-\",\n          y: 28\n        }\n      },\n      mouseWheelSensitivity: 1.1\n    };\n\n    a.splitPath = function (a) {\n      var d;\n      a = a.replace(/([A-Za-z])/g, \" $1 \");\n      a = a.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n      a = a.split(/[ ,]+/);\n\n      for (d = 0; d < a.length; d++) {\n        /[a-zA-Z]/.test(a[d]) || (a[d] = parseFloat(a[d]));\n      }\n\n      return a;\n    };\n\n    a.maps = {};\n\n    q.prototype.symbols.topbutton = function (a, d, h, k, b) {\n      return B(a - 1, d - 1, h, k, b.r, b.r, 0, 0);\n    };\n\n    q.prototype.symbols.bottombutton = function (a, d, h, k, b) {\n      return B(a - 1, d - 1, h, k, 0, 0, b.r, b.r);\n    };\n\n    v === p && n([\"topbutton\", \"bottombutton\"], function (a) {\n      p.prototype.symbols[a] = q.prototype.symbols[a];\n    });\n\n    a.Map = a.mapChart = function (d, g, h) {\n      var m = \"string\" === typeof d || d.nodeName,\n          b = arguments[m ? 1 : 0],\n          c = {\n        endOnTick: !1,\n        visible: !1,\n        minPadding: 0,\n        maxPadding: 0,\n        startOnTick: !1\n      },\n          f,\n          e = a.getOptions().credits;\n      f = b.series;\n      b.series = null;\n      b = k({\n        chart: {\n          panning: \"xy\",\n          type: \"map\"\n        },\n        credits: {\n          mapText: u(e.mapText, \" \\xA9 <a href=\\\"{geojson.copyrightUrl}\\\">{geojson.copyrightShort}</a>\"),\n          mapTextFull: u(e.mapTextFull, \"{geojson.copyright}\")\n        },\n        tooltip: {\n          followTouchMove: !1\n        },\n        xAxis: c,\n        yAxis: k(c, {\n          reversed: !0\n        })\n      }, b, {\n        chart: {\n          inverted: !1,\n          alignTicks: !1\n        }\n      });\n      b.series = f;\n      return m ? new C(d, b, h) : new C(b, g);\n    };\n  })(M);\n\n  return M;\n});","map":null,"metadata":{},"sourceType":"script"}